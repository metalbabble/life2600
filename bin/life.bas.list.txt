------- FILE C:\Users\afloc\Source\Repos\life2600\bin\life.bas.asm LEVEL 1 PASS 3
      1  8400					      processor	6502
------- FILE vcs.h LEVEL 2 PASS 3
      0  8400 ????				      include	"vcs.h"
      1  8400 ????						; VCS.H
      2  8400 ????						; Version 1.05, 13/November/2003
      3  8400 ????
      4  8400 ????	       00 69	   VERSION_VCS =	105
      5  8400 ????
      6  8400 ????						; THIS IS A PRELIMINARY RELEASE OF *THE* "STANDARD" VCS.H
      7  8400 ????						; THIS FILE IS EXPLICITLY SUPPORTED AS A DASM-PREFERRED COMPANION FILE
      8  8400 ????						; PLEASE DO *NOT* REDISTRIBUTE THIS FILE!
      9  8400 ????						;
     10  8400 ????						; This file defines hardware registers and memory mapping for the
     11  8400 ????						; Atari 2600. It is distributed as a companion machine-specific support package
     12  8400 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
     13  8400 ????						; available at at http://www.atari2600.org/dasm
     14  8400 ????						;
     15  8400 ????						; Many thanks to the original author(s) of this file, and to everyone who has
     16  8400 ????						; contributed to understanding the Atari 2600.  If you take issue with the
     17  8400 ????						; contents, or naming of registers, please write to me (atari2600@taswegian.com)
     18  8400 ????						; with your views.  Please contribute, if you think you can improve this
     19  8400 ????						; file!
     20  8400 ????						;
     21  8400 ????						; Latest Revisions...
     22  8400 ????						; 1.05  13/NOV/2003	  - Correction to 1.04 - now functions as requested by MR.
     23  8400 ????						;			  - Added VERSION_VCS equate (which will reflect 100x version #)
     24  8400 ????						;			    This will allow conditional code to verify VCS.H being
     25  8400 ????						;			    used for code assembly.
     26  8400 ????						; 1.04  12/NOV/2003	 Added TIA_BASE_WRITE_ADDRESS and TIA_BASE_READ_ADDRESS for
     27  8400 ????						;			 convenient disassembly/reassembly compatibility for hardware
     28  8400 ????						;			 mirrored reading/writing differences.	This is more a
     29  8400 ????						;			 readability issue, and binary compatibility with disassembled
     30  8400 ????						;			 and reassembled sources.  Per Manuel Rotschkar's suggestion.
     31  8400 ????						; 1.03  12/MAY/2003	 Added SEG segment at end of file to fix old-code compatibility
     32  8400 ????						;			 which was broken by the use of segments in this file, as
     33  8400 ????						;			 reported by Manuel Polik on [stella] 11/MAY/2003
     34  8400 ????						; 1.02  22/MAR/2003	 Added TIMINT($285)
     35  8400 ????						; 1.01				Constant offset added to allow use for 3F-style bankswitching
     36  8400 ????						;						 - define TIA_BASE_ADDRESS as $40 for Tigervision carts, otherwise
     37  8400 ????						;						   it is safe to leave it undefined, and the base address will
     38  8400 ????						;						   be set to 0.  Thanks to Eckhard Stolberg for the suggestion.
     39  8400 ????						;			    Note, may use -DLABEL=EXPRESSION to define TIA_BASE_ADDRESS
     40  8400 ????						;			  - register definitions are now generated through assignment
     41  8400 ????						;			    in uninitialised segments.	This allows a changeable base
     42  8400 ????						;			    address architecture.
     43  8400 ????						; 1.0	22/MAR/2003		Initial release
     44  8400 ????
     45  8400 ????
     46  8400 ????						;-------------------------------------------------------------------------------
     47  8400 ????
     48  8400 ????						; TIA_BASE_ADDRESS
     49  8400 ????						; The TIA_BASE_ADDRESS defines the base address of access to TIA registers.
     50  8400 ????						; Normally 0, the base address should (externally, before including this file)
     51  8400 ????						; be set to $40 when creating 3F-bankswitched (and other?) cartridges.
     52  8400 ????						; The reason is that this bankswitching scheme treats any access to locations
     53  8400 ????						; < $40 as a bankswitch.
     54  8400 ????
     55  8400 ????			  -	      IFNCONST	TIA_BASE_ADDRESS
     56  8400 ????			  -TIA_BASE_ADDRESS =	0
     57  8400 ????				      ENDIF
     58  8400 ????
     59  8400 ????						; Note: The address may be defined on the command-line using the -D switch, eg:
     60  8400 ????						; dasm.exe code.asm -DTIA_BASE_ADDRESS=$40 -f3 -v5 -ocode.bin
     61  8400 ????						; *OR* by declaring the label before including this file, eg:
     62  8400 ????						; TIA_BASE_ADDRESS = $40
     63  8400 ????						;   include "vcs.h"
     64  8400 ????
     65  8400 ????						; Alternate read/write address capability - allows for some disassembly compatibility
     66  8400 ????						; usage ; to allow reassembly to binary perfect copies).  This is essentially catering
     67  8400 ????						; for the mirrored ROM hardware registers.
     68  8400 ????
     69  8400 ????						; Usage: As per above, define the TIA_BASE_READ_ADDRESS and/or TIA_BASE_WRITE_ADDRESS
     70  8400 ????						; using the -D command-line switch, as required.  If the addresses are not defined,
     71  8400 ????						; they defaut to the TIA_BASE_ADDRESS.
     72  8400 ????
     73  8400 ????			  -	      IFNCONST	TIA_BASE_READ_ADDRESS
     74  8400 ????			  -TIA_BASE_READ_ADDRESS =	TIA_BASE_ADDRESS
     75  8400 ????				      ENDIF
     76  8400 ????
     77  8400 ????			  -	      IFNCONST	TIA_BASE_WRITE_ADDRESS
     78  8400 ????			  -TIA_BASE_WRITE_ADDRESS =	TIA_BASE_ADDRESS
     79  8400 ????				      ENDIF
     80  8400 ????
     81  8400 ????						;-------------------------------------------------------------------------------
     82  8400 ????
     83 U002d ????				      SEG.U	TIA_REGISTERS_WRITE
     84 U0000					      ORG	TIA_BASE_WRITE_ADDRESS
     85 U0000
     86 U0000							; DO NOT CHANGE THE RELATIVE ORDERING OF REGISTERS!
     87 U0000
     88 U0000		       00	   VSYNC      ds	1	; $00	 0000 00x0   Vertical Sync Set-Clear
     89 U0001		       00	   VBLANK     ds	1	; $01	 xx00 00x0   Vertical Blank Set-Clear
     90 U0002		       00	   WSYNC      ds	1	; $02	 ---- ----   Wait for Horizontal Blank
     91 U0003		       00	   RSYNC      ds	1	; $03	 ---- ----   Reset Horizontal Sync Counter
     92 U0004		       00	   NUSIZ0     ds	1	; $04	 00xx 0xxx   Number-Size player/missle 0
     93 U0005		       00	   NUSIZ1     ds	1	; $05	 00xx 0xxx   Number-Size player/missle 1
     94 U0006		       00	   COLUP0     ds	1	; $06	 xxxx xxx0   Color-Luminance Player 0
     95 U0007		       00	   COLUP1     ds	1	; $07	 xxxx xxx0   Color-Luminance Player 1
     96 U0008		       00	   COLUPF     ds	1	; $08	 xxxx xxx0   Color-Luminance Playfield
     97 U0009		       00	   COLUBK     ds	1	; $09	 xxxx xxx0   Color-Luminance Background
     98 U000a		       00	   CTRLPF     ds	1	; $0A	 00xx 0xxx   Control Playfield, Ball, Collisions
     99 U000b		       00	   REFP0      ds	1	; $0B	 0000 x000   Reflection Player 0
    100 U000c		       00	   REFP1      ds	1	; $0C	 0000 x000   Reflection Player 1
    101 U000d		       00	   PF0	      ds	1	; $0D	 xxxx 0000   Playfield Register Byte 0
    102 U000e		       00	   PF1	      ds	1	; $0E	 xxxx xxxx   Playfield Register Byte 1
    103 U000f		       00	   PF2	      ds	1	; $0F	 xxxx xxxx   Playfield Register Byte 2
    104 U0010		       00	   RESP0      ds	1	; $10	 ---- ----   Reset Player 0
    105 U0011		       00	   RESP1      ds	1	; $11	 ---- ----   Reset Player 1
    106 U0012		       00	   RESM0      ds	1	; $12	 ---- ----   Reset Missle 0
    107 U0013		       00	   RESM1      ds	1	; $13	 ---- ----   Reset Missle 1
    108 U0014		       00	   RESBL      ds	1	; $14	 ---- ----   Reset Ball
    109 U0015		       00	   AUDC0      ds	1	; $15	 0000 xxxx   Audio Control 0
    110 U0016		       00	   AUDC1      ds	1	; $16	 0000 xxxx   Audio Control 1
    111 U0017		       00	   AUDF0      ds	1	; $17	 000x xxxx   Audio Frequency 0
    112 U0018		       00	   AUDF1      ds	1	; $18	 000x xxxx   Audio Frequency 1
    113 U0019		       00	   AUDV0      ds	1	; $19	 0000 xxxx   Audio Volume 0
    114 U001a		       00	   AUDV1      ds	1	; $1A	 0000 xxxx   Audio Volume 1
    115 U001b		       00	   GRP0       ds	1	; $1B	 xxxx xxxx   Graphics Register Player 0
    116 U001c		       00	   GRP1       ds	1	; $1C	 xxxx xxxx   Graphics Register Player 1
    117 U001d		       00	   ENAM0      ds	1	; $1D	 0000 00x0   Graphics Enable Missle 0
    118 U001e		       00	   ENAM1      ds	1	; $1E	 0000 00x0   Graphics Enable Missle 1
    119 U001f		       00	   ENABL      ds	1	; $1F	 0000 00x0   Graphics Enable Ball
    120 U0020		       00	   HMP0       ds	1	; $20	 xxxx 0000   Horizontal Motion Player 0
    121 U0021		       00	   HMP1       ds	1	; $21	 xxxx 0000   Horizontal Motion Player 1
    122 U0022		       00	   HMM0       ds	1	; $22	 xxxx 0000   Horizontal Motion Missle 0
    123 U0023		       00	   HMM1       ds	1	; $23	 xxxx 0000   Horizontal Motion Missle 1
    124 U0024		       00	   HMBL       ds	1	; $24	 xxxx 0000   Horizontal Motion Ball
    125 U0025		       00	   VDELP0     ds	1	; $25	 0000 000x   Vertical Delay Player 0
    126 U0026		       00	   VDELP1     ds	1	; $26	 0000 000x   Vertical Delay Player 1
    127 U0027		       00	   VDELBL     ds	1	; $27	 0000 000x   Vertical Delay Ball
    128 U0028		       00	   RESMP0     ds	1	; $28	 0000 00x0   Reset Missle 0 to Player 0
    129 U0029		       00	   RESMP1     ds	1	; $29	 0000 00x0   Reset Missle 1 to Player 1
    130 U002a		       00	   HMOVE      ds	1	; $2A	 ---- ----   Apply Horizontal Motion
    131 U002b		       00	   HMCLR      ds	1	; $2B	 ---- ----   Clear Horizontal Move Registers
    132 U002c		       00	   CXCLR      ds	1	; $2C	 ---- ----   Clear Collision Latches
    133 U002d
    134 U002d							;-------------------------------------------------------------------------------
    135 U002d
    136 U000e ????				      SEG.U	TIA_REGISTERS_READ
    137 U0000					      ORG	TIA_BASE_READ_ADDRESS
    138 U0000
    139 U0000							;											bit 7	 bit 6
    140 U0000		       00	   CXM0P      ds	1	; $00	     xx00 0000	     Read Collision  M0-P1   M0-P0
    141 U0001		       00	   CXM1P      ds	1	; $01	     xx00 0000			     M1-P0   M1-P1
    142 U0002		       00	   CXP0FB     ds	1	; $02	     xx00 0000			     P0-PF   P0-BL
    143 U0003		       00	   CXP1FB     ds	1	; $03	     xx00 0000			     P1-PF   P1-BL
    144 U0004		       00	   CXM0FB     ds	1	; $04	     xx00 0000			     M0-PF   M0-BL
    145 U0005		       00	   CXM1FB     ds	1	; $05	     xx00 0000			     M1-PF   M1-BL
    146 U0006		       00	   CXBLPF     ds	1	; $06	     x000 0000			     BL-PF   -----
    147 U0007		       00	   CXPPMM     ds	1	; $07	     xx00 0000			     P0-P1   M0-M1
    148 U0008		       00	   INPT0      ds	1	; $08	     x000 0000	     Read Pot Port 0
    149 U0009		       00	   INPT1      ds	1	; $09	     x000 0000	     Read Pot Port 1
    150 U000a		       00	   INPT2      ds	1	; $0A	     x000 0000	     Read Pot Port 2
    151 U000b		       00	   INPT3      ds	1	; $0B	     x000 0000	     Read Pot Port 3
    152 U000c		       00	   INPT4      ds	1	; $0C		x000 0000	 Read Input (Trigger) 0
    153 U000d		       00	   INPT5      ds	1	; $0D		x000 0000	 Read Input (Trigger) 1
    154 U000e
    155 U000e							;-------------------------------------------------------------------------------
    156 U000e
    157 U0298 ????				      SEG.U	RIOT
    158 U0280					      ORG	$280
    159 U0280
    160 U0280							; RIOT MEMORY MAP
    161 U0280
    162 U0280		       00	   SWCHA      ds	1	; $280      Port A data register for joysticks:
    163 U0281							;			Bits 4-7 for player 1.  Bits 0-3 for player 2.
    164 U0281
    165 U0281		       00	   SWACNT     ds	1	; $281      Port A data direction register (DDR)
    166 U0282		       00	   SWCHB      ds	1	; $282		Port B data (console switches)
    167 U0283		       00	   SWBCNT     ds	1	; $283      Port B DDR
    168 U0284		       00	   INTIM      ds	1	; $284		Timer output
    169 U0285
    170 U0285		       00	   TIMINT     ds	1	; $285
    171 U0286
    172 U0286							; Unused/undefined registers ($285-$294)
    173 U0286
    174 U0286		       00		      ds	1	; $286
    175 U0287		       00		      ds	1	; $287
    176 U0288		       00		      ds	1	; $288
    177 U0289		       00		      ds	1	; $289
    178 U028a		       00		      ds	1	; $28A
    179 U028b		       00		      ds	1	; $28B
    180 U028c		       00		      ds	1	; $28C
    181 U028d		       00		      ds	1	; $28D
    182 U028e		       00		      ds	1	; $28E
    183 U028f		       00		      ds	1	; $28F
    184 U0290		       00		      ds	1	; $290
    185 U0291		       00		      ds	1	; $291
    186 U0292		       00		      ds	1	; $292
    187 U0293		       00		      ds	1	; $293
    188 U0294
    189 U0294		       00	   TIM1T      ds	1	; $294		set 1 clock interval
    190 U0295		       00	   TIM8T      ds	1	; $295      set 8 clock interval
    191 U0296		       00	   TIM64T     ds	1	; $296      set 64 clock interval
    192 U0297		       00	   T1024T     ds	1	; $297      set 1024 clock interval
    193 U0298
    194 U0298							;-------------------------------------------------------------------------------
    195 U0298							; The following required for back-compatibility with code which does not use
    196 U0298							; segments.
    197 U0298
    198  8400 ????				      SEG
    199  8400 ????
    200  8400 ????						; EOF
------- FILE C:\Users\afloc\Source\Repos\life2600\bin\life.bas.asm
------- FILE macro.h LEVEL 2 PASS 3
      0  8400 ????				      include	"macro.h"
      1  8400 ????						; MACRO.H
      2  8400 ????						; Version 1.05, 13/NOVEMBER/2003
      3  8400 ????
      4  8400 ????	       00 69	   VERSION_MACRO =	105
      5  8400 ????
      6  8400 ????						;
      7  8400 ????						; THIS FILE IS EXPLICITLY SUPPORTED AS A DASM-PREFERRED COMPANION FILE
      8  8400 ????						; PLEASE DO *NOT* REDISTRIBUTE MODIFIED VERSIONS OF THIS FILE!
      9  8400 ????						;
     10  8400 ????						; This file defines DASM macros useful for development for the Atari 2600.
     11  8400 ????						; It is distributed as a companion machine-specific support package
     12  8400 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
     13  8400 ????						; available at at http://www.atari2600.org/dasm
     14  8400 ????						;
     15  8400 ????						; Many thanks to the people who have contributed.  If you take issue with the
     16  8400 ????						; contents, or would like to add something, please write to me
     17  8400 ????						; (atari2600@taswegian.com) with your contribution.
     18  8400 ????						;
     19  8400 ????						; Latest Revisions...
     20  8400 ????						;
     21  8400 ????						; 1.05  14/NOV/2003	  - Added VERSION_MACRO equate (which will reflect 100x version #)
     22  8400 ????						;			    This will allow conditional code to verify MACRO.H being
     23  8400 ????						;			    used for code assembly.
     24  8400 ????						; 1.04  13/NOV/2003	 - SET_POINTER macro added (16-bit address load)
     25  8400 ????						;
     26  8400 ????						; 1.03  23/JUN/2003	 - CLEAN_START macro added - clears TIA, RAM, registers
     27  8400 ????						;
     28  8400 ????						; 1.02  14/JUN/2003	 - VERTICAL_SYNC macro added
     29  8400 ????						;			   (standardised macro for vertical synch code)
     30  8400 ????						; 1.01  22/MAR/2003	 - SLEEP macro added.
     31  8400 ????						;			 - NO_ILLEGAL_OPCODES switch implemented
     32  8400 ????						; 1.0	22/MAR/2003		Initial release
     33  8400 ????
     34  8400 ????						; Note: These macros use illegal opcodes.  To disable illegal opcode usage,
     35  8400 ????						;   define the symbol NO_ILLEGAL_OPCODES (-DNO_ILLEGAL_OPCODES=1 on command-line).
     36  8400 ????						;   If you do not allow illegal opcode usage, you must include this file
     37  8400 ????						;   *after* including VCS.H (as the non-illegal opcodes access hardware
     38  8400 ????						;   registers and require them to be defined first).
     39  8400 ????
     40  8400 ????						; Available macros...
     41  8400 ????						;   SLEEP n		 - sleep for n cycles
     42  8400 ????						;   VERTICAL_SYNC	 - correct 3 scanline vertical synch code
     43  8400 ????						;   CLEAN_START	 - set machine to known state on startup
     44  8400 ????						;   SET_POINTER	 - load a 16-bit absolute to a 16-bit variable
     45  8400 ????
     46  8400 ????						;-------------------------------------------------------------------------------
     47  8400 ????						; SLEEP duration
     48  8400 ????						; Original author: Thomas Jentzsch
     49  8400 ????						; Inserts code which takes the specified number of cycles to execute.	This is
     50  8400 ????						; useful for code where precise timing is required.
     51  8400 ????						; ILLEGAL-OPCODE VERSION DOES NOT AFFECT FLAGS OR REGISTERS.
     52  8400 ????						; LEGAL OPCODE VERSION MAY AFFECT FLAGS
     53  8400 ????						; Uses illegal opcode (DASM 2.20.01 onwards).
     54  8400 ????
     55  8400 ????				      MAC	sleep
     56  8400 ????			   .CYCLES    SET	{1}
     57  8400 ????
     58  8400 ????				      IF	.CYCLES < 2
     59  8400 ????				      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
     60  8400 ????				      ERR
     61  8400 ????				      ENDIF
     62  8400 ????
     63  8400 ????				      IF	.CYCLES & 1
     64  8400 ????				      IFNCONST	NO_ILLEGAL_OPCODES
     65  8400 ????				      nop	0
     66  8400 ????				      ELSE
     67  8400 ????				      bit	VSYNC
     68  8400 ????				      ENDIF
     69  8400 ????			   .CYCLES    SET	.CYCLES - 3
     70  8400 ????				      ENDIF
     71  8400 ????
     72  8400 ????				      REPEAT	.CYCLES / 2
     73  8400 ????				      nop
     74  8400 ????				      REPEND
     75  8400 ????				      ENDM		;usage: SLEEP n (n>1)
     76  8400 ????
     77  8400 ????						;-------------------------------------------------------------------------------
     78  8400 ????						; VERTICAL_SYNC
     79  8400 ????						; Original author: Manuel Polik
     80  8400 ????						; Inserts the code required for a proper 3 scannline
     81  8400 ????						; vertical sync sequence
     82  8400 ????						;
     83  8400 ????						; Note: Alters the accumulator
     84  8400 ????						;
     85  8400 ????						; IN:
     86  8400 ????						; OUT: A = 1
     87  8400 ????
     88  8400 ????				      MAC	vertical_sync
     89  8400 ????				      LDA	#$02	; A = VSYNC enable
     90  8400 ????				      STA	WSYNC	; Finish current line
     91  8400 ????				      STA	VSYNC	; Start vertical sync
     92  8400 ????				      STA	WSYNC	; 1st line vertical sync
     93  8400 ????				      STA	WSYNC	; 2nd line vertical sync
     94  8400 ????				      LSR		; A = VSYNC disable
     95  8400 ????				      STA	WSYNC	; 3rd line vertical sync
     96  8400 ????				      STA	VSYNC	; Stop vertical sync
     97  8400 ????				      ENDM
     98  8400 ????
     99  8400 ????						;-------------------------------------------------------------------------------
    100  8400 ????						; CLEAN_START
    101  8400 ????						; Original author: Andrew Davie
    102  8400 ????						; Standardised start-up code, clears stack, all TIA registers and RAM to 0
    103  8400 ????						; Sets stack pointer to $FF, and all registers to 0
    104  8400 ????						; Sets decimal mode off, sets interrupt flag (kind of un-necessary)
    105  8400 ????						; Use as very first section of code on boot (ie: at reset)
    106  8400 ????						; Code written to minimise total ROM usage - uses weird 6502 knowledge :)
    107  8400 ????
    108  8400 ????				      MAC	clean_start
    109  8400 ????				      sei
    110  8400 ????				      cld
    111  8400 ????
    112  8400 ????				      ldx	#0
    113  8400 ????				      txa
    114  8400 ????				      tay
    115  8400 ????			   .CLEAR_STACK dex
    116  8400 ????				      txs
    117  8400 ????				      pha
    118  8400 ????				      bne	.CLEAR_STACK	; SP=$FF, X = A = Y = 0
    119  8400 ????
    120  8400 ????				      ENDM
    121  8400 ????
    122  8400 ????						;-------------------------------------------------------
    123  8400 ????						; SET_POINTER
    124  8400 ????						; Original author: Manuel Rotschkar
    125  8400 ????						;
    126  8400 ????						; Sets a 2 byte RAM pointer to an absolute address.
    127  8400 ????						;
    128  8400 ????						; Usage: SET_POINTER pointer, address
    129  8400 ????						; Example: SET_POINTER SpritePTR, SpriteData
    130  8400 ????						;
    131  8400 ????						; Note: Alters the accumulator, NZ flags
    132  8400 ????						; IN 1: 2 byte RAM location reserved for pointer
    133  8400 ????						; IN 2: absolute address
    134  8400 ????
    135  8400 ????				      MAC	set_pointer
    136  8400 ????			   .POINTER   SET	{1}
    137  8400 ????			   .ADDRESS   SET	{2}
    138  8400 ????
    139  8400 ????				      LDA	#<.ADDRESS	; Get Lowbyte of Address
    140  8400 ????				      STA	.POINTER	; Store in pointer
    141  8400 ????				      LDA	#>.ADDRESS	; Get Hibyte of Address
    142  8400 ????				      STA	.POINTER+1	; Store in pointer+1
    143  8400 ????
    144  8400 ????				      ENDM
    145  8400 ????
    146  8400 ????						; EOF
------- FILE C:\Users\afloc\Source\Repos\life2600\bin\life.bas.asm
------- FILE DPCplus.h LEVEL 2 PASS 3
      0  8400 ????				      include	"DPCplus.h"
      1  8400 ????						; DPCplus.H - Display Processor Chip Plus Definitions
      2  8400 ????						; Chris Walton, Fred Quimby, Darrell Spice 2010
      3  8400 ????						; Version 0.00
      4  8400 ????
      5  8400 ????						; DPC Base Address
      6  8400 ????			  -	      IFNCONST	DPC_BASE_ADDRESS
      7  8400 ????			  -DPC_BASE_ADDRESS =	$1000
      8  8400 ????				      ENDIF
      9  8400 ????
     10  8400 ????						; DPC Read Base
     11  8400 ????			  -	      IFNCONST	DPC_BASE_READ_ADDRESS
     12  8400 ????			  -DPC_BASE_READ_ADDRESS =	DPC_BASE_ADDRESS
     13  8400 ????				      ENDIF
     14  8400 ????
     15  8400 ????						; DPC Write Base
     16  8400 ????			  -	      IFNCONST	DPC_BASE_WRITE_ADDRESS
     17  8400 ????			  -DPC_BASE_WRITE_ADDRESS =	DPC_BASE_ADDRESS+$28
     18  8400 ????				      ENDIF
     19  8400 ????
     20 U1028 ????				      SEG.U	DPC_REGISTERS_READ
     21 U1000					      ORG	DPC_BASE_READ_ADDRESS
     22 U1000
     23 U1000							;****************************************
     24 U1000							; DPC+ Read Registers
     25 U1000							;****************************************
     26 U1000							;
     27 U1000							;----------------------------------------
     28 U1000							; Random Numbers
     29 U1000							;----------------------------------------
     30 U1000							; DPC+ provides a 32 bit LFSR (Linear feedback shift register)
     31 U1000							; which is used as a random number generator.	Each individual byte of the
     32 U1000							; random number will return values from 0-255.  The random numbers will follow
     33 U1000							; an exact sequence, so it's best to clock them at least once per frame even if
     34 U1000							; you don't need the value (this allows the amount of time it takes the user to
     35 U1000							; start the game to select a random starting point in the sequence)
     36 U1000							;----------------------------------------
     37 U1000		       00	   RANDOM0NEXT DS	1	; $00 clock next 32 bit number and returns byte 0
     38 U1001		       00	   RANDOM0PRIOR DS	1	; $01 clock prior 32 bit number and returns byte 0
     39 U1002		       00	   RANDOM1    DS	1	; $02 returns byte 1 of random number w/out clock
     40 U1003		       00	   RANDOM2    DS	1	; $03 returns byte 2 of random number w/out clock
     41 U1004		       00	   RANDOM3    DS	1	; $04 returns byte 3 of random number w/out clock
     42 U1005
     43 U1005							;----------------------------------------
     44 U1005							; Music Fetcher
     45 U1005							;----------------------------------------
     46 U1005							; When generating music, this value must be read every single scanline and
     47 U1005							; stored into AUDV0.
     48 U1005							;----------------------------------------
     49 U1005		       00	   AMPLITUDE  DS	1	; $05
     50 U1006
     51 U1006							;----------------------------------------
     52 U1006							; Reserved
     53 U1006							;----------------------------------------
     54 U1006		       00		      DS	1	; $06
     55 U1007		       00		      DS	1	; $07
     56 U1008
     57 U1008							;----------------------------------------
     58 U1008							; Data Fetcher
     59 U1008							;----------------------------------------
     60 U1008							; There are 8 Data Fetchers which are used to access data stored in the Display
     61 U1008							; Data bank.  Before using, you must point the Data Fetcher at the data to read
     62 U1008							; via DFxLOW and DFxHI.  After each read the Data Fetcher will update to point
     63 U1008							; to the next byte of data to return.
     64 U1008							;
     65 U1008							; psuedo code* to point Data Fetcher 1 to the color data
     66 U1008							;	lda #<(ColorDataPosition - HowFarDownScreen)
     67 U1008							;	sta DF1LOW
     68 U1008							;	lda #>(ColorDataPosition - HowFarDownScreen)
     69 U1008							;	sta DF1HI
     70 U1008							;	....
     71 U1008							; then in the kernel read the Data Fetcher and update the color, takes 7 cycles
     72 U1008							;	LDA DF1DATA
     73 U1008							;	STA COLUP0
     74 U1008							;
     75 U1008							; * see DPCplus.asm for actual code
     76 U1008							;----------------------------------------
     77 U1008		       00	   DF0DATA    DS	1	; $08
     78 U1009		       00	   DF1DATA    DS	1	; $09
     79 U100a		       00	   DF2DATA    DS	1	; $0A
     80 U100b		       00	   DF3DATA    DS	1	; $0B
     81 U100c		       00	   DF4DATA    DS	1	; $0C
     82 U100d		       00	   DF5DATA    DS	1	; $0D
     83 U100e		       00	   DF6DATA    DS	1	; $0E
     84 U100f		       00	   DF7DATA    DS	1	; $0F
     85 U1010
     86 U1010							;----------------------------------------
     87 U1010							; Data Fetcher, Windowed
     88 U1010							;----------------------------------------
     89 U1010							; The 8 Data Fetchers can also be read in a "windowed" mode, which is most
     90 U1010							; commonly used to update sprites.  To use windowed mode, point the Data
     91 U1010							; Fetcher the same as above, but then also set the Top and Bottom of the
     92 U1010							; Window using DFxTOP and DFxBOT.  When reading via the DFxDATAW registers, a 0
     93 U1010							; value will be returned for anything that's outside of the window.
     94 U1010							;
     95 U1010							; psuedo code to point Data Fetcher0 to the sprite data
     96 U1010							;	lda #<(SpriteDataPosition - HowFarDownScreen)
     97 U1010							;	sta DF0LOW
     98 U1010							;	lda #>(SpriteDataPosition - HowFarDownScreen)
     99 U1010							;	sta DF0HI
    100 U1010							;
    101 U1010							; set the window for Data Fetcher 0
    102 U1010							;	lda #<(SpriteDataPosition - 1)
    103 U1010							;	sta DF0TOP
    104 U1010							;	lda #<(SpriteDataPosition + ImageHeight)
    105 U1010							;	sta DF0BOT
    106 U1010							;	....
    107 U1010							; then in the kernel read the Data Fetcher and update the sprite, takes 7 cycles
    108 U1010							;	LDA DF0DATAW
    109 U1010							;	STA GRP0
    110 U1010							;----------------------------------------
    111 U1010		       00	   DF0DATAW   DS	1	; $10
    112 U1011		       00	   DF1DATAW   DS	1	; $11
    113 U1012		       00	   DF2DATAW   DS	1	; $12
    114 U1013		       00	   DF3DATAW   DS	1	; $13
    115 U1014		       00	   DF4DATAW   DS	1	; $14
    116 U1015		       00	   DF5DATAW   DS	1	; $15
    117 U1016		       00	   DF6DATAW   DS	1	; $16
    118 U1017		       00	   DF7DATAW   DS	1	; $17
    119 U1018
    120 U1018							;----------------------------------------
    121 U1018							; Fractional Data Fetcher
    122 U1018							;----------------------------------------
    123 U1018							; Another 8 Data Fetchers exist which work differently than the first 8.
    124 U1018							; These allow you to fractionally increment the Data Fetcher so a single
    125 U1018							; value can be read a set number of times before advancing to the next value.
    126 U1018							; This is commonly used to draw asymmetrical playfields without needing to
    127 U1018							; use 1200 bytes of data (200 scanlines * 6 playfield updates).
    128 U1018							; Before using, you must point the Fractional Data Fetcher at the data to read
    129 U1018							; via DFxFRACLOW and DFxFRACHI.  You must also set the increment value via
    130 U1018							; DFxFRACINC.
    131 U1018							;
    132 U1018							; Set pointer
    133 U1018							;	LDA #<PlayfieldPF0l
    134 U1018							;	STA DF0FRACLOW
    135 U1018							;	... repeat for PF1l, PF2l, PF0r, PF1r and PF2r
    136 U1018							;	lda #>PlayFieldPF0l
    137 U1018							;	STA DF0FRACHI
    138 U1018							;	... repeat for PF1l, PF2l, PF0r, PF1r and PF2r
    139 U1018							; Set the increment to repeat the value for x reads
    140 U1018							;	LDA #(256/x)
    141 U1018							;	STA DF0FRACINC
    142 U1018							;	 STA DF1FRACINC
    143 U1018							;	... repeat for 2-5
    144 U1018							;
    145 U1018							; Special Condition - IF you want to increment the pointer after every read
    146 U1018							; (just like the normal Data Fetcher), then use the following to set the
    147 U1018							; increment AND prime the Fractional Data Fetcher
    148 U1018							;	LDA #255
    149 U1018							;	STA DF0FRACINC
    150 U1018							;	 STA DF1FRACINC
    151 U1018							;	... repeat for 2-5
    152 U1018							;	LDA DF0FRACDATA - priming read (first value will be read twice)
    153 U1018							;	LDA DF1FRACDATA - priming read (first value will be read twice)
    154 U1018							;	... repeat for 2-5
    155 U1018							;
    156 U1018							; then in the kernel read the Fractional Data Fetchers and update the playfield
    157 U1018							;	LDA DF0FRACDATA
    158 U1018							;	STA PF0
    159 U1018							;	LDA PF1FRACDATA
    160 U1018							;	STA PF1
    161 U1018							;	... repeat for Data Fetchers 2-5, putting them in PF2, PF0, PF1 and PF2
    162 U1018							;----------------------------------------
    163 U1018		       00	   DF0FRACDATA DS	1	; $18
    164 U1019		       00	   DF1FRACDATA DS	1	; $19
    165 U101a		       00	   DF2FRACDATA DS	1	; $1A
    166 U101b		       00	   DF3FRACDATA DS	1	; $1B
    167 U101c		       00	   DF4FRACDATA DS	1	; $1C
    168 U101d		       00	   DF5FRACDATA DS	1	; $1D
    169 U101e		       00	   DF6FRACDATA DS	1	; $1E
    170 U101f		       00	   DF7FRACDATA DS	1	; $1F
    171 U1020
    172 U1020							;----------------------------------------
    173 U1020							; Data Fetcher Window Flag
    174 U1020							;----------------------------------------
    175 U1020							; The Data Fetcher Window Flag allows you to dual-purpose the first four
    176 U1020							; Data Fetchers.  The Window is not required when a Data Fetcher is used to
    177 U1020							; update a sprite's color.  The Flag will return $FF if it's within the window,
    178 U1020							; or 0 if it's not - this value can be used to control the display of the ball
    179 U1020							; and missiles. The Data Fetcher will NOT increment when reading the flag.
    180 U1020							;
    181 U1020							; psuedo code to point Data Fetcher 1 to the color data
    182 U1020							;	lda #<(ColorDataPosition - HowFarDownScreen)
    183 U1020							;	sta DF1LOW
    184 U1020							;	lda #>(ColorDataPosition - HowFarDownScreen)
    185 U1020							;	sta DF1HI
    186 U1020							;
    187 U1020							; set the window based on the missile's Y position and height (number of
    188 U1020							; scanlines to draw missile on)
    189 U1020							;	lda #<(ColorDataPosition + MissileYposition - 1)
    190 U1020							;	sta DF1TOP
    191 U1020							;	lda #<(ColorDataPosition + MissileYposition + MissileHeight)
    192 U1020							;	sta DF1BOT
    193 U1020							;
    194 U1020							; then in the kernel read the Data Fetcher and update the color, then read the
    195 U1020							; flag and update the missile
    196 U1020							;	LDA DF1DATA
    197 U1020							;	STA COLUP0
    198 U1020							;	LDA DF1FLAG
    199 U1020							;	STA ENAM0
    200 U1020							;----------------------------------------
    201 U1020		       00	   DF0FLAG    DS	1	; $20
    202 U1021		       00	   DF1FLAG    DS	1	; $21
    203 U1022		       00	   DF2FLAG    DS	1	; $22
    204 U1023		       00	   DF3FLAG    DS	1	; $23
    205 U1024
    206 U1024							;----------------------------------------
    207 U1024							; Reserved
    208 U1024							;----------------------------------------
    209 U1024		       00		      DS	1	; $24
    210 U1025		       00		      DS	1	; $25
    211 U1026		       00		      DS	1	; $26
    212 U1027		       00		      DS	1	; $27
    213 U1028
    214 U1028
    215 U1080 ????				      SEG.U	DPC_REGISTERS_WRITE
    216 U1028					      ORG	DPC_BASE_WRITE_ADDRESS
    217 U1028
    218 U1028							;****************************************
    219 U1028							; SECTION 2 - DPC+ Write Registers
    220 U1028							;****************************************
    221 U1028							;
    222 U1028							;----------------------------------------
    223 U1028							; Fractional Data Fetcher, Low Pointer
    224 U1028							;----------------------------------------
    225 U1028							; These are used in conjunction with DFxFRACHI to point a Fractional Data
    226 U1028							; Fetcher to the data to read.  For usage, see "Fractional Data Fetcher"
    227 U1028							; in SECTION 1.
    228 U1028							;----------------------------------------
    229 U1028		       00	   DF0FRACLOW DS	1	; $28
    230 U1029		       00	   DF1FRACLOW DS	1	; $29
    231 U102a		       00	   DF2FRACLOW DS	1	; $2A
    232 U102b		       00	   DF3FRACLOW DS	1	; $2B
    233 U102c		       00	   DF4FRACLOW DS	1	; $2C
    234 U102d		       00	   DF5FRACLOW DS	1	; $2D
    235 U102e		       00	   DF6FRACLOW DS	1	; $2E
    236 U102f		       00	   DF7FRACLOW DS	1	; $2F
    237 U1030
    238 U1030							;----------------------------------------
    239 U1030							; Fractional Data Fetcher, High Pointer
    240 U1030							;----------------------------------------
    241 U1030							; These are used in conjunction with DFxFRACLOW to point a Fractional Data
    242 U1030							; Fetcher to the data to read.  For usage, see "Fractional Data Fetcher"
    243 U1030							; in SECTION 1.
    244 U1030							;
    245 U1030							; NOTE: for only the lower 4 bits are used.
    246 U1030							;----------------------------------------
    247 U1030		       00	   DF0FRACHI  DS	1	; $30
    248 U1031		       00	   DF1FRACHI  DS	1	; $31
    249 U1032		       00	   DF2FRACHI  DS	1	; $32
    250 U1033		       00	   DF3FRACHI  DS	1	; $33
    251 U1034		       00	   DF4FRACHI  DS	1	; $34
    252 U1035		       00	   DF5FRACHI  DS	1	; $35
    253 U1036		       00	   DF6FRACHI  DS	1	; $36
    254 U1037		       00	   DF7FRACHI  DS	1	; $37
    255 U1038
    256 U1038							;----------------------------------------
    257 U1038							; Fractional Data Fetcher, Increment
    258 U1038							;----------------------------------------
    259 U1038							; These are used to set the increment amount for the Fractional Data Fetcher.
    260 U1038							; To increment pointer after every Xth read use int(256/X)
    261 U1038							; For usage, see "Fractional Data Fetcher" in SECTION 1.
    262 U1038							;----------------------------------------
    263 U1038		       00	   DF0FRACINC DS	1	; $38
    264 U1039		       00	   DF1FRACINC DS	1	; $39
    265 U103a		       00	   DF2FRACINC DS	1	; $3A
    266 U103b		       00	   DF3FRACINC DS	1	; $3B
    267 U103c		       00	   DF4FRACINC DS	1	; $3C
    268 U103d		       00	   DF5FRACINC DS	1	; $3D
    269 U103e		       00	   DF6FRACINC DS	1	; $3E
    270 U103f		       00	   DF7FRACINC DS	1	; $3F
    271 U1040
    272 U1040							;----------------------------------------
    273 U1040							; Data Fetcher, Window Top
    274 U1040							;----------------------------------------
    275 U1040							; These are used with DFxBOT to define the Data Fetcher Window
    276 U1040							; For usage, see "Data Fetcher, Windowed" in SECTION 1.
    277 U1040							;----------------------------------------
    278 U1040		       00	   DF0TOP     DS	1	; $40
    279 U1041		       00	   DF1TOP     DS	1	; $41
    280 U1042		       00	   DF2TOP     DS	1	; $42
    281 U1043		       00	   DF3TOP     DS	1	; $43
    282 U1044		       00	   DF4TOP     DS	1	; $44
    283 U1045		       00	   DF5TOP     DS	1	; $45
    284 U1046		       00	   DF6TOP     DS	1	; $46
    285 U1047		       00	   DF7TOP     DS	1	; $47
    286 U1048
    287 U1048							;----------------------------------------
    288 U1048							; Data Fetcher, Window Bottom
    289 U1048							;----------------------------------------
    290 U1048							; These are used with DFxTOP to define the Data Fetcher Window
    291 U1048							; For usage, see "Data Fetcher, Windowed" in SECTION 1.
    292 U1048							;----------------------------------------
    293 U1048		       00	   DF0BOT     DS	1	; $48
    294 U1049		       00	   DF1BOT     DS	1	; $49
    295 U104a		       00	   DF2BOT     DS	1	; $4A
    296 U104b		       00	   DF3BOT     DS	1	; $4B
    297 U104c		       00	   DF4BOT     DS	1	; $4C
    298 U104d		       00	   DF5BOT     DS	1	; $4D
    299 U104e		       00	   DF6BOT     DS	1	; $4E
    300 U104f		       00	   DF7BOT     DS	1	; $4F
    301 U1050
    302 U1050							;----------------------------------------
    303 U1050							; Data Fetcher, Low Pointer
    304 U1050							;----------------------------------------
    305 U1050							; These are used in conjunction with DFxHI to point a Data Fetcher to the data
    306 U1050							; to read.  For usage, see "Data Fetcher" in SECTION 1.
    307 U1050							;----------------------------------------
    308 U1050		       00	   DF0LOW     DS	1	; $50
    309 U1051		       00	   DF1LOW     DS	1	; $51
    310 U1052		       00	   DF2LOW     DS	1	; $52
    311 U1053		       00	   DF3LOW     DS	1	; $53
    312 U1054		       00	   DF4LOW     DS	1	; $54
    313 U1055		       00	   DF5LOW     DS	1	; $55
    314 U1056		       00	   DF6LOW     DS	1	; $56
    315 U1057		       00	   DF7LOW     DS	1	; $57
    316 U1058
    317 U1058							;----------------------------------------
    318 U1058							; Fast Fetch Mode
    319 U1058							;----------------------------------------
    320 U1058							; Fast Fetch Mode enables the fastest way to read DPC+ registers.  Normal
    321 U1058							; reads use LDA Absolute addressing (LDA DF0DATA) which takes 4 cycles to
    322 U1058							; process.  Fast Fetch Mode intercepts LDA Immediate addressing (LDA #<DF0DATA)
    323 U1058							; which takes only 2 cycles!  Only immediate values < $28 are intercepted
    324 U1058							;
    325 U1058							; set Fast Fetch Mode
    326 U1058							;	LDA #0
    327 U1058							;	STA FASTFETCH
    328 U1058							;
    329 U1058							; then use immediate mode to read the registers, takes just 5 cycles to update
    330 U1058							; any TIA register
    331 U1058							;
    332 U1058							;	LDA #<DF0DATA
    333 U1058							;	STA GRP0
    334 U1058							;
    335 U1058							; when done, turn off Fast Fetch Mode using any non-zero value
    336 U1058							;	LDA #$FF
    337 U1058							;	STA FASTFETCH
    338 U1058							;
    339 U1058							; NOTE: if you forget to turn off FASTFETCH mode, then code like this will not
    340 U1058							;	 work as you expect
    341 U1058							;	LDA #0	; returns a RANDOM NUMBER, not 0.
    342 U1058							;	STA COLUPF
    343 U1058							;----------------------------------------
    344 U1058		       00	   FASTFETCH  DS	1	; $58
    345 U1059
    346 U1059							;----------------------------------------
    347 U1059							; Function Support
    348 U1059							;----------------------------------------
    349 U1059							; Currently only Function 255 is defined, and it is used to call user
    350 U1059							; written ARM routines (or C code compiled for the ARM processor.)
    351 U1059							;
    352 U1059							; PARAMETER is not used by function 255, it may be used by future functions.
    353 U1059							;
    354 U1059							; call custom ARM routine
    355 U1059							;	LDA #$FF
    356 U1059							;	STA CALLFUNCTION
    357 U1059							;
    358 U1059							; A custom ARM demo will be released in the near future
    359 U1059							;----------------------------------------
    360 U1059		       00	   PARAMETER  DS	1	; $59
    361 U105a		       00	   CALLFUNCTION DS	1	; $5A
    362 U105b
    363 U105b							;----------------------------------------
    364 U105b							; Reserved
    365 U105b							;----------------------------------------
    366 U105b		       00		      DS	1	; $5B	 ; reserved
    367 U105c		       00		      DS	1	; $5C	 ; reserved
    368 U105d
    369 U105d							;----------------------------------------
    370 U105d							; Waveforms
    371 U105d							;----------------------------------------
    372 U105d							; Waveforms are 32 byte tables that define a waveform.  Waveforms must be 32
    373 U105d							; byte aligned, and can only be stored in the 4K Display Data Bank. You MUST
    374 U105d							; define an "OFF" waveform,  comprised of all zeros.  The sum of all waveforms
    375 U105d							; being played should be <= 15, so typically you'll use a maximum of 5 for any
    376 U105d							; given value.
    377 U105d							;
    378 U105d							; Valid values are 0-127 and point to the 4K Display Data bank.  The formula
    379 U105d							; (* & $1fff)/32 as shown below will calculate the value for you
    380 U105d							;
    381 U105d							;
    382 U105d							; example waveforms
    383 U105d							;	align 32		; forces the waveform to a 32 byte boundary
    384 U105d							;SOUND_OFF = (* & $1fff)/32	; calculates waveform pointer
    385 U105d							;	.byte 0,0,0,0,0,0,0,0
    386 U105d							;	.byte 0,0,0,0,0,0,0,0
    387 U105d							;	.byte 0,0,0,0,0,0,0,0
    388 U105d							;	.byte 0,0,0,0,0,0,0,0
    389 U105d							;
    390 U105d							;	align 32
    391 U105d							;SINE_WAVE = (* & $1fff)/32
    392 U105d							;	.byte 3,3,3,4,4,5,5,5
    393 U105d							;	.byte 5,5,5,5,4,4,3,3
    394 U105d							;	.byte 3,2,2,1,1,0,0,0
    395 U105d							;	.byte 0,0,0,0,1,1,2,2
    396 U105d							;
    397 U105d							; usage, set voice 0 to Sine Wave, set voice 1 & 2 off
    398 U105d							;	LDA #SINE_WAVE
    399 U105d							;	STA WAVEFORM0
    400 U105d							;	LDA #SOUND_OFF
    401 U105d							;	STA WAVEFORM1
    402 U105d							;	STA WAVEFORM2
    403 U105d							;----------------------------------------
    404 U105d		       00	   WAVEFORM0  DS	1	; $5D
    405 U105e		       00	   WAVEFORM1  DS	1	; $5E
    406 U105f		       00	   WAVEFORM2  DS	1	; $5F
    407 U1060
    408 U1060							;----------------------------------------
    409 U1060							; Data Fetcher Push (stack)
    410 U1060							;----------------------------------------
    411 U1060							; The Data Fetchers can also be used to update the contents of the 4K
    412 U1060							; Display Data bank.  Point the Data Fetcher to the data to change,
    413 U1060							; then Push to it.  The Data Fetcher's pointer will be decremented BEFORE
    414 U1060							; the data is written.
    415 U1060							;
    416 U1060							; point Data Fetcher 1 to the sprite data
    417 U1060							;	lda #<DisplayData
    418 U1060							;	sta DF1LOW
    419 U1060							;	lda #>DisplayData
    420 U1060							;	sta DF1HI
    421 U1060							;
    422 U1060							; then update it
    423 U1060							;	LDA #$FF
    424 U1060							;	STA DF1PUSH ; changes data at DisplayData - 1
    425 U1060							;	LDA #$81
    426 U1060							;	STA DF1OUSH ; changes data at DisplayData - 2
    427 U1060							;----------------------------------------
    428 U1060		       00	   DF0PUSH    DS	1	; $60
    429 U1061		       00	   DF1PUSH    DS	1	; $61
    430 U1062		       00	   DF2PUSH    DS	1	; $62
    431 U1063		       00	   DF3PUSH    DS	1	; $63
    432 U1064		       00	   DF4PUSH    DS	1	; $64
    433 U1065		       00	   DF5PUSH    DS	1	; $65
    434 U1066		       00	   DF6PUSH    DS	1	; $66
    435 U1067		       00	   DF7PUSH    DS	1	; $67
    436 U1068
    437 U1068							;----------------------------------------
    438 U1068							; Data Fetcher, High Pointer
    439 U1068							;----------------------------------------
    440 U1068							; These are used in conjunction with DFxLOW to point a Data Fetcher to the data
    441 U1068							; to read.  For usage, see "Data Fetcher" in SECTION 1.
    442 U1068							;----------------------------------------
    443 U1068		       00	   DF0HI      DS	1	; $68
    444 U1069		       00	   DF1HI      DS	1	; $69
    445 U106a		       00	   DF2HI      DS	1	; $6A
    446 U106b		       00	   DF3HI      DS	1	; $6B
    447 U106c		       00	   DF4HI      DS	1	; $6C
    448 U106d		       00	   DF5HI      DS	1	; $6D
    449 U106e		       00	   DF6HI      DS	1	; $6E
    450 U106f		       00	   DF7HI      DS	1	; $6F
    451 U1070
    452 U1070							;----------------------------------------
    453 U1070							; Random Number Initialization
    454 U1070							;----------------------------------------
    455 U1070							; The random number generate defaults to a value that spells out DPC+.
    456 U1070							; Store any value to RRESET to set the random number back to DPC+, or you
    457 U1070							; can use RWRITE0-3 to change the 32 bit value to anything you desire.
    458 U1070							;
    459 U1070							; reset random number
    460 U1070							;	LDA #0
    461 U1070							;	STA RRESET
    462 U1070							;
    463 U1070							; set a specific random number (spells out 2600)
    464 U1070							;	LDA #$32
    465 U1070							;	STA RWRITE0
    466 U1070							;	LDA #$36
    467 U1070							;	STA RWRITE1
    468 U1070							;	LDA #$30
    469 U1070							;	STA RWRITE2
    470 U1070							;	STA RWRITE3
    471 U1070							;
    472 U1070							; NOTE: do not set all 4 bytes to 0, as that will disable the generator.
    473 U1070							;----------------------------------------
    474 U1070		       00	   RRESET     DS	1	; $70
    475 U1071		       00	   RWRITE0    DS	1	; $71
    476 U1072		       00	   RWRITE1    DS	1	; $72
    477 U1073		       00	   RWRITE2    DS	1	; $73
    478 U1074		       00	   RWRITE3    DS	1	; $74
    479 U1075
    480 U1075							;----------------------------------------
    481 U1075							; Notes
    482 U1075							;----------------------------------------
    483 U1075							; These are used to select a value from the frequency table to play.
    484 U1075							; The default table, store in DPC_frequencies.h, only defines frequencies
    485 U1075							; for 1-88, which cover the keys of a piano.  You are free to add additional
    486 U1075							; frequencies from 88-255.  Piano keys are defined at the end of this file
    487 U1075							;
    488 U1075							; set voice 0 to middle C
    489 U1075							;	LDA #C4
    490 U1075							;	STA NOTE0
    491 U1075							;
    492 U1075							; Note: if you are using ARM USER CODE then you can only use notes to 128.
    493 U1075							;----------------------------------------
    494 U1075		       00	   NOTE0      DS	1	; $75
    495 U1076		       00	   NOTE1      DS	1	; $76
    496 U1077		       00	   NOTE2      DS	1	; $77
    497 U1078
    498 U1078							;----------------------------------------
    499 U1078							; Data Fetcher Write (queue)
    500 U1078							;----------------------------------------
    501 U1078							; The Data Fetchers can also be used to update the contents of the 4K
    502 U1078							; Display Data bank.  Point the Data Fetcher to the data to change,
    503 U1078							; then Write to it  The Data Fetcher's pointer will be incremented AFTER
    504 U1078							; the data is written.
    505 U1078							;
    506 U1078							; point Data Fetcher 1 to the sprite data
    507 U1078							;	lda #<SpriteData
    508 U1078							;	sta DF1LOW
    509 U1078							;	lda #>SpriteData
    510 U1078							;	sta DF1HI
    511 U1078							;
    512 U1078							; then update it
    513 U1078							;	LDA #$FF
    514 U1078							;	STA DF1WRITE ; changes data at SpriteData
    515 U1078							;	LDA #$81
    516 U1078							;	STA DF1WRITE ; changes data at SpriteData + 1
    517 U1078							;----------------------------------------
    518 U1078		       00	   DF0WRITE   DS	1	; $78
    519 U1079		       00	   DF1WRITE   DS	1	; $79
    520 U107a		       00	   DF2WRITE   DS	1	; $7A
    521 U107b		       00	   DF3WRITE   DS	1	; $7B
    522 U107c		       00	   DF4WRITE   DS	1	; $7C
    523 U107d		       00	   DF5WRITE   DS	1	; $7D
    524 U107e		       00	   DF6WRITE   DS	1	; $7E
    525 U107f		       00	   DF7WRITE   DS	1	; $7F
    526 U1080
    527 U1080							;-------------------------------------------------------------------------------
    528 U1080							; The following required for back-compatibility with code which does not use
    529 U1080							; segments.
    530 U1080
    531  8400 ????				      SEG
------- FILE C:\Users\afloc\Source\Repos\life2600\bin\life.bas.asm
------- FILE DPCplusbB.h LEVEL 2 PASS 3
      0  8400 ????				      include	"DPCplusbB.h"
      1 U00f5 ????				      SEG.U	vars
      2 U0080					      org	$80
      3 U0080		       00	   player0x   ds	1
      4 U0081		       00	   topP1x     ds	1
      5 U0082		       00	   missile0x  ds	1
      6 U0083		       00	   missile1x  ds	1
      7 U0084		       00	   ballx      ds	1
      8 U0085
      9 U0085		       00 00 00 00*SpriteGfxIndex ds	9
     10 U008e
     11 U008e		       00	   spritedisplay ds	1
     12 U008f
     13 U008f		       00	   player0xcoll ds	1	; to detect p0x colls
     14 U0090		       00	   NewSpriteX ds	1	;		X position
     15 U0090		       00 90	   player1x   =	NewSpriteX
     16 U0091		       00	   player2x   ds	1
     17 U0092		       00	   player3x   ds	1
     18 U0093		       00	   player4x   ds	1
     19 U0094		       00	   player5x   ds	1
     20 U0095		       00	   player6x   ds	1
     21 U0096		       00	   player7x   ds	1
     22 U0097		       00	   player8x   ds	1
     23 U0098		       00	   player9x   ds	1
     24 U0099
     25 U0099		       00	   player0y   ds	1
     26 U009a		       00	   NewSpriteY ds	1	;		Y position
     27 U009a		       00 9a	   player1y   =	NewSpriteY
     28 U009b		       00	   player2y   ds	1
     29 U009c		       00	   player3y   ds	1
     30 U009d		       00	   player4y   ds	1
     31 U009e		       00	   player5y   ds	1
     32 U009f		       00	   player6y   ds	1
     33 U00a0		       00	   player7y   ds	1
     34 U00a1		       00	   player8y   ds	1
     35 U00a2		       00	   player9y   ds	1
     36 U00a3
     37 U00a3		       00 00	   player0color ds	2
     38 U00a5
     39 U00a5		       00	   player0height ds	1
     40 U00a6		       00	   player1height ds	1
     41 U00a7		       00	   player2height ds	1
     42 U00a8		       00	   player3height ds	1
     43 U00a9		       00	   player4height ds	1
     44 U00aa		       00	   player5height ds	1
     45 U00ab		       00	   player6height ds	1
     46 U00ac		       00	   player7height ds	1
     47 U00ad		       00	   player8height ds	1
     48 U00ae		       00	   player9height ds	1
     49 U00af
     50 U00af		       00	   _NUSIZ1    ds	1
     51 U00b0		       00	   NUSIZ2     ds	1
     52 U00b1		       00	   NUSIZ3     ds	1
     53 U00b2		       00	   NUSIZ4     ds	1
     54 U00b3		       00	   NUSIZ5     ds	1
     55 U00b4		       00	   NUSIZ6     ds	1
     56 U00b5		       00	   NUSIZ7     ds	1
     57 U00b6		       00	   NUSIZ8     ds	1
     58 U00b7		       00	   NUSIZ9     ds	1
     59 U00b8
     60 U00b8		       00 00 00    score      ds	3
     61 U00bb		       00	   COLUM0     ds	1
     62 U00bc		       00	   COLUM1     ds	1
     63 U00bd		       00	   player0pointerlo ds	1
     64 U00be		       00	   player0pointerhi ds	1
     65 U00bf
     66 U00bf		       00 85	   RAMcopybegin =	SpriteGfxIndex
     67 U00bf		       00 3a	   RAMcopylength =	*-RAMcopybegin
     68 U00bf
     69 U00bf		       00	   missile0y  ds	1
     70 U00c0		       00	   missile1y  ds	1
     71 U00c1		       00	   bally      ds	1
     72 U00c2
     73 U00c2		       00	   missile0height ds	1
     74 U00c3		       00	   missile1height ds	1
     75 U00c4		       00	   ballheight ds	1
     76 U00c5
     77 U00c5		       00	   statusbarlength ds	1	; needed?
     78 U00c5		       00 c5	   aux3       =	statusbarlength
     79 U00c6
     80 U00c6		       00	   lifecolor  ds	1
     81 U00c6		       00 c6	   pfscorecolor =	lifecolor
     82 U00c7		       00	   aux4       ds	1
     83 U00c8
     84 U00c8		       00	   lifepointer ds	1
     85 U00c9		       00	   lives      ds	1
     86 U00c9		       00 c8	   pfscore1   =	lifepointer
     87 U00c9		       00 c9	   pfscore2   =	lives
     88 U00c9		       00 c8	   aux5       =	pfscore1
     89 U00c9		       00 c9	   aux6       =	pfscore2
     90 U00ca
     91 U00ca		       00	   playfieldpos ds	1
     92 U00cb
     93 U00cb		       00	   temp1      ds	1	; used in sprite flickering
     94 U00cc		       00	   temp2      ds	1	;are obliterated when drawscreen is called.
     95 U00cd		       00	   temp3      ds	1
     96 U00ce		       00	   temp4      ds	1
     97 U00cf		       00	   temp5      ds	1
     98 U00d0		       00	   temp6      ds	1
     99 U00d0		       00 81	   temp7      =	topP1x	; This is used to aid in bankswitching
    100 U00d1
    101 U00d1		       00	   A	      ds	1
    102 U00d1		       00 d1	   a	      =	A
    103 U00d2		       00	   B	      ds	1
    104 U00d2		       00 d2	   b	      =	B
    105 U00d3		       00	   C	      ds	1
    106 U00d3		       00 d3	   c	      =	C
    107 U00d4		       00	   D	      ds	1
    108 U00d4		       00 d4	   d	      =	D
    109 U00d5		       00	   E	      ds	1
    110 U00d5		       00 d5	   e	      =	E
    111 U00d6		       00	   F	      ds	1
    112 U00d6		       00 d6	   f	      =	F
    113 U00d7		       00	   G	      ds	1
    114 U00d7		       00 d7	   g	      =	G
    115 U00d8		       00	   H	      ds	1
    116 U00d8		       00 d8	   h	      =	H
    117 U00d9		       00	   I	      ds	1
    118 U00d9		       00 d9	   i	      =	I
    119 U00da		       00	   J	      ds	1
    120 U00da		       00 da	   j	      =	J
    121 U00db		       00	   K	      ds	1
    122 U00db		       00 db	   k	      =	K
    123 U00dc		       00	   L	      ds	1
    124 U00dc		       00 dc	   l	      =	L
    125 U00dd		       00	   M	      ds	1
    126 U00dd		       00 dd	   m	      =	M
    127 U00de		       00	   N	      ds	1
    128 U00de		       00 de	   n	      =	N
    129 U00df		       00	   O	      ds	1
    130 U00df		       00 df	   o	      =	O
    131 U00e0		       00	   P	      ds	1
    132 U00e0		       00 e0	   p	      =	P
    133 U00e1		       00	   Q	      ds	1
    134 U00e1		       00 e1	   q	      =	Q
    135 U00e2		       00	   R	      ds	1
    136 U00e2		       00 e2	   r	      =	R
    137 U00e3		       00	   S	      ds	1
    138 U00e3		       00 e3	   s	      =	S
    139 U00e4		       00	   T	      ds	1
    140 U00e4		       00 e4	   t	      =	T
    141 U00e5		       00	   U	      ds	1
    142 U00e5		       00 e5	   u	      =	U
    143 U00e6		       00	   V	      ds	1
    144 U00e6		       00 e6	   v	      =	V
    145 U00e7		       00	   W	      ds	1
    146 U00e7		       00 e7	   w	      =	W
    147 U00e8		       00	   X	      ds	1
    148 U00e8		       00 e8	   x	      =	X
    149 U00e9		       00	   Y	      ds	1
    150 U00e9		       00 e9	   y	      =	Y
    151 U00ea		       00	   Z	      ds	1
    152 U00ea		       00 ea	   z	      =	Z
    153 U00eb		       00	   scorecolor ds	1
    154 U00ec
    155 U00ec		       00	   var0       ds	1
    156 U00ed		       00	   var1       ds	1
    157 U00ee		       00	   var2       ds	1
    158 U00ef		       00	   var3       ds	1
    159 U00f0		       00	   var4       ds	1
    160 U00f1		       00	   var5       ds	1
    161 U00f2		       00	   var6       ds	1
    162 U00f3		       00	   var7       ds	1
    163 U00f4		       00	   var8       ds	1
    164 U00f5
 free ram: 0
    165 U00f5					      echo	"free ram:",($f5-*)d
    166 U00f5
    167 U00f5		       00 f6	   stack1     =	$f6
    168 U00f5		       00 f7	   stack2     =	$f7
    169 U00f5		       00 f8	   stack3     =	$f8
    170 U00f5		       00 f9	   stack4     =	$f9
    171 U00f5							; the stack bytes above may be used in the kernel
    172 U00f5							; stack = F6-F7, F8-F9, FA-FB, FC-FD, FE-FF
    173 U00f5
    174 U00f5					      MAC	return
    175 U00f5					      ifnconst	bankswitch
    176 U00f5					      rts
    177 U00f5					      else
    178 U00f5					      jmp	BS_return
    179 U00f5					      endif
    180 U00f5					      ENDM		; auto-return from either a regular or bankswitched module
    181  8400 ????				      seg
    182  8400 ????	       10 00	   rand       =	RANDOM0NEXT
    183  8400 ????	       00 d3	   KERNEL_LINES =	178*76/64	; warning: not all values will work
    184  8400 ????	       00 a7	   OVERSCAN_LINES =	128+33*76/64	; again, not all values work
    185  8400 ????	       d1 a4	   C_function =	FETCHER_BEGIN
    186  8400 ????	       d1 a8	   CcodeData  =	C_function + 4
    187  8400 ????	       d1 e2	   playerpointers =	CcodeData + RAMcopylength
    188  8400 ????	       d2 08	   P1GFX      =	playerpointers + 38
    189  8400 ????	       d3 08	   P1COLOR    =	P1GFX + 256
    190  8400 ????	       d4 08	   P0GFX      =	P1COLOR + 256
    191  8400 ????	       d5 08	   P0COLOR    =	P0GFX + 256
    192  8400 ????	       d6 08	   PF1L       =	P0COLOR + 256
    193  8400 ????	       d7 08	   PF2L       =	PF1L + 256
    194  8400 ????	       d8 08	   PF1R       =	PF2L + 256
    195  8400 ????	       d9 08	   PF2R       =	PF1R + 256
    196  8400 ????	       da 08	   PFCOLS     =	PF2R + 256
    197  8400 ????	       db 08	   JUMPTABLELO =	PFCOLS + 256
    198  8400 ????	       db 14	   JUMPTABLEHI =	JUMPTABLELO + 12
    199  8400 ????	       db 20	   P1HMP      =	JUMPTABLEHI + 12
    200  8400 ????	       db 2d	   P1SKIP     =	P1HMP + 13
    201  8400 ????	       db 39	   NUSIZREFP  =	P1SKIP + 12
    202  8400 ????	       db 45	   scoredata  =	NUSIZREFP + 12
    203  8400 ????	       db a5	   BKCOLS     =	scoredata + 96
    204  8400 ????	       dc a5	   STACKbegin =	BKCOLS + 256
    205  8400 ????	       dd a5	   USERSTACK  =	STACKbegin + 256	; stack starts here and goes down!!!!
 DPC free RAM= 603
    206  8400 ????				      echo	"DPC free RAM=",($1000-(USERSTACK&$0FFF))d
------- FILE C:\Users\afloc\Source\Repos\life2600\bin\life.bas.asm
------- FILE 2600basic_variable_redefs.h LEVEL 2 PASS 3
      0  8400 ????				      include	"2600basic_variable_redefs.h"
      1  8400 ????						; This file contains variable mapping and other information for the current project.
      2  8400 ????
      3  8400 ????	       00 20	   bscode_length =	32
      4  8400 ????	       00 d7	   startingSeed =	g
      5  8400 ????
      6  8400 ????	       00 d6	   drawCounter =	f
      7  8400 ????
      8  8400 ????	       00 d5	   tmp	      =	e
      9  8400 ????
     10  8400 ????	       00 d4	   chkY       =	d
     11  8400 ????
     12  8400 ????	       00 d3	   chkX       =	c
     13  8400 ????
     14  8400 ????	       00 d2	   neighbors  =	b
     15  8400 ????
     16  8400 ????	       00 d1	   stackCounter =	a
     17  8400 ????
     18  8400 ????	       00 2b	   vblank_time =	43
     19  8400 ????	       00 25	   overscan_time =	37
     20  8400 ????	       00 07	   bs_mask    =	7
     21  8400 ????	       00 1c	   bankswitch =	28
     22  8400 ????	       1f f6	   bankswitch_hotspot =	$1FF6
     23  8400 ????	       00 02	   multisprite =	2
------- FILE C:\Users\afloc\Source\Repos\life2600\bin\life.bas.asm
      7  0400					      ORG	$400
      8  0400					      RORG	$0
      9  0400					      incbin	DPCplus.arm
     10  1000					      ORG	$1000
     11  1000					      RORG	$1000
     12  1000					      incbin	custom/bin/custom2.bin
     13  1894							; assume custom2.bin > 128 bytes
     14  1894							; repeat $80
     15  1894							; .byte 0
     16  1894							; repend
     17  1894							; feel free to modify the score graphics - just keep each digit 8 high
     18  1894							; and keep the conditional compilation stuff intact
     19  1894				  -	      ifconst	ROM2k
     20  1894				  -	      ORG	$F7AC-8
     21  1894					      else
     22  1894					      ifconst	bankswitch
     23  1894				  -	      if	bankswitch == 8
     24  1894				  -	      ORG	$2F94-bscode_length
     25  1894				  -	      RORG	$FF94-bscode_length
     26  1894					      endif
     27  1894				  -	      if	bankswitch == 16
     28  1894				  -	      ORG	$4F94-bscode_length
     29  1894				  -	      RORG	$FF94-bscode_length
     30  1894					      endif
     31  1894				  -	      if	bankswitch == 32
     32  1894				  -	      ORG	$8F94-bscode_length
     33  1894				  -	      RORG	$FF94-bscode_length
     34  1894					      endif
     35  1894				  -	      if	bankswitch == 64
     36  1894				  -	      ORG	$10F80-bscode_length
     37  1894				  -	      RORG	$1FF80-bscode_length
     38  1894					      endif
     39  1894				  -	      else
     40  1894				  -	      ORG	$FF9C
     41  1894					      endif
     42  1894					      endif
     43  1894
     44  1894							; font equates
     45  1894		       00 01	   .21stcentury =	1
     46  1894		       00 02	   alarmclock =	2
     47  1894		       00 03	   handwritten =	3
     48  1894		       00 04	   interrupted =	4
     49  1894		       00 05	   retroputer =	5
     50  1894		       00 06	   whimsey    =	6
     51  1894		       00 07	   tiny       =	7
     52  1894
     53  1894				   scoretable
     54  1894
     55  1894				  -	      ifconst	font
     56  1894				  -	      if	font == .21stcentury
     57  1894				  -	      include	"score_graphics.asm.21stcentury"
     58  1894				  -	      endif
     59  1894				  -	      if	font == alarmclock
     60  1894				  -	      include	"score_graphics.asm.alarmclock"
     61  1894				  -	      endif
     62  1894				  -	      if	font == handwritten
     63  1894				  -	      include	"score_graphics.asm.handwritten"
     64  1894				  -	      endif
     65  1894				  -	      if	font == interrupted
     66  1894				  -	      include	"score_graphics.asm.interrupted"
     67  1894				  -	      endif
     68  1894				  -	      if	font == retroputer
     69  1894				  -	      include	"score_graphics.asm.retroputer"
     70  1894				  -	      endif
     71  1894				  -	      if	font == whimsey
     72  1894				  -	      include	"score_graphics.asm.whimsey"
     73  1894				  -	      endif
     74  1894				  -	      if	font == tiny
     75  1894				  -	      include	"score_graphics.asm.tiny"
     76  1894				  -	      endif
     77  1894					      else		; default font
     78  1894
     79  1894		       3c		      .byte.b	%00111100
     80  1895		       66		      .byte.b	%01100110
     81  1896		       66		      .byte.b	%01100110
     82  1897		       66		      .byte.b	%01100110
     83  1898		       66		      .byte.b	%01100110
     84  1899		       66		      .byte.b	%01100110
     85  189a		       66		      .byte.b	%01100110
     86  189b		       3c		      .byte.b	%00111100
     87  189c
     88  189c		       7e		      .byte.b	%01111110
     89  189d		       18		      .byte.b	%00011000
     90  189e		       18		      .byte.b	%00011000
     91  189f		       18		      .byte.b	%00011000
     92  18a0		       18		      .byte.b	%00011000
     93  18a1		       38		      .byte.b	%00111000
     94  18a2		       18		      .byte.b	%00011000
     95  18a3		       08		      .byte.b	%00001000
     96  18a4
     97  18a4		       7e		      .byte.b	%01111110
     98  18a5		       60		      .byte.b	%01100000
     99  18a6		       60		      .byte.b	%01100000
    100  18a7		       3c		      .byte.b	%00111100
    101  18a8		       06		      .byte.b	%00000110
    102  18a9		       06		      .byte.b	%00000110
    103  18aa		       46		      .byte.b	%01000110
    104  18ab		       3c		      .byte.b	%00111100
    105  18ac
    106  18ac		       3c		      .byte.b	%00111100
    107  18ad		       46		      .byte.b	%01000110
    108  18ae		       06		      .byte.b	%00000110
    109  18af		       06		      .byte.b	%00000110
    110  18b0		       1c		      .byte.b	%00011100
    111  18b1		       06		      .byte.b	%00000110
    112  18b2		       46		      .byte.b	%01000110
    113  18b3		       3c		      .byte.b	%00111100
    114  18b4
    115  18b4		       0c		      .byte.b	%00001100
    116  18b5		       0c		      .byte.b	%00001100
    117  18b6		       7e		      .byte.b	%01111110
    118  18b7		       4c		      .byte.b	%01001100
    119  18b8		       4c		      .byte.b	%01001100
    120  18b9		       2c		      .byte.b	%00101100
    121  18ba		       1c		      .byte.b	%00011100
    122  18bb		       0c		      .byte.b	%00001100
    123  18bc
    124  18bc		       3c		      .byte.b	%00111100
    125  18bd		       46		      .byte.b	%01000110
    126  18be		       06		      .byte.b	%00000110
    127  18bf		       06		      .byte.b	%00000110
    128  18c0		       3c		      .byte.b	%00111100
    129  18c1		       60		      .byte.b	%01100000
    130  18c2		       60		      .byte.b	%01100000
    131  18c3		       7e		      .byte.b	%01111110
    132  18c4
    133  18c4		       3c		      .byte.b	%00111100
    134  18c5		       66		      .byte.b	%01100110
    135  18c6		       66		      .byte.b	%01100110
    136  18c7		       66		      .byte.b	%01100110
    137  18c8		       7c		      .byte.b	%01111100
    138  18c9		       60		      .byte.b	%01100000
    139  18ca		       62		      .byte.b	%01100010
    140  18cb		       3c		      .byte.b	%00111100
    141  18cc
    142  18cc		       30		      .byte.b	%00110000
    143  18cd		       30		      .byte.b	%00110000
    144  18ce		       30		      .byte.b	%00110000
    145  18cf		       18		      .byte.b	%00011000
    146  18d0		       0c		      .byte.b	%00001100
    147  18d1		       06		      .byte.b	%00000110
    148  18d2		       42		      .byte.b	%01000010
    149  18d3		       3e		      .byte.b	%00111110
    150  18d4
    151  18d4		       3c		      .byte.b	%00111100
    152  18d5		       66		      .byte.b	%01100110
    153  18d6		       66		      .byte.b	%01100110
    154  18d7		       66		      .byte.b	%01100110
    155  18d8		       3c		      .byte.b	%00111100
    156  18d9		       66		      .byte.b	%01100110
    157  18da		       66		      .byte.b	%01100110
    158  18db		       3c		      .byte.b	%00111100
    159  18dc
    160  18dc		       3c		      .byte.b	%00111100
    161  18dd		       46		      .byte.b	%01000110
    162  18de		       06		      .byte.b	%00000110
    163  18df		       3e		      .byte.b	%00111110
    164  18e0		       66		      .byte.b	%01100110
    165  18e1		       66		      .byte.b	%01100110
    166  18e2		       66		      .byte.b	%01100110
    167  18e3		       3c		      .byte.b	%00111100
    168  18e4
    169  18e4					      ifnconst	DPC_kernel_options
    170  18e4
    171  18e4		       00		      .byte.b	%00000000
    172  18e5		       00		      .byte.b	%00000000
    173  18e6		       00		      .byte.b	%00000000
    174  18e7		       00		      .byte.b	%00000000
    175  18e8		       00		      .byte.b	%00000000
    176  18e9		       00		      .byte.b	%00000000
    177  18ea		       00		      .byte.b	%00000000
    178  18eb		       00		      .byte.b	%00000000
    179  18ec
    180  18ec					      endif
    181  18ec
    182  18ec					      endif
    183  18ec
    184  18ec				  -	      ifconst	ROM2k
    185  18ec				  -	      ORG	$F7FC
    186  18ec					      else
    187  18ec					      ifconst	bankswitch
    188  18ec				  -	      if	bankswitch == 8
    189  18ec				  -	      ORG	$2FF4-bscode_length
    190  18ec				  -	      RORG	$FFF4-bscode_length
    191  18ec					      endif
    192  18ec				  -	      if	bankswitch == 16
    193  18ec				  -	      ORG	$4FF4-bscode_length
    194  18ec				  -	      RORG	$FFF4-bscode_length
    195  18ec					      endif
    196  18ec				  -	      if	bankswitch == 32
    197  18ec				  -	      ORG	$8FF4-bscode_length
    198  18ec				  -	      RORG	$FFF4-bscode_length
    199  18ec					      endif
    200  18ec				  -	      if	bankswitch == 64
    201  18ec				  -	      ORG	$10FE0-bscode_length
    202  18ec				  -	      RORG	$1FFE0-bscode_length
    203  18ec					      endif
    204  18ec				  -	      else
    205  18ec				  -	      ORG	$FFFC
    206  18ec					      endif
    207  18ec					      endif
    208  18ec				   start
    209  18ec		       78		      sei
    210  18ed		       d8		      cld
    211  18ee		       a0 00		      ldy	#0
    212  18f0		       a5 d0		      lda	$D0
    213  18f2		       c9 2c		      cmp	#$2C	;check RAM location #1
    214  18f4		       d0 07		      bne	MachineIs2600
    215  18f6		       a5 d1		      lda	$D1
    216  18f8		       c9 a9		      cmp	#$A9	;check RAM location #2
    217  18fa		       d0 01		      bne	MachineIs2600
    218  18fc		       88		      dey
    219  18fd				   MachineIs2600
    220  18fd		       a2 00		      ldx	#0
    221  18ff		       8a		      txa
    222  1900				   clearmem
    223  1900		       e8		      inx
    224  1901		       9a		      txs
    225  1902		       48		      pha
    226  1903		       d0 fb		      bne	clearmem
    227  1905		       84 cb		      sty	temp1
    228  1907		       a2 08		      ldx	#8
    229  1909		       86 ca		      stx	playfieldpos
    230  190b		       8e 58 10 	      stx	FASTFETCH
    231  190e		       a2 08		      ldx	#8
    232  1910		       a9 e0		      lda	#224
    233  1912				   inityloop
    234  1912		       95 9a		      sta	player1y,x
    235  1914		       ca		      dex
    236  1915		       10 fb		      bpl	inityloop
    237  1917
    238  1917		       a9 01		      lda	#1
    239  1919		       85 0a		      sta	CTRLPF
    240  191b		       ad 84 02 	      lda	INTIM
    241  191e		       8d 71 10 	      sta	RWRITE0
    242  1921		       a9 00		      lda	#0
    243  1923		       8d 38 10 	      STA	DF0FRACINC
    244  1926		       8d 39 10 	      STA	DF1FRACINC
    245  1929		       8d 3a 10 	      STA	DF2FRACINC
    246  192c		       8d 3b 10 	      STA	DF3FRACINC
    247  192f		       8d 3c 10 	      STA	DF4FRACINC
    248  1932		       8d 3e 10 	      STA	DF6FRACINC
    249  1935		       a9 a5		      lda	#<USERSTACK
    250  1937		       8d 57 10 	      STA	DF7LOW
    251  193a		       a9 0d		      lda	#(>USERSTACK) & $0F
    252  193c		       8d 6f 10 	      STA	DF7HI
    253  193f		       a9 ff		      lda	#255
    254  1941		       8d 5a 10 	      sta	CALLFUNCTION	; zero-fill fetcher
    255  1944
    256  1944		       a9 1f		      lda	#>(game-1)
    257  1946		       48		      pha
    258  1947		       a9 8f		      lda	#<(game-1)
    259  1949		       48		      pha
    260  194a		       48		      pha
    261  194b		       48		      pha
    262  194c		       a2 01		      ldx	#1
    263  194e		       4c ee df 	      jmp	BS_jsr
    264  1951				   drawscreen
    265  1951		       a9 01		      lda	#1
    266  1953		       85 2c		      sta	CXCLR
    267  1955		       85 09		      sta	COLUBK	; REVENG - don't start with the lastline color
    268  1957
    269  1957				   fufu
    270  1957		       ad 84 02 	      lda	INTIM
    271  195a		       30 fb		      bmi	fufu
    272  195c
      0  195c					      VERTICAL_SYNC
      1  195c		       a9 02		      LDA	#$02
      2  195e		       85 02		      STA	WSYNC
      3  1960		       85 00		      STA	VSYNC
      4  1962		       85 02		      STA	WSYNC
      5  1964		       85 02		      STA	WSYNC
      6  1966		       4a		      LSR
      7  1967		       85 02		      STA	WSYNC
      8  1969		       85 00		      STA	VSYNC
    274  196b
    275  196b		       a9 a9		      lda	#41+128	;was 37 - do more w/c code
    276  196d		       8d 96 02 	      sta	TIM64T
    277  1970
    278  1970							; adjust for pfpos?
    279  1970
    280  1970							; set zero to properly enter C code
    281  1970		       a9 a4		      lda	#<C_function
    282  1972		       8d 50 10 	      sta	DF0LOW
    283  1975		       a9 01		      lda	#(>C_function) & $0F
    284  1977		       8d 68 10 	      sta	DF0HI
    285  197a		       a9 00		      lda	#0
    286  197c		       8d 78 10 	      sta	DF0WRITE
    287  197f
    288  197f							; REVENG - pass the number of vsprites we want...
    289  197f					      ifnconst	dpcspritemax
    290  197f		       a9 09		      lda	#9
    291  1981				  -	      else
    292  1981				  -	      lda	#dpcspritemax
    293  1981					      endif
    294  1981		       8d 78 10 	      sta	DF0WRITE
    295  1984
    296  1984		       a5 80		      lda	player0x
    297  1986		       85 8f		      sta	player0xcoll	; detect p0x colls
    298  1988
    299  1988							; copy RAM to fetcher for C-code
    300  1988		       a9 e2		      lda	#<(CcodeData + RAMcopylength)
    301  198a		       8d 50 10 	      sta	DF0LOW
    302  198d		       a9 01		      lda	#(>(CcodeData + RAMcopylength)) & $0F
    303  198f		       8d 68 10 	      sta	DF0HI
    304  1992		       a2 39		      ldx	#RAMcopylength-1
    305  1994				   copy2fetcherloop
    306  1994		       b5 85		      lda	RAMcopybegin,x
    307  1996		       8d 60 10 	      sta	DF0PUSH
    308  1999		       ca		      dex
    309  199a		       10 f8		      bpl	copy2fetcherloop
    310  199c
    311  199c		       a9 ff		      lda	#255
    312  199e		       8d 5a 10 	      sta	CALLFUNCTION
    313  19a1
    314  19a1							; copy modified data back (just need first 6 bytes, which is sprite sort data)
    315  19a1		       a2 ed		      ldx	#256-19
    316  19a3				   copyfromfetcherloop
    317  19a3		       ad 08 10 	      lda	DF0DATA
    318  19a6		       95 98		      sta	RAMcopybegin+19,x
    319  19a8		       e8		      inx
    320  19a9		       30 f8		      bmi	copyfromfetcherloop
    321  19ab
    322  19ab		       20 39 1e 	      jsr	kernel_setup
    323  19ae		       85 02		      sta	WSYNC
    324  19b0		       a0 80		      ldy	#$80
    325  19b2		       84 20		      sty	HMP0
    326  19b4		       84 21		      sty	HMP1
    327  19b6		       84 22		      sty	HMM0
    328  19b8		       84 23		      sty	HMM1
    329  19ba		       84 24		      sty	HMBL
    330  19bc
    331  19bc							; run possible vblank bB code
    332  19bc				  -	      ifconst	vblank_bB_code
    333  19bc				  -	      jsr	vblank_bB_code
    334  19bc					      endif
    335  19bc
    336  19bc		       20 01 1d 	      jsr	set_fetchers
    337  19bf
    338  19bf		       a2 07		      ldx	#7
    339  19c1				   setloopfrac
    340  19c1		       bd 7c 1d 	      lda	dffraclow,x
    341  19c4		       9d 28 10 	      sta	DF0FRACLOW,x
    342  19c7		       bd 84 1d 	      lda	dffrachi,x
    343  19ca		       9d 30 10 	      sta	DF0FRACHI,x
    344  19cd		       ca		      dex
    345  19ce		       10 f1		      bpl	setloopfrac
    346  19d0							; lda #255
    347  19d0		       8e 3d 10 	      STx	DF5FRACINC	; x=255 right now
    348  19d3		       8e 3f 10 	      STx	DF7FRACINC
    349  19d6		       ad 1d 10 	      lda	DF5FRACDATA	; priming read
    350  19d9		       ad 1f 10 	      lda	DF7FRACDATA	; priming read
    351  19dc
    352  19dc		       a6 85		      ldx	SpriteGfxIndex
    353  19de		       b5 af		      lda	_NUSIZ1,x	; top NUSIZ/REFP
    354  19e0		       85 05		      sta	NUSIZ1
    355  19e2		       85 0c		      sta	REFP1
    356  19e4
    357  19e4							;REVENG - allow P0 to wrap at the top
    358  19e4				   startwrapfix
    359  19e4		       a9 ff		      lda	#255
    360  19e6		       85 cc		      sta	temp2
    361  19e8		       18		      clc
    362  19e9		       a5 99		      lda	player0y
    363  19eb		       65 a5		      adc	player0height
    364  19ed		       38		      sec
    365  19ee		       c5 a5		      cmp	player0height
    366  19f0		       90 04		      bcc	skipwrapfix
    367  19f2		       a9 00		      lda	#0
    368  19f4		       85 cc		      sta	temp2
    369  19f6				   skipwrapfix
    370  19f6
    371  19f6		       38		      sec
    372  19f7		       a9 08		      lda	#<P0GFX
    373  19f9		       e5 99		      sbc	player0y
    374  19fb		       8d 52 10 	      sta	DF2LOW
    375  19fe		       a9 d4		      lda	#>P0GFX
    376  1a00							;sbc #0
    377  1a00		       e5 cc		      sbc	temp2
    378  1a02		       8d 6a 10 	      sta	DF2HI
    379  1a05		       a9 07		      lda	#<(P0GFX-1)
    380  1a07		       8d 42 10 	      sta	DF2TOP
    381  1a0a		       38		      sec
    382  1a0b		       65 a5		      adc	player0height
    383  1a0d		       8d 4a 10 	      sta	DF2BOT
    384  1a10
    385  1a10							;REVENG - 1/2 of the COLUM0 fix. the rest is in main.c
    386  1a10		       a9 08		      lda	#<(P0COLOR)
    387  1a12		       8d 50 10 	      sta	DF0LOW
    388  1a15		       85 cc		      sta	temp2
    389  1a17		       a9 d5		      lda	#>(P0COLOR)
    390  1a19		       8d 68 10 	      sta	DF0HI
    391  1a1c
    392  1a1c							; ball
    393  1a1c		       a9 07		      lda	#<(P1GFX-1)
    394  1a1e		       18		      clc
    395  1a1f		       65 c1		      adc	bally
    396  1a21		       8d 43 10 	      sta	DF3TOP
    397  1a24		       38		      sec
    398  1a25		       65 c4		      adc	ballheight
    399  1a27		       8d 4b 10 	      sta	DF3BOT
    400  1a2a
    401  1a2a							; missile0
    402  1a2a		       a5 cc		      lda	temp2
    403  1a2c		       18		      clc
    404  1a2d		       65 bf		      adc	missile0y
    405  1a2f		       8d 40 10 	      sta	DF0TOP
    406  1a32		       38		      sec
    407  1a33		       65 c2		      adc	missile0height
    408  1a35		       8d 48 10 	      sta	DF0BOT
    409  1a38
    410  1a38
    411  1a38				   fuu
    412  1a38		       ad 84 02 	      lda	INTIM
    413  1a3b		       30 fb		      bmi	fuu
    414  1a3d		       85 02		      sta	WSYNC
    415  1a3f							;     ldy #$80
    416  1a3f							;     sty HMP0
    417  1a3f							;     sty HMP1
    418  1a3f							;     sty HMM0
    419  1a3f							;     sty HMM1
    420  1a3f							;     sty HMBL
    421  1a3f							; relocated code above prior to vblank, to allow for Cosmic Ark starfield
    422  1a3f							; and/or skewed players
      0  1a3f					      sleep	17
      1  1a3f				   .CYCLES    SET	17
      2  1a3f
      3  1a3f				  -	      IF	.CYCLES < 2
      4  1a3f				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  1a3f				  -	      ERR
      6  1a3f					      ENDIF
      7  1a3f
      8  1a3f					      IF	.CYCLES & 1
      9  1a3f					      IFNCONST	NO_ILLEGAL_OPCODES
     10  1a3f		       04 00		      nop	0
     11  1a41				  -	      ELSE
     12  1a41				  -	      bit	VSYNC
     13  1a41					      ENDIF
     14  1a41				   .CYCLES    SET	.CYCLES - 3
     15  1a41					      ENDIF
     16  1a41
     17  1a41					      REPEAT	.CYCLES / 2
     18  1a41		       ea		      nop
     17  1a41					      REPEND
     18  1a42		       ea		      nop
     17  1a42					      REPEND
     18  1a43		       ea		      nop
     17  1a43					      REPEND
     18  1a44		       ea		      nop
     17  1a44					      REPEND
     18  1a45		       ea		      nop
     17  1a45					      REPEND
     18  1a46		       ea		      nop
     17  1a46					      REPEND
     18  1a47		       ea		      nop
     19  1a48					      REPEND
    424  1a48
    425  1a48		       a9 d3		      lda	#KERNEL_LINES
    426  1a4a		       8d 96 02 	      sta	TIM64T
    427  1a4d		       a9 01		      lda	#1
    428  1a4f		       85 27		      sta	VDELBL
    429  1a51		       85 25		      sta	VDELP0
    430  1a53
    431  1a53							; missile1
    432  1a53		       a9 07		      lda	#<(P1COLOR-1)
    433  1a55		       18		      clc
    434  1a56		       65 c0		      adc	missile1y
    435  1a58		       8d 41 10 	      sta	DF1TOP
    436  1a5b		       38		      sec
    437  1a5c		       65 c3		      adc	missile1height
    438  1a5e		       8d 49 10 	      sta	DF1BOT
    439  1a61
    440  1a61		       a9 00		      lda	#0
    441  1a63		       85 01		      sta	VBLANK
    442  1a65		       8d 58 10 	      sta	FASTFETCH
    443  1a68							;sleep 7
    444  1a68		       a9 12		      lda	#<DF2DATAW	; REVENG - added so GRP0 is at TOP
    445  1a6a		       85 1b		      STA	GRP0	; 36 (VDEL)   ; ""
      0  1a6c					      sleep	2	; ""
      1  1a6c				   .CYCLES    SET	2
      2  1a6c
      3  1a6c				  -	      IF	.CYCLES < 2
      4  1a6c				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  1a6c				  -	      ERR
      6  1a6c					      ENDIF
      7  1a6c
      8  1a6c				  -	      IF	.CYCLES & 1
      9  1a6c				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  1a6c				  -	      nop	0
     11  1a6c				  -	      ELSE
     12  1a6c				  -	      bit	VSYNC
     13  1a6c				  -	      ENDIF
     14  1a6c				  -.CYCLES    SET	.CYCLES - 3
     15  1a6c					      ENDIF
     16  1a6c
     17  1a6c					      REPEAT	.CYCLES / 2
     18  1a6c		       ea		      nop
     19  1a6d					      REPEND
    447  1a6d
    448  1a6d		       a9 18		      lda	#<DF0FRACDATA
    449  1a6f		       85 0e		      sta	PF1	; (PF1L)
    450  1a71
    451  1a71							; enter at cycle ??
    452  1a71				   loop
    453  1a71		       a9 08		      lda	#<DF0DATA	;74
    454  1a73		       85 06		      STA	COLUP0	; 1
    455  1a75		       a9 09		      lda	#<DF1DATA	;3
    456  1a77				   loop2
    457  1a77		       85 07		      STA	COLUP1	; 6
    458  1a79		       a9 0b		      lda	#<DF3DATA
    459  1a7b		       85 1c		      STA	GRP1	; 11
    460  1a7d		       a9 20		      lda	#<DF0FLAG
    461  1a7f		       85 1d		      STA	ENAM0	; 16
    462  1a81
    463  1a81		       a9 1e		      lda	#<DF6FRACDATA
    464  1a83		       85 09		      sta	COLUBK	; 21
    465  1a85		       a9 1c		      lda	#<DF4FRACDATA
    466  1a87		       85 08		      sta	COLUPF	; 26
    467  1a89		       a9 19		      lda	#<DF1FRACDATA
    468  1a8b		       85 0f		      sta	PF2	; 31 (PF2L)
    469  1a8d				   loop3
    470  1a8d		       a9 12		      lda	#<DF2DATAW
    471  1a8f		       85 1b		      STA	GRP0	; 36 (VDEL)
    472  1a91		       a9 23		      lda	#<DF3FLAG
    473  1a93		       85 1f		      STA	ENABL	; 41 (VDEL)
    474  1a95		       a2 70		      ldx	#$70	;in case we get kernel 6
    475  1a97		       a9 1a		      lda	#<DF2FRACDATA	;45
    476  1a99		       85 0f		      sta	PF2	; 48
    477  1a9b		       84 21		      sty	HMP1	; 51 ; from prev. cycle: $80=nomove
    478  1a9d		       a9 1b		      lda	#<DF3FRACDATA	;53
    479  1a9f		       85 0e		      sta	PF1	; 56
    480  1aa1		       a9 0c		      lda	#<DF4DATA	; 58 this is the repos info
    481  1aa3		       f0 44		      beq	repo	;60/61
    482  1aa5				   norepo		; 60
    483  1aa5		       a8		      tay		; 62
    484  1aa6		       a9 08		      lda	#<DF0DATA	; 64
    485  1aa8
    486  1aa8		       ae 84 02 	      ldx	INTIM	; 68 timed for 192 lines
    487  1aab		       f0 57		      beq	exitkernel	; 70/71
    488  1aad		       85 2a		      sta	HMOVE	; 73
    489  1aaf
    490  1aaf		       85 06		      STA	COLUP0	; 0
    491  1ab1		       a9 09		      lda	#<DF1DATA	;2
    492  1ab3		       85 07		      STA	COLUP1	;5
    493  1ab5		       a9 0b		      lda	#<DF3DATA
    494  1ab7		       85 1c		      STA	GRP1	; 10
    495  1ab9		       a9 21		      lda	#<DF1FLAG
    496  1abb		       85 1e		      STA	ENAM1	; 15
    497  1abd		       a9 18		      lda	#<DF0FRACDATA
    498  1abf		       85 0e		      sta	PF1	; 20 (PF1L)
    499  1ac1		       a9 19		      lda	#<DF1FRACDATA
    500  1ac3		       85 0f		      sta	PF2	; 25 (PF2L)
    501  1ac5		       a9 12		      lda	#<DF2DATAW
    502  1ac7		       85 1b		      STA	GRP0	; 30 (VDEL)
    503  1ac9		       a9 23		      lda	#<DF3FLAG
    504  1acb		       85 1f		      STA	ENABL	; 35 (VDEL)
    505  1acd		       88		      dey		; 37
    506  1ace		       8c 64 10 	      STY	DF4PUSH	; 41
    507  1ad1		       a0 80		      ldy	#$80	; 43 no movement next line
    508  1ad3		       a9 1a		      lda	#<DF2FRACDATA	;45
    509  1ad5		       85 0f		      sta	PF2	; 48
    510  1ad7		       84 21		      sty	HMP1	; 51 ; from prev. cycle: $80=nomove
    511  1ad9		       a9 1b		      lda	#<DF3FRACDATA	;53
    512  1adb		       85 0e		      sta	PF1	; 56
    513  1add					      ifnconst	DPC_kernel_options
    514  1add							;sleep 8 ; REVENG - timing is off - results in a garbled screen
      0  1add					      sleep	5	; this is better
      1  1add				   .CYCLES    SET	5
      2  1add
      3  1add				  -	      IF	.CYCLES < 2
      4  1add				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  1add				  -	      ERR
      6  1add					      ENDIF
      7  1add
      8  1add					      IF	.CYCLES & 1
      9  1add					      IFNCONST	NO_ILLEGAL_OPCODES
     10  1add		       04 00		      nop	0
     11  1adf				  -	      ELSE
     12  1adf				  -	      bit	VSYNC
     13  1adf					      ENDIF
     14  1adf				   .CYCLES    SET	.CYCLES - 3
     15  1adf					      ENDIF
     16  1adf
     17  1adf					      REPEAT	.CYCLES / 2
     18  1adf		       ea		      nop
     19  1ae0					      REPEND
    516  1ae0				  -	      else
    517  1ae0				  -	      bit	DPC_kernel_options
    518  1ae0				  -	      if	(DPC_kernel_options > $3F)
    519  1ae0				  -	      bmi	COLfound
    520  1ae0				  -	      else
    521  1ae0				  -	      bpl	COLfound
    522  1ae0				  -	      endif
    523  1ae0					      endif
    524  1ae0		       86 ce		      stx	temp4	; +3
    525  1ae2
    526  1ae2				   getbackearly
    527  1ae2		       a9 18		      lda	#<DF0FRACDATA	; +2
    528  1ae4		       85 0e		      sta	PF1	; 69 (PF1L) too early?
    529  1ae6		       4c 71 5a 	      JMP	loop+$4000	; 72
    530  1ae9
    531  1ae9				  -	      ifconst	DPC_kernel_options
    532  1ae9				  -COLfound
    533  1ae9				  -	      lda	DF0FRACDATA
    534  1ae9				  -	      sta	PF1	; 69 (PF1L) too early?
    535  1ae9				  -	      JMP	loop+$4000	; 72
    536  1ae9					      endif
    537  1ae9
    538  1ae9				   repo
    539  1ae9		       ac 1f 10 	      ldy	DF7FRACDATA	; 65
    540  1aec		       a9 18		      lda	#<DF0FRACDATA	; 67 preload PF1L for next line
    541  1aee				  -	      if	((>repo) > (>norepo))
    542  1aee				  -	      STA	PF1
    543  1aee					      else
    544  1aee		       8d 0e 00 	      STA.w	PF1	; 71 ; sta.w if page doesn't wrap
    545  1af1					      endif
    546  1af1		       a9 08		      lda	#<DF0DATA	;73
    547  1af3		       85 06		      STA	COLUP0	; 0
    548  1af5		       a9 09		      lda	#<DF1DATA
    549  1af7		       85 07		      STA	COLUP1	;5
    550  1af9		       a9 0b		      lda	#<DF3DATA
    551  1afb		       85 1c		      STA	GRP1	; 10
    552  1afd		       a9 21		      lda	#<DF1FLAG
    553  1aff		       85 1e		      STA	ENAM1	; 15
    554  1b01							; repos info holds HMMx
    555  1b01		       6c 0d 10 	      jmp	(DF5DATA)	; 20 grabs df6/df7=lo/hi
    556  1b04
    557  1b04				   exitkernel		; exit the kernel
    558  1b04		       20 c8 5e 	      jsr	scorekernel+$4000	; 1
    559  1b07				   exit
    560  1b07		       a2 ff		      ldx	#255
    561  1b09		       8e 58 10 	      stx	FASTFETCH
    562  1b0c		       85 02		      sta	WSYNC
    563  1b0e		       a9 02		      lda	#2
    564  1b10		       85 01		      STA	VBLANK
    565  1b12		       a9 a7		      lda	#OVERSCAN_LINES
    566  1b14		       8d 96 02 	      sta	TIM64T
    567  1b17		       38		      sec
    568  1b18		       a9 d3		      lda	#KERNEL_LINES
    569  1b1a		       e5 ce		      sbc	temp4
    570  1b1c		       aa		      tax
    571  1b1d		       4a		      lsr
    572  1b1e		       4a		      lsr
    573  1b1f		       85 cd		      sta	temp3	; div4
    574  1b21		       4a		      lsr
    575  1b22		       4a		      lsr
    576  1b23		       85 cc		      sta	temp2	; div16
    577  1b25		       4a		      lsr
    578  1b26		       85 cb		      sta	temp1	; div32
    579  1b28		       18		      clc
    580  1b29		       8a		      txa
    581  1b2a		       65 cc		      adc	temp2
    582  1b2c		       65 cb		      adc	temp1
    583  1b2e		       38		      sec
    584  1b2f		       e5 cd		      sbc	temp3
    585  1b31		       85 ce		      sta	temp4	; approx line of first pf coll
      0  1b33					      RETURN
      1  1b33				  -	      ifnconst	bankswitch
      2  1b33				  -	      rts
      3  1b33					      else
      4  1b33		       4c e0 df 	      jmp	BS_return
      5  1b36					      endif
    587  1b36
    588  1b36							; jmp exit
    589  1b36
    590  1b36							; kernels resp1 23/28/33/38/43/48/53/58/63/68/73
    591  1b36
    592  1b36				   kernel1
    593  1b36		       85 11		      sta	RESP1	; 23
    594  1b38		       a9 12		      lda	#<DF2DATAW
    595  1b3a		       85 1b		      STA	GRP0	; 28 (VDEL)
    596  1b3c		       a9 23		      lda	#<DF3FLAG
    597  1b3e		       85 1f		      STA	ENABL	; 33 (VDEL)
    598  1b40		       a9 19		      lda	#<DF1FRACDATA
    599  1b42		       85 0f		      STA	PF2	; 38
      0  1b44					      sleep	5
      1  1b44				   .CYCLES    SET	5
      2  1b44
      3  1b44				  -	      IF	.CYCLES < 2
      4  1b44				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  1b44				  -	      ERR
      6  1b44					      ENDIF
      7  1b44
      8  1b44					      IF	.CYCLES & 1
      9  1b44					      IFNCONST	NO_ILLEGAL_OPCODES
     10  1b44		       04 00		      nop	0
     11  1b46				  -	      ELSE
     12  1b46				  -	      bit	VSYNC
     13  1b46					      ENDIF
     14  1b46				   .CYCLES    SET	.CYCLES - 3
     15  1b46					      ENDIF
     16  1b46
     17  1b46					      REPEAT	.CYCLES / 2
     18  1b46		       ea		      nop
     19  1b47					      REPEND
    601  1b47		       a9 1a		      lda	#<DF2FRACDATA	;45
    602  1b49		       85 0f		      sta	PF2	; 48
    603  1b4b		       a9 1b		      lda	#<DF3FRACDATA	;50
    604  1b4d		       85 0e		      sta	PF1	; 53
    605  1b4f		       a9 1d		      lda	#<DF5FRACDATA	; NUSIZ/RESP info (OK here, GRP1 off)
    606  1b51		       85 05		      STA	NUSIZ1	; 58
    607  1b53		       85 0c		      STA	REFP1	; 61
    608  1b55		       4c e2 1a 	      jmp	getbackearly	;64
    609  1b58
    610  1b58				   kernel2
    611  1b58		       a9 12		      lda	#<DF2DATAW
    612  1b5a		       85 1b		      STA	GRP0	; 25 (VDEL)
    613  1b5c		       85 11		      sta	RESP1	;28
    614  1b5e		       a9 23		      lda	#<DF3FLAG
    615  1b60		       85 1f		      STA	ENABL	; 33 (VDEL)
    616  1b62		       a9 19		      lda	#<DF1FRACDATA
    617  1b64		       85 0f		      STA	PF2	; 38
      0  1b66					      sleep	5
      1  1b66				   .CYCLES    SET	5
      2  1b66
      3  1b66				  -	      IF	.CYCLES < 2
      4  1b66				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  1b66				  -	      ERR
      6  1b66					      ENDIF
      7  1b66
      8  1b66					      IF	.CYCLES & 1
      9  1b66					      IFNCONST	NO_ILLEGAL_OPCODES
     10  1b66		       04 00		      nop	0
     11  1b68				  -	      ELSE
     12  1b68				  -	      bit	VSYNC
     13  1b68					      ENDIF
     14  1b68				   .CYCLES    SET	.CYCLES - 3
     15  1b68					      ENDIF
     16  1b68
     17  1b68					      REPEAT	.CYCLES / 2
     18  1b68		       ea		      nop
     19  1b69					      REPEND
    619  1b69		       a9 1a		      lda	#<DF2FRACDATA	;45
    620  1b6b		       85 0f		      sta	PF2	; 48
    621  1b6d		       a9 1b		      lda	#<DF3FRACDATA	;50
    622  1b6f		       85 0e		      sta	PF1	; 53
    623  1b71		       a9 1d		      lda	#<DF5FRACDATA	; NUSIZ/RESP info (OK here, GRP1 off)
    624  1b73		       85 05		      STA	NUSIZ1
    625  1b75		       85 0c		      STA	REFP1
    626  1b77		       4c e2 1a 	      jmp	getbackearly	;64
    627  1b7a
    628  1b7a				   kernel3
    629  1b7a		       a9 12		      lda	#<DF2DATAW
    630  1b7c		       85 1b		      STA	GRP0	; 25 (VDEL)
    631  1b7e		       a9 23		      lda	#<DF3FLAG
    632  1b80		       85 1f		      STA	ENABL	; 30 (VDEL)
    633  1b82		       85 11		      sta	RESP1	;33
    634  1b84		       a9 19		      lda	#<DF1FRACDATA
    635  1b86		       85 0f		      STA	PF2	; 38
      0  1b88					      sleep	5
      1  1b88				   .CYCLES    SET	5
      2  1b88
      3  1b88				  -	      IF	.CYCLES < 2
      4  1b88				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  1b88				  -	      ERR
      6  1b88					      ENDIF
      7  1b88
      8  1b88					      IF	.CYCLES & 1
      9  1b88					      IFNCONST	NO_ILLEGAL_OPCODES
     10  1b88		       04 00		      nop	0
     11  1b8a				  -	      ELSE
     12  1b8a				  -	      bit	VSYNC
     13  1b8a					      ENDIF
     14  1b8a				   .CYCLES    SET	.CYCLES - 3
     15  1b8a					      ENDIF
     16  1b8a
     17  1b8a					      REPEAT	.CYCLES / 2
     18  1b8a		       ea		      nop
     19  1b8b					      REPEND
    637  1b8b		       a9 1a		      lda	#<DF2FRACDATA	;45
    638  1b8d		       85 0f		      sta	PF2	; 48
    639  1b8f		       a9 1b		      lda	#<DF3FRACDATA	;50
    640  1b91		       85 0e		      sta	PF1	; 53
    641  1b93		       a9 1d		      lda	#<DF5FRACDATA	; NUSIZ/RESP info (OK here, GRP1 off)
    642  1b95		       85 05		      STA	NUSIZ1
    643  1b97		       85 0c		      STA	REFP1
    644  1b99		       4c e2 1a 	      JMP	getbackearly	; 64
    645  1b9c
    646  1b9c				   kernel4
    647  1b9c		       a9 12		      lda	#<DF2DATAW
    648  1b9e		       85 1b		      STA	GRP0	; 25 (VDEL)
    649  1ba0		       a9 23		      lda	#<DF3FLAG
    650  1ba2		       85 1f		      STA	ENABL	; 30(VDEL)
    651  1ba4		       a9 19		      lda	#<DF1FRACDATA
    652  1ba6		       85 0f		      STA	PF2	; 35
    653  1ba8		       85 11		      sta	RESP1	;38
      0  1baa					      sleep	5
      1  1baa				   .CYCLES    SET	5
      2  1baa
      3  1baa				  -	      IF	.CYCLES < 2
      4  1baa				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  1baa				  -	      ERR
      6  1baa					      ENDIF
      7  1baa
      8  1baa					      IF	.CYCLES & 1
      9  1baa					      IFNCONST	NO_ILLEGAL_OPCODES
     10  1baa		       04 00		      nop	0
     11  1bac				  -	      ELSE
     12  1bac				  -	      bit	VSYNC
     13  1bac					      ENDIF
     14  1bac				   .CYCLES    SET	.CYCLES - 3
     15  1bac					      ENDIF
     16  1bac
     17  1bac					      REPEAT	.CYCLES / 2
     18  1bac		       ea		      nop
     19  1bad					      REPEND
    655  1bad		       a9 1a		      lda	#<DF2FRACDATA	;45
    656  1baf		       85 0f		      sta	PF2	; 48
    657  1bb1		       a9 1b		      lda	#<DF3FRACDATA	;50
    658  1bb3		       85 0e		      sta	PF1	; 53
    659  1bb5		       a9 1d		      lda	#<DF5FRACDATA	; NUSIZ/RESP info (OK here, GRP1 off)
    660  1bb7		       85 05		      STA	NUSIZ1	; 58
    661  1bb9		       85 0c		      STA	REFP1	; 61
    662  1bbb		       4c e2 1a 	      JMP	getbackearly	; 64
    663  1bbe
    664  1bbe				   kernel5
    665  1bbe		       a9 12		      lda	#<DF2DATAW
    666  1bc0		       85 1b		      STA	GRP0	; (VDEL)
    667  1bc2		       a9 23		      lda	#<DF3FLAG
    668  1bc4		       85 1f		      STA	ENABL	; (VDEL)
    669  1bc6		       a9 19		      lda	#<DF1FRACDATA
    670  1bc8		       85 0f		      STA	PF2	; 35
      0  1bca					      sleep	5
      1  1bca				   .CYCLES    SET	5
      2  1bca
      3  1bca				  -	      IF	.CYCLES < 2
      4  1bca				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  1bca				  -	      ERR
      6  1bca					      ENDIF
      7  1bca
      8  1bca					      IF	.CYCLES & 1
      9  1bca					      IFNCONST	NO_ILLEGAL_OPCODES
     10  1bca		       04 00		      nop	0
     11  1bcc				  -	      ELSE
     12  1bcc				  -	      bit	VSYNC
     13  1bcc					      ENDIF
     14  1bcc				   .CYCLES    SET	.CYCLES - 3
     15  1bcc					      ENDIF
     16  1bcc
     17  1bcc					      REPEAT	.CYCLES / 2
     18  1bcc		       ea		      nop
     19  1bcd					      REPEND
    672  1bcd		       85 11		      sta	RESP1	;43
    673  1bcf		       a9 1a		      lda	#<DF2FRACDATA	;45
    674  1bd1		       85 0f		      sta	PF2	; 48
    675  1bd3		       a9 1b		      lda	#<DF3FRACDATA	;50
    676  1bd5		       85 0e		      sta	PF1	; 53
    677  1bd7		       a9 1d		      lda	#<DF5FRACDATA	; NUSIZ/RESP info (OK here, GRP1 off)
    678  1bd9		       85 05		      STA	NUSIZ1
    679  1bdb		       85 0c		      STA	REFP1
    680  1bdd		       4c e2 1a 	      JMP	getbackearly	; 64
    681  1be0
    682  1be0				   kernel6
    683  1be0		       a9 12		      lda	#<DF2DATAW
    684  1be2		       85 1b		      STA	GRP0	; 25 (VDEL)
    685  1be4		       a9 23		      lda	#<DF3FLAG
    686  1be6		       85 1f		      STA	ENABL	; 30 (VDEL)
    687  1be8		       a9 19		      lda	#<DF1FRACDATA
    688  1bea		       85 0f		      STA	PF2	; 35
    689  1bec		       a9 1d		      lda	#<DF5FRACDATA	; 37 NUSIZ/RESP info (OK here, GRP1 off)
    690  1bee		       85 05		      STA	NUSIZ1	; 40
    691  1bf0		       85 0c		      STA	REFP1	; 43
    692  1bf2		       a9 1a		      lda	#<DF2FRACDATA	;45
    693  1bf4		       85 0f		      sta	PF2	; 48
    694  1bf6		       a9 1b		      lda	#<DF3FRACDATA	;50
    695  1bf8		       85 11		      sta	RESP1	;53
    696  1bfa							; do a move right by 15
    697  1bfa		       85 0e		      sta	PF1	; 56
    698  1bfc		       86 21		      stx	HMP1	; 59
    699  1bfe		       a9 19		      lda	#<DF1FRACDATA
    700  1c00		       85 0f		      sta	PF2	; 64 (PF2L)
    701  1c02		       a9 18		      lda	#<DF0FRACDATA
    702  1c04		       85 0e		      sta	PF1	; 69 (PF1L) too early?
    703  1c06		       a9 08		      lda	#<DF0DATA	; 71
    704  1c08		       85 2a		      sta	HMOVE	; 74 adjust to +15 right
    705  1c0a
    706  1c0a		       85 06		      STA	COLUP0	; 1
    707  1c0c		       a9 09		      lda	#<DF1DATA
    708  1c0e		       85 07		      sta	COLUP1	; 6
    709  1c10		       a9 0b		      lda	#<DF3DATA
    710  1c12		       85 1c		      STA	GRP1	; 11
    711  1c14		       a9 20		      lda	#<DF0FLAG
    712  1c16		       85 1d		      STA	ENAM0	; 16
    713  1c18		       a9 1e		      lda	#<DF6FRACDATA
    714  1c1a		       85 09		      STA	COLUBK	; 21
    715  1c1c		       a9 1c		      lda	#<DF4FRACDATA
    716  1c1e		       85 08		      sta	COLUPF	; 26
      0  1c20					      sleep	2
      1  1c20				   .CYCLES    SET	2
      2  1c20
      3  1c20				  -	      IF	.CYCLES < 2
      4  1c20				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  1c20				  -	      ERR
      6  1c20					      ENDIF
      7  1c20
      8  1c20				  -	      IF	.CYCLES & 1
      9  1c20				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  1c20				  -	      nop	0
     11  1c20				  -	      ELSE
     12  1c20				  -	      bit	VSYNC
     13  1c20				  -	      ENDIF
     14  1c20				  -.CYCLES    SET	.CYCLES - 3
     15  1c20					      ENDIF
     16  1c20
     17  1c20					      REPEAT	.CYCLES / 2
     18  1c20		       ea		      nop
     19  1c21					      REPEND
    718  1c21		       4c 8d 1a 	      jmp	loop3	; 31
    719  1c24
    720  1c24				   kernel7
    721  1c24		       a9 12		      lda	#<DF2DATAW
    722  1c26		       85 1b		      STA	GRP0	; 25 (VDEL)
    723  1c28		       a9 23		      lda	#<DF3FLAG
    724  1c2a		       85 1f		      STA	ENABL	; 30 (VDEL)
    725  1c2c		       a9 19		      lda	#<DF1FRACDATA
    726  1c2e		       85 0f		      STA	PF2	; 35
    727  1c30		       a9 1d		      lda	#<DF5FRACDATA	; 37 NUSIZ/RESP info (OK here, GRP1 off)
    728  1c32		       85 05		      STA	NUSIZ1	; 40
    729  1c34		       85 0c		      STA	REFP1	; 43
    730  1c36		       a9 1a		      lda	#<DF2FRACDATA	;45
    731  1c38		       85 0f		      sta	PF2	; 48
      0  1c3a					      sleep	2
      1  1c3a				   .CYCLES    SET	2
      2  1c3a
      3  1c3a				  -	      IF	.CYCLES < 2
      4  1c3a				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  1c3a				  -	      ERR
      6  1c3a					      ENDIF
      7  1c3a
      8  1c3a				  -	      IF	.CYCLES & 1
      9  1c3a				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  1c3a				  -	      nop	0
     11  1c3a				  -	      ELSE
     12  1c3a				  -	      bit	VSYNC
     13  1c3a				  -	      ENDIF
     14  1c3a				  -.CYCLES    SET	.CYCLES - 3
     15  1c3a					      ENDIF
     16  1c3a
     17  1c3a					      REPEAT	.CYCLES / 2
     18  1c3a		       ea		      nop
     19  1c3b					      REPEND
    733  1c3b		       85 11		      sta	RESP1	;53
    734  1c3d		       a9 1b		      lda	#<DF3FRACDATA	;55
    735  1c3f		       85 0e		      sta	PF1	; 58
      0  1c41					      sleep	3
      1  1c41				   .CYCLES    SET	3
      2  1c41
      3  1c41				  -	      IF	.CYCLES < 2
      4  1c41				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  1c41				  -	      ERR
      6  1c41					      ENDIF
      7  1c41
      8  1c41					      IF	.CYCLES & 1
      9  1c41					      IFNCONST	NO_ILLEGAL_OPCODES
     10  1c41		       04 00		      nop	0
     11  1c43				  -	      ELSE
     12  1c43				  -	      bit	VSYNC
     13  1c43					      ENDIF
     14  1c43				   .CYCLES    SET	.CYCLES - 3
     15  1c43					      ENDIF
     16  1c43
     17  1c43				  -	      REPEAT	.CYCLES / 2
     18  1c43				  -	      nop
     19  1c43					      REPEND
    737  1c43		       4c e2 1a 	      JMP	getbackearly	; 64
    738  1c46
    739  1c46				   kernel8
    740  1c46		       a9 12		      lda	#<DF2DATAW
    741  1c48		       85 1b		      STA	GRP0	; (VDEL)
    742  1c4a		       a9 23		      lda	#<DF3FLAG
    743  1c4c		       85 1f		      STA	ENABL	; (VDEL)
    744  1c4e		       a9 19		      lda	#<DF1FRACDATA
    745  1c50		       85 0f		      STA	PF2	; 35
    746  1c52		       a9 1d		      lda	#<DF5FRACDATA	; 37 NUSIZ/RESP info (OK here, GRP1 off)
    747  1c54		       85 05		      STA	NUSIZ1	; 40
    748  1c56		       85 0c		      STA	REFP1	; 43
    749  1c58		       a9 1a		      lda	#<DF2FRACDATA	;45
    750  1c5a		       85 0f		      sta	PF2	; 48
    751  1c5c		       a9 1b		      lda	#<DF3FRACDATA	;50
    752  1c5e		       85 0e		      sta	PF1	; 53
      0  1c60					      sleep	2
      1  1c60				   .CYCLES    SET	2
      2  1c60
      3  1c60				  -	      IF	.CYCLES < 2
      4  1c60				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  1c60				  -	      ERR
      6  1c60					      ENDIF
      7  1c60
      8  1c60				  -	      IF	.CYCLES & 1
      9  1c60				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  1c60				  -	      nop	0
     11  1c60				  -	      ELSE
     12  1c60				  -	      bit	VSYNC
     13  1c60				  -	      ENDIF
     14  1c60				  -.CYCLES    SET	.CYCLES - 3
     15  1c60					      ENDIF
     16  1c60
     17  1c60					      REPEAT	.CYCLES / 2
     18  1c60		       ea		      nop
     19  1c61					      REPEND
    754  1c61		       85 11		      sta	RESP1	;58
      0  1c63					      sleep	3
      1  1c63				   .CYCLES    SET	3
      2  1c63
      3  1c63				  -	      IF	.CYCLES < 2
      4  1c63				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  1c63				  -	      ERR
      6  1c63					      ENDIF
      7  1c63
      8  1c63					      IF	.CYCLES & 1
      9  1c63					      IFNCONST	NO_ILLEGAL_OPCODES
     10  1c63		       04 00		      nop	0
     11  1c65				  -	      ELSE
     12  1c65				  -	      bit	VSYNC
     13  1c65					      ENDIF
     14  1c65				   .CYCLES    SET	.CYCLES - 3
     15  1c65					      ENDIF
     16  1c65
     17  1c65				  -	      REPEAT	.CYCLES / 2
     18  1c65				  -	      nop
     19  1c65					      REPEND
    756  1c65		       4c e2 1a 	      JMP	getbackearly	; 64
    757  1c68
    758  1c68				   kernel9
    759  1c68		       a9 12		      lda	#<DF2DATAW
    760  1c6a		       85 1b		      STA	GRP0	; (VDEL)
    761  1c6c		       a9 23		      lda	#<DF3FLAG
    762  1c6e		       85 1f		      STA	ENABL	; (VDEL)
    763  1c70		       a9 19		      lda	#<DF1FRACDATA
    764  1c72		       85 0f		      STA	PF2	; 35
    765  1c74		       a9 1d		      lda	#<DF5FRACDATA	; 37 NUSIZ/RESP info (OK here, GRP1 off)
    766  1c76		       85 05		      STA	NUSIZ1	; 40
    767  1c78		       85 0c		      STA	REFP1	; 43
    768  1c7a		       a9 1a		      lda	#<DF2FRACDATA	;45
    769  1c7c		       85 0f		      sta	PF2	; 48
    770  1c7e		       a9 1b		      lda	#<DF3FRACDATA	;50
    771  1c80		       85 0e		      sta	PF1	; 53
      0  1c82					      sleep	5
      1  1c82				   .CYCLES    SET	5
      2  1c82
      3  1c82				  -	      IF	.CYCLES < 2
      4  1c82				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  1c82				  -	      ERR
      6  1c82					      ENDIF
      7  1c82
      8  1c82					      IF	.CYCLES & 1
      9  1c82					      IFNCONST	NO_ILLEGAL_OPCODES
     10  1c82		       04 00		      nop	0
     11  1c84				  -	      ELSE
     12  1c84				  -	      bit	VSYNC
     13  1c84					      ENDIF
     14  1c84				   .CYCLES    SET	.CYCLES - 3
     15  1c84					      ENDIF
     16  1c84
     17  1c84					      REPEAT	.CYCLES / 2
     18  1c84		       ea		      nop
     19  1c85					      REPEND
    773  1c85		       a9 18		      lda	#<DF0FRACDATA
    774  1c87		       85 11		      sta	RESP1	;63
      0  1c89					      sleep	3
      1  1c89				   .CYCLES    SET	3
      2  1c89
      3  1c89				  -	      IF	.CYCLES < 2
      4  1c89				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  1c89				  -	      ERR
      6  1c89					      ENDIF
      7  1c89
      8  1c89					      IF	.CYCLES & 1
      9  1c89					      IFNCONST	NO_ILLEGAL_OPCODES
     10  1c89		       04 00		      nop	0
     11  1c8b				  -	      ELSE
     12  1c8b				  -	      bit	VSYNC
     13  1c8b					      ENDIF
     14  1c8b				   .CYCLES    SET	.CYCLES - 3
     15  1c8b					      ENDIF
     16  1c8b
     17  1c8b				  -	      REPEAT	.CYCLES / 2
     18  1c8b				  -	      nop
     19  1c8b					      REPEND
    776  1c8b		       85 0e		      sta	PF1	; 69 (PF1L) too early?
    777  1c8d		       4c 71 1a 	      jmp	loop	;72
    778  1c90
    779  1c90				   kernel10
    780  1c90		       a9 12		      lda	#<DF2DATAW
    781  1c92		       85 1b		      STA	GRP0	; 25 (VDEL)
    782  1c94		       a9 23		      lda	#<DF3FLAG
    783  1c96		       85 1f		      STA	ENABL	; 30 (VDEL)
    784  1c98		       a9 19		      lda	#<DF1FRACDATA
    785  1c9a		       85 0f		      STA	PF2	; 35
    786  1c9c		       a9 1d		      lda	#<DF5FRACDATA	; 37 NUSIZ/RESP info (OK here, GRP1 off)
    787  1c9e		       85 05		      STA	NUSIZ1	; 40
    788  1ca0		       85 0c		      STA	REFP1	; 43
    789  1ca2		       a9 1a		      lda	#<DF2FRACDATA	;45
    790  1ca4		       85 0f		      sta	PF2	; 48
    791  1ca6		       a9 1b		      lda	#<DF3FRACDATA	;50
    792  1ca8		       85 0e		      sta	PF1	; 53
      0  1caa					      sleep	6
      1  1caa				   .CYCLES    SET	6
      2  1caa
      3  1caa				  -	      IF	.CYCLES < 2
      4  1caa				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  1caa				  -	      ERR
      6  1caa					      ENDIF
      7  1caa
      8  1caa				  -	      IF	.CYCLES & 1
      9  1caa				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  1caa				  -	      nop	0
     11  1caa				  -	      ELSE
     12  1caa				  -	      bit	VSYNC
     13  1caa				  -	      ENDIF
     14  1caa				  -.CYCLES    SET	.CYCLES - 3
     15  1caa					      ENDIF
     16  1caa
     17  1caa					      REPEAT	.CYCLES / 2
     18  1caa		       ea		      nop
     17  1caa					      REPEND
     18  1cab		       ea		      nop
     17  1cab					      REPEND
     18  1cac		       ea		      nop
     19  1cad					      REPEND
    794  1cad		       a9 18		      lda	#<DF0FRACDATA
    795  1caf		       ae 08 10 	      LDX	DF0DATA	; 65
    796  1cb2		       85 11		      sta	RESP1	; 68
    797  1cb4		       85 0e		      STA	PF1	; 71
    798  1cb6		       a9 09		      lda	#<DF1DATA	; 74
    799  1cb8		       86 06		      STX	COLUP0	; 0
    800  1cba		       4c 77 1a 	      jmp	loop2	; 3
    801  1cbd
    802  1cbd				   kernel11
    803  1cbd		       a9 12		      lda	#<DF2DATAW
    804  1cbf		       85 1b		      STA	GRP0	; (VDEL)
    805  1cc1		       a9 23		      lda	#<DF3FLAG
    806  1cc3		       85 1f		      STA	ENABL	; (VDEL)
    807  1cc5		       a9 19		      lda	#<DF1FRACDATA
    808  1cc7		       85 0f		      STA	PF2	; 35
    809  1cc9		       a9 1d		      lda	#<DF5FRACDATA	; NUSIZ/RESP info (OK here, GRP1 off)
    810  1ccb		       85 05		      STA	NUSIZ1
    811  1ccd		       85 0c		      STA	REFP1
    812  1ccf		       a9 1a		      lda	#<DF2FRACDATA	;45
    813  1cd1		       85 0f		      sta	PF2	; 48
    814  1cd3		       a9 1b		      lda	#<DF3FRACDATA	;50
    815  1cd5		       85 0e		      sta	PF1	; 53
      0  1cd7					      sleep	3
      1  1cd7				   .CYCLES    SET	3
      2  1cd7
      3  1cd7				  -	      IF	.CYCLES < 2
      4  1cd7				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  1cd7				  -	      ERR
      6  1cd7					      ENDIF
      7  1cd7
      8  1cd7					      IF	.CYCLES & 1
      9  1cd7					      IFNCONST	NO_ILLEGAL_OPCODES
     10  1cd7		       04 00		      nop	0
     11  1cd9				  -	      ELSE
     12  1cd9				  -	      bit	VSYNC
     13  1cd9					      ENDIF
     14  1cd9				   .CYCLES    SET	.CYCLES - 3
     15  1cd9					      ENDIF
     16  1cd9
     17  1cd9				  -	      REPEAT	.CYCLES / 2
     18  1cd9				  -	      nop
     19  1cd9					      REPEND
    817  1cd9		       a9 19		      lda	#<DF1FRACDATA	;45
    818  1cdb		       85 0f		      sta	PF2	; 61
    819  1cdd		       ae 08 10 	      LDX	DF0DATA	; 65
    820  1ce0
    821  1ce0		       a9 18		      lda	#<DF0FRACDATA	; 67
    822  1ce2		       85 0e		      sta	PF1	; 70
    823  1ce4		       85 11		      sta	RESP1	; 73
    824  1ce6		       86 06		      STX	COLUP0	; 0
    825  1ce8		       a9 09		      lda	#<DF1DATA	; 2
    826  1cea		       85 07		      sta	COLUP1	; 5
    827  1cec		       a9 0b		      lda	#<DF3DATA
    828  1cee		       85 1c		      STA	GRP1	; 10
    829  1cf0		       a9 20		      lda	#<DF0FLAG
    830  1cf2		       85 1d		      STA	ENAM0	; 25
    831  1cf4		       a9 1e		      lda	#<DF6FRACDATA
    832  1cf6		       85 09		      STA	COLUBK	; 20
    833  1cf8		       a9 1c		      lda	#<DF4FRACDATA
    834  1cfa		       85 08		      sta	COLUPF	; 25
      0  1cfc					      sleep	3
      1  1cfc				   .CYCLES    SET	3
      2  1cfc
      3  1cfc				  -	      IF	.CYCLES < 2
      4  1cfc				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  1cfc				  -	      ERR
      6  1cfc					      ENDIF
      7  1cfc
      8  1cfc					      IF	.CYCLES & 1
      9  1cfc					      IFNCONST	NO_ILLEGAL_OPCODES
     10  1cfc		       04 00		      nop	0
     11  1cfe				  -	      ELSE
     12  1cfe				  -	      bit	VSYNC
     13  1cfe					      ENDIF
     14  1cfe				   .CYCLES    SET	.CYCLES - 3
     15  1cfe					      ENDIF
     16  1cfe
     17  1cfe				  -	      REPEAT	.CYCLES / 2
     18  1cfe				  -	      nop
     19  1cfe					      REPEND
    836  1cfe		       4c 8d 1a 	      jmp	loop3	; 31
    837  1d01
    838  1d01				   set_fetchers
    839  1d01		       ad 6c 1d 	      lda	dflow
    840  1d04		       8d 50 10 	      sta	DF0LOW
    841  1d07		       ad 74 1d 	      lda	dfhigh
    842  1d0a		       8d 68 10 	      sta	DF0HI
    843  1d0d
    844  1d0d		       ad 6d 1d 	      lda	dflow+1
    845  1d10		       8d 51 10 	      sta	DF1LOW
    846  1d13		       ad 75 1d 	      lda	dfhigh+1
    847  1d16		       8d 69 10 	      sta	DF1HI
    848  1d19
    849  1d19		       ad 6e 1d 	      lda	dflow+2
    850  1d1c		       8d 52 10 	      sta	DF2LOW
    851  1d1f		       ad 76 1d 	      lda	dfhigh+2
    852  1d22		       8d 6a 10 	      sta	DF2HI
    853  1d25
    854  1d25				   set_fetchers36		; sets just 3-6
    855  1d25		       ad 6f 1d 	      lda	dflow+3
    856  1d28		       8d 53 10 	      sta	DF3LOW
    857  1d2b		       ad 77 1d 	      lda	dfhigh+3
    858  1d2e		       8d 6b 10 	      sta	DF3HI
    859  1d31
    860  1d31		       ad 70 1d 	      lda	dflow+4
    861  1d34		       8d 54 10 	      sta	DF4LOW
    862  1d37		       ad 78 1d 	      lda	dfhigh+4
    863  1d3a		       8d 6c 10 	      sta	DF4HI
    864  1d3d
    865  1d3d		       ad 71 1d 	      lda	dflow+5
    866  1d40		       8d 55 10 	      sta	DF5LOW
    867  1d43		       ad 79 1d 	      lda	dfhigh+5
    868  1d46		       8d 6d 10 	      sta	DF5HI
    869  1d49
    870  1d49		       ad 72 1d 	      lda	dflow+6
    871  1d4c		       8d 56 10 	      sta	DF6LOW
    872  1d4f		       ad 7a 1d 	      lda	dfhigh+6
    873  1d52		       8d 6e 10 	      sta	DF6HI
    874  1d55
    875  1d55		       60		      rts
    876  1d56
    877  1d56							;9d bad
    878  1d56							; the below isn't quite right
    879  1d56							;DF0DATA: COLUP0
    880  1d56							;DF1DATA: COLUP1
    881  1d56							;DF2DATAW: GRP0
    882  1d56							;DF3DATA: GRP1
    883  1d56							;DF4DATA: 2lk lines until repos/HMP1
    884  1d56							;DF5DATA: low byte of repo kernels (xpos mod 15)
    885  1d56							;DF6DATA: High byte of repo kernels (x pos div 15)
    886  1d56							;DF7DATA: Programmer's stack
    887  1d56							;DF0FRACDATA: PF1L
    888  1d56							;DF1FRACDATA: PF2L
    889  1d56							;DF4FRACDATA: COLUPF
    890  1d56							;DF2FRACDATA: PF2R
    891  1d56							;DF3FRACDATA: PF2L
    892  1d56							;DF5FRACDATA: Sprite NUSIZ1/REFP1 (only during repos)
    893  1d56							;DF6FRACDATA: COLUBK
    894  1d56							;DF7FRACDATA: HMP1
    895  1d56							;DF3FLAG: kernel exit loop ?? (use flags instead?)
    896  1d56							;DF0FLAG: ENAM0
    897  1d56							;DF1FLAG: ENAM1
    898  1d56							;DF3FLAG: ENABL
    899  1d56
    900  1d56				   fetcher_address_table
    901  1d56				   kernello
    902  1d56		       36		      .byte.b	<kernel1
    903  1d57		       58		      .byte.b	<kernel2
    904  1d58		       7a		      .byte.b	<kernel3
    905  1d59		       9c		      .byte.b	<kernel4
    906  1d5a		       be		      .byte.b	<kernel5
    907  1d5b		       e0		      .byte.b	<kernel6
    908  1d5c		       24		      .byte.b	<kernel7
    909  1d5d		       46		      .byte.b	<kernel8
    910  1d5e		       68		      .byte.b	<kernel9
    911  1d5f		       90		      .byte.b	<kernel10
    912  1d60		       bd		      .byte.b	<kernel11
    913  1d61				   kernelhi
    914  1d61		       1b		      .byte.b	>kernel1
    915  1d62		       1b		      .byte.b	>kernel2
    916  1d63		       1b		      .byte.b	>kernel3
    917  1d64		       1b		      .byte.b	>kernel4
    918  1d65		       1b		      .byte.b	>kernel5
    919  1d66		       1b		      .byte.b	>kernel6
    920  1d67		       1c		      .byte.b	>kernel7
    921  1d68		       1c		      .byte.b	>kernel8
    922  1d69		       1c		      .byte.b	>kernel9
    923  1d6a		       1c		      .byte.b	>kernel10
    924  1d6b		       1c		      .byte.b	>kernel11
    925  1d6c				   dflow
    926  1d6c		       08		      .byte.b	<P0COLOR
    927  1d6d		       08		      .byte.b	<P1COLOR
    928  1d6e		       08		      .byte.b	<P0GFX
    929  1d6f		       08		      .byte.b	<P1GFX
    930  1d70		       2d		      .byte.b	<P1SKIP
    931  1d71		       08		      .byte.b	<JUMPTABLELO
    932  1d72		       14		      .byte.b	<JUMPTABLEHI
    933  1d73		       a5		      .byte.b	<USERSTACK
    934  1d74				   dfhigh
    935  1d74		       05		      .byte.b	(>P0COLOR) & $0F
    936  1d75		       03		      .byte.b	(>P1COLOR) & $0F
    937  1d76		       04		      .byte.b	(>P0GFX) & $0F
    938  1d77		       02		      .byte.b	(>P1GFX) & $0F
    939  1d78		       0b		      .byte.b	(>P1SKIP) & $0F
    940  1d79		       0b		      .byte.b	(>JUMPTABLELO) & $0F
    941  1d7a		       0b		      .byte.b	(>JUMPTABLEHI) & $0F
    942  1d7b		       0d		      .byte.b	(>USERSTACK) & $0F
    943  1d7c				   dffraclow
    944  1d7c		       08		      .byte.b	<PF1L
    945  1d7d		       08		      .byte.b	<PF2L
    946  1d7e		       08		      .byte.b	<PF1R
    947  1d7f		       08		      .byte.b	<PF2R
    948  1d80		       08		      .byte.b	<PFCOLS
    949  1d81		       39		      .byte.b	<NUSIZREFP
    950  1d82		       a5		      .byte.b	<BKCOLS
    951  1d83		       20		      .byte.b	<P1HMP
    952  1d84				   dffrachi
    953  1d84		       06		      .byte.b	(>PF1L) & $0F
    954  1d85		       07		      .byte.b	(>PF2L) & $0F
    955  1d86		       08		      .byte.b	(>PF1R) & $0F
    956  1d87		       09		      .byte.b	(>PF2R) & $0F
    957  1d88		       0a		      .byte.b	(>PFCOLS) & $0F
    958  1d89		       0b		      .byte.b	(>NUSIZREFP) & $0F
    959  1d8a		       0b		      .byte.b	(>BKCOLS) & $0F
    960  1d8b		       0b		      .byte.b	(>P1HMP) & $0F
    961  1d8c				   scorepointer
    962  1d8c		       94		      .byte.b	<scoretable
    963  1d8d		       08		      .byte.b	((>scoretable) & $0f) | (((>scoretable) / 2) & $70)
    964  1d8e				   scoresetup		; pointers to digit graphics
    965  1d8e		       45		      .byte.b	<scoredata
    966  1d8f		       0b		      .byte.b	(>scoredata) & $0F
    967  1d90				   Hmval		; 112 wuz first
    968  1d90		       60 50 40 30*	      .byte.b	96, 80, 64, 48, 32, 16, 1, 240
    969  1d98				   Hmval74
    970  1d98		       e0 d0 c0 b0*	      .byte.b	224, 208, 192, 176, 160, 144, 128
    971  1d9f		       60 50 40 30*	      .byte.b	96, 80, 64, 48, 32, 16, 1, 240, 224, 208, 192, 176, 160, 144, 128, 96
    972  1daf		       50 40 30 20*	      .byte.b	80, 64, 48, 32, 16, 1, 240, 224, 208, 192, 176, 160, 144, 128, 96, 80
    973  1dbf		       40 30 20 10*	      .byte.b	64, 48, 32, 16, 1, 240, 224, 208, 192, 176, 160, 144, 128, 96, 80, 64
    974  1dcf		       30 20 10 01*	      .byte.b	48, 32, 16, 1, 240, 224, 208, 192, 176, 160, 144, 128, 96, 80, 64, 48
    975  1ddf		       20 10 01 f0*	      .byte.b	32, 16, 1, 240, 224, 208, 192, 176, 160, 144, 128, 96, 80, 64, 48, 32
    976  1def		       10 01 f0 e0*	      .byte.b	16, 1, 240, 224, 208, 192, 176, 160, 144, 128, 96, 80, 64, 48, 32, 16
    977  1dff		       01 f0 e0 d0*	      .byte.b	1, 240, 224, 208, 192, 176, 160, 144, 128, 96, 80, 64, 48, 32, 16, 1
    978  1e0f		       f0 e0 d0 c0*	      .byte.b	240, 224, 208, 192, 176, 160, 144, 128, 96, 80, 64, 48, 32, 16, 1, 240
    979  1e1f		       e0 d0 c0 b0*	      .byte.b	224, 208, 192, 176, 160, 144, 128, 96, 80, 64, 48, 32, 16, 1, 240, 224, 208, 192
    980  1e31		       b0 a0 90 80*	      .byte.b	176,160,144,128,16,1,240,224
    981  1e39
    982  1e39
    983  1e39				   kernel_setup
    984  1e39							;--position P0, top P1, M0, M1, BL
    985  1e39		       a2 00		      ldx	#0	; first sprite displayed
    986  1e3b		       b5 85		      lda	SpriteGfxIndex,x
    987  1e3d		       aa		      tax
    988  1e3e		       b5 90		      lda	player1x,x
    989  1e40		       c9 a0		      cmp	#160
    990  1e42		       90 0a		      bcc	nostorep1
    991  1e44		       c9 d0		      cmp	#208
    992  1e46		       b0 02		      bcs	ksadjustdown
    993  1e48							; 160-208: minus 160
    994  1e48							;add 160 is like minus 96
    995  1e48							; so minus 64
    996  1e48		       e9 3f		      sbc	#63	;cc
    997  1e4a				   ksadjustdown
    998  1e4a							; 209-255: add 160
    999  1e4a		       69 9f		      adc	#159	; cs
   1000  1e4c		       95 90		      sta	player1x,x
   1001  1e4e				   nostorep1
   1002  1e4e		       85 02		      sta	WSYNC
   1003  1e50		       a2 04		      ldx	#4
   1004  1e52		       85 81		      sta	topP1x	; cache top p1
   1005  1e54				   HorPosLoop
   1006  1e54		       b5 80		      lda	player0x,X
   1007  1e56		       38		      sec
   1008  1e57				   DivideLoop
   1009  1e57		       e9 0f		      sbc	#15
   1010  1e59		       b0 fc		      bcs	DivideLoop
      0  1e5b					      sleep	4
      1  1e5b				   .CYCLES    SET	4
      2  1e5b
      3  1e5b				  -	      IF	.CYCLES < 2
      4  1e5b				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  1e5b				  -	      ERR
      6  1e5b					      ENDIF
      7  1e5b
      8  1e5b				  -	      IF	.CYCLES & 1
      9  1e5b				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  1e5b				  -	      nop	0
     11  1e5b				  -	      ELSE
     12  1e5b				  -	      bit	VSYNC
     13  1e5b				  -	      ENDIF
     14  1e5b				  -.CYCLES    SET	.CYCLES - 3
     15  1e5b					      ENDIF
     16  1e5b
     17  1e5b					      REPEAT	.CYCLES / 2
     18  1e5b		       ea		      nop
     17  1e5b					      REPEND
     18  1e5c		       ea		      nop
     19  1e5d					      REPEND
   1012  1e5d		       95 10		      sta	RESP0,X
   1013  1e5f		       85 02		      sta	WSYNC
   1014  1e61		       ca		      dex		;2
   1015  1e62		       10 f0		      bpl	HorPosLoop	;4/5
   1016  1e64
   1017  1e64		       a4 80		      ldy	player0x	; 7
   1018  1e66		       b9 90 1d 	      lda	Hmval,y	; 11
   1019  1e69		       85 20		      sta	HMP0	; 14
   1020  1e6b
   1021  1e6b		       a4 81		      ldy	player0x+1
   1022  1e6d		       b9 90 1d 	      lda	Hmval,y
   1023  1e70		       85 21		      sta	HMP0+1	; 24
   1024  1e72
   1025  1e72		       a4 82		      ldy	player0x+2
   1026  1e74		       b9 90 1d 	      lda	Hmval,y
   1027  1e77		       85 22		      sta	HMP0+2	; 34
   1028  1e79
   1029  1e79		       a4 83		      ldy	player0x+3
   1030  1e7b		       b9 90 1d 	      lda	Hmval,y
   1031  1e7e		       85 23		      sta	HMP0+3	; 44
   1032  1e80
   1033  1e80		       a4 84		      ldy	player0x+4
   1034  1e82		       b9 90 1d 	      lda	Hmval,y
   1035  1e85		       85 24		      sta	HMP0+4	; 54
   1036  1e87
   1037  1e87		       85 02		      sta	WSYNC
   1038  1e89		       85 2a		      sta	HMOVE
   1039  1e8b
   1040  1e8b				   myrts
   1041  1e8b		       60		      rts
   1042  1e8c
   1043  1e8c
   1044  1e8c				   pfsetup
   1045  1e8c
   1046  1e8c		       84 cb		      sty	temp1
   1047  1e8e		       85 cc		      sta	temp2
   1048  1e90		       86 cd		      stx	temp3
   1049  1e92		       a2 03		      ldx	#3
   1050  1e94				   pfsetupp
   1051  1e94		       bd 7c 1d 	      lda	dffraclow,x
   1052  1e97		       9d 50 10 	      sta	DF0LOW,x
   1053  1e9a		       bd 84 1d 	      lda	dffrachi,x
   1054  1e9d		       9d 68 10 	      sta	DF0HI,x
   1055  1ea0		       a5 cc		      lda	temp2
   1056  1ea2		       8d 59 10 	      sta	PARAMETER
   1057  1ea5		       a5 cd		      lda	temp3
   1058  1ea7		       8d 59 10 	      sta	PARAMETER
   1059  1eaa		       8e 59 10 	      stx	PARAMETER
   1060  1ead		       8c 59 10 	      sty	PARAMETER
   1061  1eb0		       a9 01		      LDA	#1
   1062  1eb2		       8d 5a 10 	      sta	CALLFUNCTION
   1063  1eb5		       18		      clc
   1064  1eb6		       a5 cc		      lda	temp2
   1065  1eb8		       65 cb		      adc	temp1
   1066  1eba		       85 cc		      sta	temp2
   1067  1ebc		       a5 cd		      lda	temp3
   1068  1ebe		       69 00		      adc	#0
   1069  1ec0		       85 cd		      sta	temp3
   1070  1ec2		       ca		      dex
   1071  1ec3		       10 cf		      bpl	pfsetupp
      0  1ec5					      RETURN
      1  1ec5				  -	      ifnconst	bankswitch
      2  1ec5				  -	      rts
      3  1ec5					      else
      4  1ec5		       4c e0 df 	      jmp	BS_return
      5  1ec8					      endif
   1073  1ec8
   1074  1ec8
   1075  1ec8				   scorekernel
   1076  1ec8				  -	      ifconst	minikernel
   1077  1ec8				  -			;; disable fast fetch, call the minikernel, and re-enable fast fetch
   1078  1ec8				  -	      lda	#255
   1079  1ec8				  -	      sta	FASTFETCH
   1080  1ec8				  -	      jsr	minikernel
   1081  1ec8				  -	      lda	#0
   1082  1ec8				  -	      sta.w	FASTFETCH
   1083  1ec8					      endif
   1084  1ec8		       a6 eb		      ldx	scorecolor
   1085  1eca		       86 06		      stx	COLUP0
   1086  1ecc		       86 07		      stx	COLUP1
   1087  1ece		       a2 00		      ldx	#0
   1088  1ed0		       86 0e		      STx	PF1
   1089  1ed2		       86 0b		      stx	REFP0
   1090  1ed4		       86 0c		      stx	REFP1
   1091  1ed6		       86 1b		      STx	GRP0
   1092  1ed8		       86 1c		      STx	GRP1
   1093  1eda		       86 0f		      STx	PF2
   1094  1edc		       86 2b		      stx	HMCLR
   1095  1ede		       86 1d		      stx	ENAM0
   1096  1ee0		       86 1e		      stx	ENAM1
   1097  1ee2		       86 1f		      stx	ENABL
   1098  1ee4
   1099  1ee4
   1100  1ee4				  -	      ifconst	pfscore
   1101  1ee4				  -	      lda	pfscorecolor
   1102  1ee4				  -	      sta	COLUPF
   1103  1ee4					      endif
   1104  1ee4
   1105  1ee4				  -	      ifconst	noscore
   1106  1ee4				  -	      ldx	#10
   1107  1ee4				  -noscoreloop
   1108  1ee4				  -	      sta	WSYNC
   1109  1ee4				  -	      dex
   1110  1ee4				  -	      bpl	noscoreloop
   1111  1ee4				  -	      rts
   1112  1ee4					      else
   1113  1ee4
   1114  1ee4		       85 2b		      sta	HMCLR
   1115  1ee6		       a2 f0		      ldx	#$f0
   1116  1ee8		       86 20		      stx	HMP0
   1117  1eea
   1118  1eea							; set up fetchers 0-5 to handle score digits
   1119  1eea		       a2 45		      ldx	#<(scoredata)
   1120  1eec		       8e 56 10 	      stx	DF6LOW
   1121  1eef		       a2 0b		      ldx	#(>(scoredata)) & $0F
   1122  1ef1		       8e 6e 10 	      stx	DF6HI
   1123  1ef4		       a2 4d		      ldx	#<(scoredata+8)
   1124  1ef6		       8e 50 10 	      stx	DF0LOW
   1125  1ef9		       a2 0b		      ldx	#(>(scoredata+8)) & $0F
   1126  1efb		       8e 68 10 	      stx	DF0HI
   1127  1efe		       a2 55		      ldx	#<(scoredata+16)
   1128  1f00		       8e 51 10 	      stx	DF1LOW
   1129  1f03							; cycle 0??
   1130  1f03		       a2 0b		      ldx	#(>(scoredata+16)) & $0F
   1131  1f05		       8e 69 10 	      stx	DF1HI
   1132  1f08		       a2 5d		      ldx	#<(scoredata+24)
   1133  1f0a		       8e 52 10 	      stx	DF2LOW
   1134  1f0d		       a2 0b		      ldx	#(>(scoredata+24)) & $0F
   1135  1f0f		       8e 6a 10 	      stx	DF2HI
   1136  1f12
   1137  1f12		       85 02		      sta	WSYNC
   1138  1f14		       a2 00		      ldx	#0
   1139  1f16		       86 1b		      STx	GRP0
   1140  1f18		       86 1c		      STx	GRP1	; seems to be needed because of vdel
   1141  1f1a
   1142  1f1a		       a2 65		      ldx	#<(scoredata+32)
   1143  1f1c		       8e 53 10 	      stx	DF3LOW
   1144  1f1f		       a2 0b		      ldx	#(>(scoredata+32)) & $0F
   1145  1f21		       8e 6b 10 	      stx	DF3HI
   1146  1f24		       a2 6d		      ldx	#<(scoredata+40)
   1147  1f26		       8e 54 10 	      stx	DF4LOW
   1148  1f29		       a2 0b		      ldx	#(>(scoredata+40)) & $0F
   1149  1f2b		       8e 6c 10 	      stx	DF4HI
   1150  1f2e
   1151  1f2e		       a0 07		      LDY	#7
   1152  1f30		       a2 03		      LDx	#$03
   1153  1f32		       84 25		      STY	VDELP0
   1154  1f34		       85 10		      STA	RESP0
   1155  1f36		       85 11		      STA	RESP1
   1156  1f38		       84 cb		      sty	temp1
   1157  1f3a
   1158  1f3a		       86 04		      STx	NUSIZ0
   1159  1f3c		       86 05		      STx	NUSIZ1
   1160  1f3e		       86 26		      STx	VDELP1
   1161  1f40		       a2 75		      ldx	#<(scoredata+48)
   1162  1f42		       8e 55 10 	      stx	DF5LOW
   1163  1f45		       a2 0b		      ldx	#(>(scoredata+48)) & $0F
   1164  1f47		       8e 6d 10 	      stx	DF5HI
   1165  1f4a		       8d 2a 00 	      STA.w	HMOVE	; cycle 73 ?
   1166  1f4d				   scoreloop
   1167  1f4d		       a9 0e		      lda	#<DF6DATA	;59
   1168  1f4f		       85 06		      sta	COLUP0	;62
   1169  1f51		       85 07		      sta	COLUP1	;65
   1170  1f53		       a9 09		      lda	#<DF1DATA	;75
   1171  1f55		       85 1b		      sta	GRP0	;2
   1172  1f57		       a9 08		      lda	#<DF0DATA	;4
   1173  1f59		       85 1c		      sta	GRP1	;7
   1174  1f5b		       a9 0b		      lda	#<DF3DATA	;9
   1175  1f5d		       85 1b		      sta	GRP0	;12
   1176  1f5f
   1177  1f5f							; REVENG - rearranged to correct pf write timing and A register overwrite
   1178  1f5f				  -	      ifconst	pfscore
   1179  1f5f				  -	      lda	pfscore1
   1180  1f5f				  -	      sta	PF1
   1181  1f5f					      else
      0  1f5f					      sleep	6
      1  1f5f				   .CYCLES    SET	6
      2  1f5f
      3  1f5f				  -	      IF	.CYCLES < 2
      4  1f5f				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  1f5f				  -	      ERR
      6  1f5f					      ENDIF
      7  1f5f
      8  1f5f				  -	      IF	.CYCLES & 1
      9  1f5f				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  1f5f				  -	      nop	0
     11  1f5f				  -	      ELSE
     12  1f5f				  -	      bit	VSYNC
     13  1f5f				  -	      ENDIF
     14  1f5f				  -.CYCLES    SET	.CYCLES - 3
     15  1f5f					      ENDIF
     16  1f5f
     17  1f5f					      REPEAT	.CYCLES / 2
     18  1f5f		       ea		      nop
     17  1f5f					      REPEND
     18  1f60		       ea		      nop
     17  1f60					      REPEND
     18  1f61		       ea		      nop
     19  1f62					      REPEND
   1183  1f62					      endif
      0  1f62					      sleep	5
      1  1f62				   .CYCLES    SET	5
      2  1f62
      3  1f62				  -	      IF	.CYCLES < 2
      4  1f62				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  1f62				  -	      ERR
      6  1f62					      ENDIF
      7  1f62
      8  1f62					      IF	.CYCLES & 1
      9  1f62					      IFNCONST	NO_ILLEGAL_OPCODES
     10  1f62		       04 00		      nop	0
     11  1f64				  -	      ELSE
     12  1f64				  -	      bit	VSYNC
     13  1f64					      ENDIF
     14  1f64				   .CYCLES    SET	.CYCLES - 3
     15  1f64					      ENDIF
     16  1f64
     17  1f64					      REPEAT	.CYCLES / 2
     18  1f64		       ea		      nop
     19  1f65					      REPEND
   1185  1f65		       ae 0a 10 	      ldx	DF2DATA	;16
   1186  1f68		       ac 0d 10 	      ldy	DF5DATA	;20
   1187  1f6b		       a9 0c		      lda	#<DF4DATA	;22
   1188  1f6d
   1189  1f6d		       86 1c		      stx	GRP1	;40
   1190  1f6f		       84 1b		      sty	GRP0	;43
   1191  1f71		       85 1c		      sta	GRP1	;46
   1192  1f73		       85 1b		      sta	GRP0	;49
   1193  1f75				  -	      ifconst	pfscore
   1194  1f75				  -	      lda	pfscore2
   1195  1f75				  -	      sta	PF1
   1196  1f75					      else
      0  1f75					      sleep	6
      1  1f75				   .CYCLES    SET	6
      2  1f75
      3  1f75				  -	      IF	.CYCLES < 2
      4  1f75				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  1f75				  -	      ERR
      6  1f75					      ENDIF
      7  1f75
      8  1f75				  -	      IF	.CYCLES & 1
      9  1f75				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  1f75				  -	      nop	0
     11  1f75				  -	      ELSE
     12  1f75				  -	      bit	VSYNC
     13  1f75				  -	      ENDIF
     14  1f75				  -.CYCLES    SET	.CYCLES - 3
     15  1f75					      ENDIF
     16  1f75
     17  1f75					      REPEAT	.CYCLES / 2
     18  1f75		       ea		      nop
     17  1f75					      REPEND
     18  1f76		       ea		      nop
     17  1f76					      REPEND
     18  1f77		       ea		      nop
     19  1f78					      REPEND
   1198  1f78					      endif
   1199  1f78							; sleep 2 ;57
      0  1f78					      sleep	6
      1  1f78				   .CYCLES    SET	6
      2  1f78
      3  1f78				  -	      IF	.CYCLES < 2
      4  1f78				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  1f78				  -	      ERR
      6  1f78					      ENDIF
      7  1f78
      8  1f78				  -	      IF	.CYCLES & 1
      9  1f78				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  1f78				  -	      nop	0
     11  1f78				  -	      ELSE
     12  1f78				  -	      bit	VSYNC
     13  1f78				  -	      ENDIF
     14  1f78				  -.CYCLES    SET	.CYCLES - 3
     15  1f78					      ENDIF
     16  1f78
     17  1f78					      REPEAT	.CYCLES / 2
     18  1f78		       ea		      nop
     17  1f78					      REPEND
     18  1f79		       ea		      nop
     17  1f79					      REPEND
     18  1f7a		       ea		      nop
     19  1f7b					      REPEND
   1201  1f7b		       c6 cb		      dec	temp1	;70
   1202  1f7d		       10 ce		      bpl	scoreloop	;72/73
   1203  1f7f		       a2 00		      LDx	#0
   1204  1f81		       86 0e		      stx	PF1
   1205  1f83		       86 1b		      STx	GRP0
   1206  1f85		       86 1c		      STx	GRP1
   1207  1f87		       86 25		      STx	VDELP0
   1208  1f89		       86 26		      STx	VDELP1	;do we need these
   1209  1f8b		       86 04		      STx	NUSIZ0
   1210  1f8d		       86 05		      STx	NUSIZ1
   1211  1f8f
   1212  1f8f		       60		      rts
   1213  1f90
   1214  1f90
   1215  1f90					      endif		; noscore
   1216  1f90				   game
   1217  1f90				   .
   1218  1f90							;
   1219  1f90
   1220  1f90				   .
   1221  1f90							;
   1222  1f90
   1223  1f90				   .
   1224  1f90							;
   1225  1f90
   1226  1f90				   .
   1227  1f90							;
   1228  1f90
   1229  1f90				   .
   1230  1f90							;
   1231  1f90
   1232  1f90				   .
   1233  1f90							;
   1234  1f90
   1235  1f90				   .
   1236  1f90							;
   1237  1f90
   1238  1f90				   .L00 		;  set kernel DPC +
   1239  1f90
   1240  1f90				   .L01 		;  set tv ntsc
   1241  1f90
   1242  1f90				   .L02 		;  set smartbranching on
   1243  1f90
   1244  1f90				   .
   1245  1f90							;
   1246  1f90
   1247  1f90				   .
   1248  1f90							;
   1249  1f90
   1250  1f90				   .L03 		;  dim stackCounter  =  a
   1251  1f90
   1252  1f90				   .L04 		;  dim neighbors  =  b
   1253  1f90
   1254  1f90				   .L05 		;  dim chkX  =  c
   1255  1f90
   1256  1f90				   .L06 		;  dim chkY  =  d
   1257  1f90
   1258  1f90				   .L07 		;  dim tmp  =	e
   1259  1f90
   1260  1f90				   .L08 		;  dim drawCounter  =	f
   1261  1f90
   1262  1f90				   .L09 		;  dim startingSeed  =  g
   1263  1f90
   1264  1f90				   .
   1265  1f90							;
   1266  1f90
   1267  1f90				   .L010		;  rem x, y are used for loops. z used for bits
   1268  1f90
   1269  1f90							;.flipNeeded.	z{0}.
   1270  1f90				   .L011		;  def flipNeeded  =  z{0}
   1271  1f90
   1272  1f90							;.resetFlag.  z{1}.
   1273  1f90				   .L012		;  def resetFlag  =  z{1}
   1274  1f90
   1275  1f90				   .
   1276  1f90							;
   1277  1f90
   1278  1f90				   .
   1279  1f90							;
   1280  1f90
   1281  1f90							;.MAXX.  30.
   1282  1f90				   .L013		;  def MAXX  =  30
   1283  1f90
   1284  1f90							;.MAXY.  20.
   1285  1f90				   .L014		;  def MAXY  =  20
   1286  1f90
   1287  1f90							;.FILLVALUE.  50.
   1288  1f90				   .L015		;  def FILLVALUE  =  50
   1289  1f90
   1290  1f90							;.RES.  32.
   1291  1f90				   .L016		;  def RES  =	32
   1292  1f90
   1293  1f90							;.REDRAW_FRAME.  4.
   1294  1f90				   .L017		;  def REDRAW_FRAME  =  4
   1295  1f90
   1296  1f90				   .
   1297  1f90							;
   1298  1f90
   1299  1f90				   .L018		;  goto Init bank2
   1300  1f90
   1301  1f90		       85 81		      sta	temp7
   1302  1f92		       a9 30		      lda	#>(.Init-1)
   1303  1f94		       48		      pha
   1304  1f95		       a9 a3		      lda	#<(.Init-1)
   1305  1f97		       48		      pha
   1306  1f98		       a5 81		      lda	temp7
   1307  1f9a		       48		      pha
   1308  1f9b		       8a		      txa
   1309  1f9c		       48		      pha
   1310  1f9d		       a2 02		      ldx	#2
   1311  1f9f		       4c ee df 	      jmp	BS_jsr
   1312  1fa2				   .
   1313  1fa2							;
   1314  1fa2
   1315  1fa2				   .
   1316  1fa2							;
   1317  1fa2
   1318  1fa2				   .
   1319  1fa2							;
   1320  1fa2
   1321  1fa2				   .
   1322  1fa2							;
   1323  1fa2
   1324  1fa2				   .
   1325  1fa2							;
   1326  1fa2
   1327  1fa2				   .
   1328  1fa2							;
   1329  1fa2
   1330  1fa2				   .L019		;  bank 2
   1331  1fa2
   1332  1fa2					      if	ECHO1
      50 bytes of ROM space left in bank 1
   1333  1fa2					      echo	"    ",[(start_bank1 - *)]d , "bytes of ROM space left in bank 1")
   1334  1fa2					      endif
   1335  1fa2		       00 01	   ECHO1      =	1
   1336  1fd4					      ORG	$1FF4-bscode_length
   1337  1fd4					      RORG	$1FF4-bscode_length
   1338  1fd4		       a2 ff	   start_bank1 ldx	#$ff
   1339  1fd6					      ifconst	FASTFETCH	; using DPC+
   1340  1fd6		       8e 58 10 	      stx	FASTFETCH
   1341  1fd9					      endif
   1342  1fd9		       9a		      txs
   1343  1fda				  -	      if	bankswitch == 64
   1344  1fda				  -	      lda	#(((>(start-1)) & $0F) | $F0)
   1345  1fda					      else
   1346  1fda		       a9 18		      lda	#>(start-1)
   1347  1fdc					      endif
   1348  1fdc		       48		      pha
   1349  1fdd		       a9 eb		      lda	#<(start-1)
   1350  1fdf		       48		      pha
   1351  1fe0		       48		      pha
   1352  1fe1		       8a		      txa
   1353  1fe2		       48		      pha
   1354  1fe3		       ba		      tsx
   1355  1fe4					      if	bankswitch != 64
   1356  1fe4		       b5 04		      lda	4,x	; get high byte of return address
   1357  1fe6		       2a		      rol
   1358  1fe7		       2a		      rol
   1359  1fe8		       2a		      rol
   1360  1fe9		       2a		      rol
   1361  1fea		       29 07		      and	#bs_mask	;1 3 or 7 for F8/F6/F4
   1362  1fec		       aa		      tax
   1363  1fed		       e8		      inx
   1364  1fee				  -	      else
   1365  1fee				  -	      lda	4,x	; get high byte of return address
   1366  1fee				  -	      tay
   1367  1fee				  -	      ora	#$10	; change our bank nibble into a valid rom mirror
   1368  1fee				  -	      sta	4,x
   1369  1fee				  -	      tya
   1370  1fee				  -	      lsr
   1371  1fee				  -	      lsr
   1372  1fee				  -	      lsr
   1373  1fee				  -	      lsr
   1374  1fee				  -	      tax
   1375  1fee				  -	      inx
   1376  1fee					      endif
   1377  1fee		       bd f5 1f 	      lda	bankswitch_hotspot-1,x
   1378  1ff1		       68		      pla
   1379  1ff2		       aa		      tax
   1380  1ff3		       68		      pla
   1381  1ff4		       60		      rts
   1382  1ff5				  -	      if	((* & $1FFF) > ((bankswitch_hotspot & $1FFF) - 1))
   1383  1ff5				  -	      echo	"WARNING: size parameter in banksw.asm too small - the program probably will not work."
   1384  1ff5				  -	      echo	"Change to",[(*-begin_bscode+1)&$FF]d,"and try again."
   1385  1ff5					      endif
   1386  1ffc					      ORG	$1FFC
   1387  1ffc					      RORG	$1FFC
   1388  1ffc		       d4 1f		      .word.w	start_bank1
   1389  1ffe		       d4 1f		      .word.w	start_bank1
   1390  2000					      ORG	$2000
   1391  2000					      RORG	$3000
   1392  2000				   HMdiv
   1393  2000		       00 00 00 00*	      .byte.b	0, 0, 0, 0, 0, 0, 0
   1394  2007		       01 01 01 01*	      .byte.b	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2
   1395  2017		       02 02 02 02*	      .byte.b	2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3
   1396  2027		       03 03 03 03*	      .byte.b	3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4
   1397  2037		       04 04 04 04*	      .byte.b	4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5
   1398  2047		       05 05 05 05*	      .byte.b	5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6
   1399  2057		       06 06 06 06*	      .byte.b	6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7
   1400  2067		       07 07 07 07*	      .byte.b	7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8
   1401  2077		       08 08 08 08*	      .byte.b	8, 8, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9
   1402  2087		       09 09 09 09*	      .byte.b	9, 9, 9, 9, 9, 9, 9, 10, 10, 10, 10, 10, 10, 10, 10, 10
   1403  2097		       0a 0a 0a 0a*	      .byte.b	10,10,10,10,10,10,0,0,0
   1404  20a0				   .L020		;  temp1 = temp1
   1405  20a0
   1406  20a0		       a5 cb		      LDA	temp1
   1407  20a2		       85 cb		      STA	temp1
   1408  20a4				   .
   1409  20a4							;
   1410  20a4
   1411  20a4				   .Init
   1412  20a4							; Init
   1413  20a4
   1414  20a4				   .L021		;  drawscreen
   1415  20a4
   1416  20a4		       85 81		      sta	temp7
   1417  20a6		       a9 30		      lda	#>(ret_point1-1)
   1418  20a8		       48		      pha
   1419  20a9		       a9 bb		      lda	#<(ret_point1-1)
   1420  20ab		       48		      pha
   1421  20ac		       a9 19		      lda	#>(drawscreen-1)
   1422  20ae		       48		      pha
   1423  20af		       a9 50		      lda	#<(drawscreen-1)
   1424  20b1		       48		      pha
   1425  20b2		       a5 81		      lda	temp7
   1426  20b4		       48		      pha
   1427  20b5		       8a		      txa
   1428  20b6		       48		      pha
   1429  20b7		       a2 01		      ldx	#1
   1430  20b9		       4c ee df 	      jmp	BS_jsr
   1431  20bc				   ret_point1
   1432  20bc				   .L022		;  pfclear
   1433  20bc
   1434  20bc		       a9 a4		      lda	#<C_function
   1435  20be		       8d 50 10 	      sta	DF0LOW
   1436  20c1		       a9 01		      lda	#(>C_function) & $0F
   1437  20c3		       8d 68 10 	      sta	DF0HI
   1438  20c6		       a2 1c		      ldx	#28
   1439  20c8		       8e 78 10 	      stx	DF0WRITE
   1440  20cb		       a9 00		      LDA	#0
   1441  20cd		       8d 78 10 	      sta	DF0WRITE
   1442  20d0		       a9 ff		      lda	#255
   1443  20d2		       8d 5a 10 	      sta	CALLFUNCTION
   1444  20d5				   .L023		;  AUDV0  =  0  :  AUDV1  =  0
   1445  20d5
   1446  20d5		       a9 00		      LDA	#0
   1447  20d7		       85 19		      STA	AUDV0
   1448  20d9		       85 1a		      STA	AUDV1
   1449  20db				   .
   1450  20db							;
   1451  20db
   1452  20db				   .
   1453  20db							;
   1454  20db
   1455  20db				   .L024		;  a  =  0  :	b  =  0  :  c  =  0  :	d  =  0  :  e  =  0  :	f  =  0  :  g  =  0  :	h  =  0  :  i  =  0
   1456  20db
   1457  20db		       a9 00		      LDA	#0
   1458  20dd		       85 d1		      STA	a
   1459  20df		       85 d2		      STA	b
   1460  20e1		       85 d3		      STA	c
   1461  20e3		       85 d4		      STA	d
   1462  20e5		       85 d5		      STA	e
   1463  20e7		       85 d6		      STA	f
   1464  20e9		       85 d7		      STA	g
   1465  20eb		       85 d8		      STA	h
   1466  20ed		       85 d9		      STA	i
   1467  20ef				   .L025		;  j  =  0  :	k  =  0  :  l  =  0  :	m  =  0  :  n  =  0  :	o  =  0  :  p  =  0  :	q  =  0  :  r  =  0
   1468  20ef
   1469  20ef		       a9 00		      LDA	#0
   1470  20f1		       85 da		      STA	j
   1471  20f3		       85 db		      STA	k
   1472  20f5		       85 dc		      STA	l
   1473  20f7		       85 dd		      STA	m
   1474  20f9		       85 de		      STA	n
   1475  20fb		       85 df		      STA	o
   1476  20fd		       85 e0		      STA	p
   1477  20ff		       85 e1		      STA	q
   1478  2101		       85 e2		      STA	r
   1479  2103				   .L026		;  s  =  0  :	t  =  0  :  u  =  0  :	v  =  0  :  w  =  0  :	x  =  0  :  y  =  0  :	z  =  0
   1480  2103
   1481  2103		       a9 00		      LDA	#0
   1482  2105		       85 e3		      STA	s
   1483  2107		       85 e4		      STA	t
   1484  2109		       85 e5		      STA	u
   1485  210b		       85 e6		      STA	v
   1486  210d		       85 e7		      STA	w
   1487  210f		       85 e8		      STA	x
   1488  2111		       85 e9		      STA	y
   1489  2113		       85 ea		      STA	z
   1490  2115				   .L027		;  var0  =  0	:  var1  =  0  :  var2	=  0  :  var3  =  0  :	var4  =  0
   1491  2115
   1492  2115		       a9 00		      LDA	#0
   1493  2117		       85 ec		      STA	var0
   1494  2119		       85 ed		      STA	var1
   1495  211b		       85 ee		      STA	var2
   1496  211d		       85 ef		      STA	var3
   1497  211f		       85 f0		      STA	var4
   1498  2121				   .L028		;  var5  =  0	:  var6  =  0  :  var7	=  0  :  var8  =  0
   1499  2121
   1500  2121		       a9 00		      LDA	#0
   1501  2123		       85 f1		      STA	var5
   1502  2125		       85 f2		      STA	var6
   1503  2127		       85 f3		      STA	var7
   1504  2129		       85 f4		      STA	var8
   1505  212b				   .
   1506  212b							;
   1507  212b
   1508  212b				   .
   1509  212b							;
   1510  212b
   1511  212b				   .L029		;  scorecolors:
   1512  212b
   1513  212b		       a9 45		      lda	#<scoredata
   1514  212d		       8d 50 10 	      STA	DF0LOW
   1515  2130		       a9 0b		      lda	#((>scoredata) & $0f)
   1516  2132		       8d 68 10 	      STA	DF0HI
   1517  2135		       a9 9e		      lda	#$9E
   1518  2137
   1519  2137		       8d 78 10 	      sta	DF0WRITE
   1520  213a		       a9 9c		      lda	#$9C
   1521  213c
   1522  213c		       8d 78 10 	      sta	DF0WRITE
   1523  213f		       a9 9a		      lda	#$9A
   1524  2141
   1525  2141		       8d 78 10 	      sta	DF0WRITE
   1526  2144		       a9 9a		      lda	#$9A
   1527  2146
   1528  2146		       8d 78 10 	      sta	DF0WRITE
   1529  2149		       a9 98		      lda	#$98
   1530  214b
   1531  214b		       8d 78 10 	      sta	DF0WRITE
   1532  214e		       a9 98		      lda	#$98
   1533  2150
   1534  2150		       8d 78 10 	      sta	DF0WRITE
   1535  2153		       a9 96		      lda	#$96
   1536  2155
   1537  2155		       8d 78 10 	      sta	DF0WRITE
   1538  2158		       a9 96		      lda	#$96
   1539  215a
   1540  215a		       8d 78 10 	      sta	DF0WRITE
   1541  215d				   .
   1542  215d							;
   1543  215d
   1544  215d				   .
   1545  215d							;
   1546  215d
   1547  215d				   .L030		;  gosub SelectSeed bank4
   1548  215d
   1549  215d		       85 81		      sta	temp7
   1550  215f		       a9 31		      lda	#>(ret_point2-1)
   1551  2161		       48		      pha
   1552  2162		       a9 74		      lda	#<(ret_point2-1)
   1553  2164		       48		      pha
   1554  2165		       a9 70		      lda	#>(.SelectSeed-1)
   1555  2167		       48		      pha
   1556  2168		       a9 84		      lda	#<(.SelectSeed-1)
   1557  216a		       48		      pha
   1558  216b		       a5 81		      lda	temp7
   1559  216d		       48		      pha
   1560  216e		       8a		      txa
   1561  216f		       48		      pha
   1562  2170		       a2 04		      ldx	#4
   1563  2172		       4c ee df 	      jmp	BS_jsr
   1564  2175				   ret_point2
   1565  2175				   .
   1566  2175							;
   1567  2175
   1568  2175				   .L031		;  goto MainLoop bank3
   1569  2175
   1570  2175		       85 81		      sta	temp7
   1571  2177		       a9 50		      lda	#>(.MainLoop-1)
   1572  2179		       48		      pha
   1573  217a		       a9 84		      lda	#<(.MainLoop-1)
   1574  217c		       48		      pha
   1575  217d		       a5 81		      lda	temp7
   1576  217f		       48		      pha
   1577  2180		       8a		      txa
   1578  2181		       48		      pha
   1579  2182		       a2 03		      ldx	#3
   1580  2184		       4c ee df 	      jmp	BS_jsr
   1581  2187				   .
   1582  2187							;
   1583  2187
   1584  2187				   .
   1585  2187							;
   1586  2187
   1587  2187				   .
   1588  2187							;
   1589  2187
   1590  2187				   .
   1591  2187							;
   1592  2187
   1593  2187				   .L032		;  bank 3
   1594  2187
   1595  2187					      if	ECHO2
      3661 bytes of ROM space left in bank 2
   1596  2187					      echo	"    ",[(start_bank2 - *)]d , "bytes of ROM space left in bank 2")
   1597  2187					      endif
   1598  2187		       00 01	   ECHO2      =	1
   1599  2fd4					      ORG	$2FF4-bscode_length
   1600  2fd4					      RORG	$3FF4-bscode_length
   1601  2fd4		       a2 ff	   start_bank2 ldx	#$ff
   1602  2fd6					      ifconst	FASTFETCH	; using DPC+
   1603  2fd6		       8e 58 10 	      stx	FASTFETCH
   1604  2fd9					      endif
   1605  2fd9		       9a		      txs
   1606  2fda				  -	      if	bankswitch == 64
   1607  2fda				  -	      lda	#(((>(start-1)) & $0F) | $F0)
   1608  2fda					      else
   1609  2fda		       a9 18		      lda	#>(start-1)
   1610  2fdc					      endif
   1611  2fdc		       48		      pha
   1612  2fdd		       a9 eb		      lda	#<(start-1)
   1613  2fdf		       48		      pha
   1614  2fe0		       48		      pha
   1615  2fe1		       8a		      txa
   1616  2fe2		       48		      pha
   1617  2fe3		       ba		      tsx
   1618  2fe4					      if	bankswitch != 64
   1619  2fe4		       b5 04		      lda	4,x	; get high byte of return address
   1620  2fe6		       2a		      rol
   1621  2fe7		       2a		      rol
   1622  2fe8		       2a		      rol
   1623  2fe9		       2a		      rol
   1624  2fea		       29 07		      and	#bs_mask	;1 3 or 7 for F8/F6/F4
   1625  2fec		       aa		      tax
   1626  2fed		       e8		      inx
   1627  2fee				  -	      else
   1628  2fee				  -	      lda	4,x	; get high byte of return address
   1629  2fee				  -	      tay
   1630  2fee				  -	      ora	#$10	; change our bank nibble into a valid rom mirror
   1631  2fee				  -	      sta	4,x
   1632  2fee				  -	      tya
   1633  2fee				  -	      lsr
   1634  2fee				  -	      lsr
   1635  2fee				  -	      lsr
   1636  2fee				  -	      lsr
   1637  2fee				  -	      tax
   1638  2fee				  -	      inx
   1639  2fee					      endif
   1640  2fee		       bd f5 1f 	      lda	bankswitch_hotspot-1,x
   1641  2ff1		       68		      pla
   1642  2ff2		       aa		      tax
   1643  2ff3		       68		      pla
   1644  2ff4		       60		      rts
   1645  2ff5				  -	      if	((* & $1FFF) > ((bankswitch_hotspot & $1FFF) - 1))
   1646  2ff5				  -	      echo	"WARNING: size parameter in banksw.asm too small - the program probably will not work."
   1647  2ff5				  -	      echo	"Change to",[(*-begin_bscode+1)&$FF]d,"and try again."
   1648  2ff5					      endif
   1649  2ffc					      ORG	$2FFC
   1650  2ffc					      RORG	$3FFC
   1651  2ffc		       d4 3f		      .word.w	start_bank2
   1652  2ffe		       d4 3f		      .word.w	start_bank2
   1653  3000					      ORG	$3000
   1654  3000					      RORG	$5000
   1655  3000					      repeat	129
   1656  3000		       00		      .byte.b	0
   1655  3000					      repend
   1656  3001		       00		      .byte.b	0
   1655  3001					      repend
   1656  3002		       00		      .byte.b	0
   1655  3002					      repend
   1656  3003		       00		      .byte.b	0
   1655  3003					      repend
   1656  3004		       00		      .byte.b	0
   1655  3004					      repend
   1656  3005		       00		      .byte.b	0
   1655  3005					      repend
   1656  3006		       00		      .byte.b	0
   1655  3006					      repend
   1656  3007		       00		      .byte.b	0
   1655  3007					      repend
   1656  3008		       00		      .byte.b	0
   1655  3008					      repend
   1656  3009		       00		      .byte.b	0
   1655  3009					      repend
   1656  300a		       00		      .byte.b	0
   1655  300a					      repend
   1656  300b		       00		      .byte.b	0
   1655  300b					      repend
   1656  300c		       00		      .byte.b	0
   1655  300c					      repend
   1656  300d		       00		      .byte.b	0
   1655  300d					      repend
   1656  300e		       00		      .byte.b	0
   1655  300e					      repend
   1656  300f		       00		      .byte.b	0
   1655  300f					      repend
   1656  3010		       00		      .byte.b	0
   1655  3010					      repend
   1656  3011		       00		      .byte.b	0
   1655  3011					      repend
   1656  3012		       00		      .byte.b	0
   1655  3012					      repend
   1656  3013		       00		      .byte.b	0
   1655  3013					      repend
   1656  3014		       00		      .byte.b	0
   1655  3014					      repend
   1656  3015		       00		      .byte.b	0
   1655  3015					      repend
   1656  3016		       00		      .byte.b	0
   1655  3016					      repend
   1656  3017		       00		      .byte.b	0
   1655  3017					      repend
   1656  3018		       00		      .byte.b	0
   1655  3018					      repend
   1656  3019		       00		      .byte.b	0
   1655  3019					      repend
   1656  301a		       00		      .byte.b	0
   1655  301a					      repend
   1656  301b		       00		      .byte.b	0
   1655  301b					      repend
   1656  301c		       00		      .byte.b	0
   1655  301c					      repend
   1656  301d		       00		      .byte.b	0
   1655  301d					      repend
   1656  301e		       00		      .byte.b	0
   1655  301e					      repend
   1656  301f		       00		      .byte.b	0
   1655  301f					      repend
   1656  3020		       00		      .byte.b	0
   1655  3020					      repend
   1656  3021		       00		      .byte.b	0
   1655  3021					      repend
   1656  3022		       00		      .byte.b	0
   1655  3022					      repend
   1656  3023		       00		      .byte.b	0
   1655  3023					      repend
   1656  3024		       00		      .byte.b	0
   1655  3024					      repend
   1656  3025		       00		      .byte.b	0
   1655  3025					      repend
   1656  3026		       00		      .byte.b	0
   1655  3026					      repend
   1656  3027		       00		      .byte.b	0
   1655  3027					      repend
   1656  3028		       00		      .byte.b	0
   1655  3028					      repend
   1656  3029		       00		      .byte.b	0
   1655  3029					      repend
   1656  302a		       00		      .byte.b	0
   1655  302a					      repend
   1656  302b		       00		      .byte.b	0
   1655  302b					      repend
   1656  302c		       00		      .byte.b	0
   1655  302c					      repend
   1656  302d		       00		      .byte.b	0
   1655  302d					      repend
   1656  302e		       00		      .byte.b	0
   1655  302e					      repend
   1656  302f		       00		      .byte.b	0
   1655  302f					      repend
   1656  3030		       00		      .byte.b	0
   1655  3030					      repend
   1656  3031		       00		      .byte.b	0
   1655  3031					      repend
   1656  3032		       00		      .byte.b	0
   1655  3032					      repend
   1656  3033		       00		      .byte.b	0
   1655  3033					      repend
   1656  3034		       00		      .byte.b	0
   1655  3034					      repend
   1656  3035		       00		      .byte.b	0
   1655  3035					      repend
   1656  3036		       00		      .byte.b	0
   1655  3036					      repend
   1656  3037		       00		      .byte.b	0
   1655  3037					      repend
   1656  3038		       00		      .byte.b	0
   1655  3038					      repend
   1656  3039		       00		      .byte.b	0
   1655  3039					      repend
   1656  303a		       00		      .byte.b	0
   1655  303a					      repend
   1656  303b		       00		      .byte.b	0
   1655  303b					      repend
   1656  303c		       00		      .byte.b	0
   1655  303c					      repend
   1656  303d		       00		      .byte.b	0
   1655  303d					      repend
   1656  303e		       00		      .byte.b	0
   1655  303e					      repend
   1656  303f		       00		      .byte.b	0
   1655  303f					      repend
   1656  3040		       00		      .byte.b	0
   1655  3040					      repend
   1656  3041		       00		      .byte.b	0
   1655  3041					      repend
   1656  3042		       00		      .byte.b	0
   1655  3042					      repend
   1656  3043		       00		      .byte.b	0
   1655  3043					      repend
   1656  3044		       00		      .byte.b	0
   1655  3044					      repend
   1656  3045		       00		      .byte.b	0
   1655  3045					      repend
   1656  3046		       00		      .byte.b	0
   1655  3046					      repend
   1656  3047		       00		      .byte.b	0
   1655  3047					      repend
   1656  3048		       00		      .byte.b	0
   1655  3048					      repend
   1656  3049		       00		      .byte.b	0
   1655  3049					      repend
   1656  304a		       00		      .byte.b	0
   1655  304a					      repend
   1656  304b		       00		      .byte.b	0
   1655  304b					      repend
   1656  304c		       00		      .byte.b	0
   1655  304c					      repend
   1656  304d		       00		      .byte.b	0
   1655  304d					      repend
   1656  304e		       00		      .byte.b	0
   1655  304e					      repend
   1656  304f		       00		      .byte.b	0
   1655  304f					      repend
   1656  3050		       00		      .byte.b	0
   1655  3050					      repend
   1656  3051		       00		      .byte.b	0
   1655  3051					      repend
   1656  3052		       00		      .byte.b	0
   1655  3052					      repend
   1656  3053		       00		      .byte.b	0
   1655  3053					      repend
   1656  3054		       00		      .byte.b	0
   1655  3054					      repend
   1656  3055		       00		      .byte.b	0
   1655  3055					      repend
   1656  3056		       00		      .byte.b	0
   1655  3056					      repend
   1656  3057		       00		      .byte.b	0
   1655  3057					      repend
   1656  3058		       00		      .byte.b	0
   1655  3058					      repend
   1656  3059		       00		      .byte.b	0
   1655  3059					      repend
   1656  305a		       00		      .byte.b	0
   1655  305a					      repend
   1656  305b		       00		      .byte.b	0
   1655  305b					      repend
   1656  305c		       00		      .byte.b	0
   1655  305c					      repend
   1656  305d		       00		      .byte.b	0
   1655  305d					      repend
   1656  305e		       00		      .byte.b	0
   1655  305e					      repend
   1656  305f		       00		      .byte.b	0
   1655  305f					      repend
   1656  3060		       00		      .byte.b	0
   1655  3060					      repend
   1656  3061		       00		      .byte.b	0
   1655  3061					      repend
   1656  3062		       00		      .byte.b	0
   1655  3062					      repend
   1656  3063		       00		      .byte.b	0
   1655  3063					      repend
   1656  3064		       00		      .byte.b	0
   1655  3064					      repend
   1656  3065		       00		      .byte.b	0
   1655  3065					      repend
   1656  3066		       00		      .byte.b	0
   1655  3066					      repend
   1656  3067		       00		      .byte.b	0
   1655  3067					      repend
   1656  3068		       00		      .byte.b	0
   1655  3068					      repend
   1656  3069		       00		      .byte.b	0
   1655  3069					      repend
   1656  306a		       00		      .byte.b	0
   1655  306a					      repend
   1656  306b		       00		      .byte.b	0
   1655  306b					      repend
   1656  306c		       00		      .byte.b	0
   1655  306c					      repend
   1656  306d		       00		      .byte.b	0
   1655  306d					      repend
   1656  306e		       00		      .byte.b	0
   1655  306e					      repend
   1656  306f		       00		      .byte.b	0
   1655  306f					      repend
   1656  3070		       00		      .byte.b	0
   1655  3070					      repend
   1656  3071		       00		      .byte.b	0
   1655  3071					      repend
   1656  3072		       00		      .byte.b	0
   1655  3072					      repend
   1656  3073		       00		      .byte.b	0
   1655  3073					      repend
   1656  3074		       00		      .byte.b	0
   1655  3074					      repend
   1656  3075		       00		      .byte.b	0
   1655  3075					      repend
   1656  3076		       00		      .byte.b	0
   1655  3076					      repend
   1656  3077		       00		      .byte.b	0
   1655  3077					      repend
   1656  3078		       00		      .byte.b	0
   1655  3078					      repend
   1656  3079		       00		      .byte.b	0
   1655  3079					      repend
   1656  307a		       00		      .byte.b	0
   1655  307a					      repend
   1656  307b		       00		      .byte.b	0
   1655  307b					      repend
   1656  307c		       00		      .byte.b	0
   1655  307c					      repend
   1656  307d		       00		      .byte.b	0
   1655  307d					      repend
   1656  307e		       00		      .byte.b	0
   1655  307e					      repend
   1656  307f		       00		      .byte.b	0
   1655  307f					      repend
   1656  3080		       00		      .byte.b	0
   1657  3081					      repend
   1658  3081				   .L033		;  temp1 = temp1
   1659  3081
   1660  3081		       a5 cb		      LDA	temp1
   1661  3083		       85 cb		      STA	temp1
   1662  3085				   .
   1663  3085							;
   1664  3085
   1665  3085				   .
   1666  3085							;
   1667  3085
   1668  3085				   .MainLoop
   1669  3085							; MainLoop
   1670  3085
   1671  3085				   .
   1672  3085							;
   1673  3085
   1674  3085				   .
   1675  3085							;
   1676  3085
   1677  3085				   .L034		;  stackCounter  =  0
   1678  3085
   1679  3085		       a9 00		      LDA	#0
   1680  3087		       85 d1		      STA	stackCounter
   1681  3089				   .
   1682  3089							;
   1683  3089
   1684  3089				   .
   1685  3089							;
   1686  3089
   1687  3089				   .L035		;  for y  =  1 to MAXY
   1688  3089
   1689  3089		       a9 01		      LDA	#1
   1690  308b		       85 e9		      STA	y
   1691  308d				   .L035fory
   1692  308d				   .L036		;  for x  =  1 to MAXX
   1693  308d
   1694  308d		       a9 01		      LDA	#1
   1695  308f		       85 e8		      STA	x
   1696  3091				   .L036forx
   1697  3091				   .
   1698  3091							;
   1699  3091
   1700  3091				   .
   1701  3091							;
   1702  3091
   1703  3091				   .L037		;  neighbors  =  0
   1704  3091
   1705  3091		       a9 00		      LDA	#0
   1706  3093		       85 d2		      STA	neighbors
   1707  3095				   .
   1708  3095							;
   1709  3095
   1710  3095				   .L038		;  chkX  =  x	-  1
   1711  3095
   1712  3095		       a5 e8		      LDA	x
   1713  3097		       38		      SEC
   1714  3098		       e9 01		      SBC	#1
   1715  309a		       85 d3		      STA	chkX
   1716  309c				   .L039		;  if pfread ( chkX ,	y )  then neighbors  =	neighbors  +  1
   1717  309c
   1718  309c		       a9 a4		      lda	#<C_function
   1719  309e		       8d 50 10 	      sta	DF0LOW
   1720  30a1		       a9 01		      lda	#(>C_function) & $0F
   1721  30a3		       8d 68 10 	      sta	DF0HI
   1722  30a6		       a9 18		      lda	#24
   1723  30a8		       8d 78 10 	      sta	DF0WRITE
   1724  30ab		       a5 d3		      LDA	chkX
   1725  30ad		       8d 78 10 	      STA	DF0WRITE
   1726  30b0		       a4 e9		      LDY	y
   1727  30b2		       8c 78 10 	      STY	DF0WRITE
   1728  30b5		       a9 ff		      lda	#255
   1729  30b7		       8d 5a 10 	      sta	CALLFUNCTION
   1730  30ba		       ad 08 10 	      LDA	DF0DATA
   1731  30bd		       d0 02		      BNE	.skipL039
   1732  30bf				   .condpart0
   1733  30bf		       e6 d2		      INC	neighbors
   1734  30c1				   .skipL039
   1735  30c1				   .L040		;  chkY  =  y	-  1
   1736  30c1
   1737  30c1		       a5 e9		      LDA	y
   1738  30c3		       38		      SEC
   1739  30c4		       e9 01		      SBC	#1
   1740  30c6		       85 d4		      STA	chkY
   1741  30c8				   .L041		;  if pfread ( x ,  chkY )  then neighbors  =	neighbors  +  1
   1742  30c8
   1743  30c8		       a9 a4		      lda	#<C_function
   1744  30ca		       8d 50 10 	      sta	DF0LOW
   1745  30cd		       a9 01		      lda	#(>C_function) & $0F
   1746  30cf		       8d 68 10 	      sta	DF0HI
   1747  30d2		       a9 18		      lda	#24
   1748  30d4		       8d 78 10 	      sta	DF0WRITE
   1749  30d7		       a5 e8		      LDA	x
   1750  30d9		       8d 78 10 	      STA	DF0WRITE
   1751  30dc		       a4 d4		      LDY	chkY
   1752  30de		       8c 78 10 	      STY	DF0WRITE
   1753  30e1		       a9 ff		      lda	#255
   1754  30e3		       8d 5a 10 	      sta	CALLFUNCTION
   1755  30e6		       ad 08 10 	      LDA	DF0DATA
   1756  30e9		       d0 02		      BNE	.skipL041
   1757  30eb				   .condpart1
   1758  30eb		       e6 d2		      INC	neighbors
   1759  30ed				   .skipL041
   1760  30ed				   .L042		;  chkX  =  x	+  1
   1761  30ed
   1762  30ed		       a5 e8		      LDA	x
   1763  30ef		       18		      CLC
   1764  30f0		       69 01		      ADC	#1
   1765  30f2		       85 d3		      STA	chkX
   1766  30f4				   .L043		;  if pfread ( chkX ,	y )  then neighbors  =	neighbors  +  1
   1767  30f4
   1768  30f4		       a9 a4		      lda	#<C_function
   1769  30f6		       8d 50 10 	      sta	DF0LOW
   1770  30f9		       a9 01		      lda	#(>C_function) & $0F
   1771  30fb		       8d 68 10 	      sta	DF0HI
   1772  30fe		       a9 18		      lda	#24
   1773  3100		       8d 78 10 	      sta	DF0WRITE
   1774  3103		       a5 d3		      LDA	chkX
   1775  3105		       8d 78 10 	      STA	DF0WRITE
   1776  3108		       a4 e9		      LDY	y
   1777  310a		       8c 78 10 	      STY	DF0WRITE
   1778  310d		       a9 ff		      lda	#255
   1779  310f		       8d 5a 10 	      sta	CALLFUNCTION
   1780  3112		       ad 08 10 	      LDA	DF0DATA
   1781  3115		       d0 02		      BNE	.skipL043
   1782  3117				   .condpart2
   1783  3117		       e6 d2		      INC	neighbors
   1784  3119				   .skipL043
   1785  3119				   .L044		;  chkY  =  y	+  1
   1786  3119
   1787  3119		       a5 e9		      LDA	y
   1788  311b		       18		      CLC
   1789  311c		       69 01		      ADC	#1
   1790  311e		       85 d4		      STA	chkY
   1791  3120				   .L045		;  if pfread ( x ,  chkY )  then neighbors  =	neighbors  +  1
   1792  3120
   1793  3120		       a9 a4		      lda	#<C_function
   1794  3122		       8d 50 10 	      sta	DF0LOW
   1795  3125		       a9 01		      lda	#(>C_function) & $0F
   1796  3127		       8d 68 10 	      sta	DF0HI
   1797  312a		       a9 18		      lda	#24
   1798  312c		       8d 78 10 	      sta	DF0WRITE
   1799  312f		       a5 e8		      LDA	x
   1800  3131		       8d 78 10 	      STA	DF0WRITE
   1801  3134		       a4 d4		      LDY	chkY
   1802  3136		       8c 78 10 	      STY	DF0WRITE
   1803  3139		       a9 ff		      lda	#255
   1804  313b		       8d 5a 10 	      sta	CALLFUNCTION
   1805  313e		       ad 08 10 	      LDA	DF0DATA
   1806  3141		       d0 02		      BNE	.skipL045
   1807  3143				   .condpart3
   1808  3143		       e6 d2		      INC	neighbors
   1809  3145				   .skipL045
   1810  3145				   .
   1811  3145							;
   1812  3145
   1813  3145				   .L046		;  chkX  =  x	-  1  :  chkY  =  y  -	1
   1814  3145
   1815  3145		       a5 e8		      LDA	x
   1816  3147		       38		      SEC
   1817  3148		       e9 01		      SBC	#1
   1818  314a		       85 d3		      STA	chkX
   1819  314c		       a5 e9		      LDA	y
   1820  314e		       38		      SEC
   1821  314f		       e9 01		      SBC	#1
   1822  3151		       85 d4		      STA	chkY
   1823  3153				   .L047		;  if pfread ( chkX ,	chkY )	then neighbors	=  neighbors  +  1
   1824  3153
   1825  3153		       a9 a4		      lda	#<C_function
   1826  3155		       8d 50 10 	      sta	DF0LOW
   1827  3158		       a9 01		      lda	#(>C_function) & $0F
   1828  315a		       8d 68 10 	      sta	DF0HI
   1829  315d		       a9 18		      lda	#24
   1830  315f		       8d 78 10 	      sta	DF0WRITE
   1831  3162		       a5 d3		      LDA	chkX
   1832  3164		       8d 78 10 	      STA	DF0WRITE
   1833  3167		       a4 d4		      LDY	chkY
   1834  3169		       8c 78 10 	      STY	DF0WRITE
   1835  316c		       a9 ff		      lda	#255
   1836  316e		       8d 5a 10 	      sta	CALLFUNCTION
   1837  3171		       ad 08 10 	      LDA	DF0DATA
   1838  3174		       d0 02		      BNE	.skipL047
   1839  3176				   .condpart4
   1840  3176		       e6 d2		      INC	neighbors
   1841  3178				   .skipL047
   1842  3178				   .L048		;  chkX  =  x	-  1  :  chkY  =  y  +	1
   1843  3178
   1844  3178		       a5 e8		      LDA	x
   1845  317a		       38		      SEC
   1846  317b		       e9 01		      SBC	#1
   1847  317d		       85 d3		      STA	chkX
   1848  317f		       a5 e9		      LDA	y
   1849  3181		       18		      CLC
   1850  3182		       69 01		      ADC	#1
   1851  3184		       85 d4		      STA	chkY
   1852  3186				   .L049		;  if pfread ( chkX ,	chkY )	then neighbors	=  neighbors  +  1
   1853  3186
   1854  3186		       a9 a4		      lda	#<C_function
   1855  3188		       8d 50 10 	      sta	DF0LOW
   1856  318b		       a9 01		      lda	#(>C_function) & $0F
   1857  318d		       8d 68 10 	      sta	DF0HI
   1858  3190		       a9 18		      lda	#24
   1859  3192		       8d 78 10 	      sta	DF0WRITE
   1860  3195		       a5 d3		      LDA	chkX
   1861  3197		       8d 78 10 	      STA	DF0WRITE
   1862  319a		       a4 d4		      LDY	chkY
   1863  319c		       8c 78 10 	      STY	DF0WRITE
   1864  319f		       a9 ff		      lda	#255
   1865  31a1		       8d 5a 10 	      sta	CALLFUNCTION
   1866  31a4		       ad 08 10 	      LDA	DF0DATA
   1867  31a7		       d0 02		      BNE	.skipL049
   1868  31a9				   .condpart5
   1869  31a9		       e6 d2		      INC	neighbors
   1870  31ab				   .skipL049
   1871  31ab				   .L050		;  chkX  =  x	+  1  :  chkY  =  y  -	1
   1872  31ab
   1873  31ab		       a5 e8		      LDA	x
   1874  31ad		       18		      CLC
   1875  31ae		       69 01		      ADC	#1
   1876  31b0		       85 d3		      STA	chkX
   1877  31b2		       a5 e9		      LDA	y
   1878  31b4		       38		      SEC
   1879  31b5		       e9 01		      SBC	#1
   1880  31b7		       85 d4		      STA	chkY
   1881  31b9				   .L051		;  if pfread ( chkX ,	chkY )	then neighbors	=  neighbors  +  1
   1882  31b9
   1883  31b9		       a9 a4		      lda	#<C_function
   1884  31bb		       8d 50 10 	      sta	DF0LOW
   1885  31be		       a9 01		      lda	#(>C_function) & $0F
   1886  31c0		       8d 68 10 	      sta	DF0HI
   1887  31c3		       a9 18		      lda	#24
   1888  31c5		       8d 78 10 	      sta	DF0WRITE
   1889  31c8		       a5 d3		      LDA	chkX
   1890  31ca		       8d 78 10 	      STA	DF0WRITE
   1891  31cd		       a4 d4		      LDY	chkY
   1892  31cf		       8c 78 10 	      STY	DF0WRITE
   1893  31d2		       a9 ff		      lda	#255
   1894  31d4		       8d 5a 10 	      sta	CALLFUNCTION
   1895  31d7		       ad 08 10 	      LDA	DF0DATA
   1896  31da		       d0 02		      BNE	.skipL051
   1897  31dc				   .condpart6
   1898  31dc		       e6 d2		      INC	neighbors
   1899  31de				   .skipL051
   1900  31de				   .L052		;  chkX  =  x	+  1  :  chkY  =  y  +	1
   1901  31de
   1902  31de		       a5 e8		      LDA	x
   1903  31e0		       18		      CLC
   1904  31e1		       69 01		      ADC	#1
   1905  31e3		       85 d3		      STA	chkX
   1906  31e5		       a5 e9		      LDA	y
   1907  31e7		       18		      CLC
   1908  31e8		       69 01		      ADC	#1
   1909  31ea		       85 d4		      STA	chkY
   1910  31ec				   .L053		;  if pfread ( chkX ,	chkY )	then neighbors	=  neighbors  +  1
   1911  31ec
   1912  31ec		       a9 a4		      lda	#<C_function
   1913  31ee		       8d 50 10 	      sta	DF0LOW
   1914  31f1		       a9 01		      lda	#(>C_function) & $0F
   1915  31f3		       8d 68 10 	      sta	DF0HI
   1916  31f6		       a9 18		      lda	#24
   1917  31f8		       8d 78 10 	      sta	DF0WRITE
   1918  31fb		       a5 d3		      LDA	chkX
   1919  31fd		       8d 78 10 	      STA	DF0WRITE
   1920  3200		       a4 d4		      LDY	chkY
   1921  3202		       8c 78 10 	      STY	DF0WRITE
   1922  3205		       a9 ff		      lda	#255
   1923  3207		       8d 5a 10 	      sta	CALLFUNCTION
   1924  320a		       ad 08 10 	      LDA	DF0DATA
   1925  320d		       d0 02		      BNE	.skipL053
   1926  320f				   .condpart7
   1927  320f		       e6 d2		      INC	neighbors
   1928  3211				   .skipL053
   1929  3211				   .
   1930  3211							;
   1931  3211
   1932  3211				   .
   1933  3211							;
   1934  3211
   1935  3211				   .L054		;  flipNeeded	=  0
   1936  3211
   1937  3211		       a5 ea		      LDA	z
   1938  3213		       29 fe		      AND	#254
   1939  3215		       85 ea		      STA	z
   1940  3217				   .L055		;  if !pfread ( x , y )  then goto __deadCellChecks
   1941  3217
   1942  3217		       a9 a4		      lda	#<C_function
   1943  3219		       8d 50 10 	      sta	DF0LOW
   1944  321c		       a9 01		      lda	#(>C_function) & $0F
   1945  321e		       8d 68 10 	      sta	DF0HI
   1946  3221		       a9 18		      lda	#24
   1947  3223		       8d 78 10 	      sta	DF0WRITE
   1948  3226		       a5 e8		      LDA	x
   1949  3228		       8d 78 10 	      STA	DF0WRITE
   1950  322b		       a4 e9		      LDY	y
   1951  322d		       8c 78 10 	      STY	DF0WRITE
   1952  3230		       a9 ff		      lda	#255
   1953  3232		       8d 5a 10 	      sta	CALLFUNCTION
   1954  3235		       ad 08 10 	      LDA	DF0DATA
   1955  3238		       f0 03		      BEQ	.skipL055
   1956  323a				   .condpart8
   1957  323a		       4c 58 52 	      jmp	.__deadCellChecks
   1958  323d
   1959  323d				   .skipL055
   1960  323d				   .
   1961  323d							;
   1962  323d
   1963  323d				   .__livingCellChecks
   1964  323d							; __livingCellChecks
   1965  323d
   1966  323d				   .L056		;  if neighbors  <  2 then flipNeeded	=  1
   1967  323d
   1968  323d		       a5 d2		      LDA	neighbors
   1969  323f		       c9 02		      CMP	#2
   1970  3241		       b0 06		      BCS	.skipL056
   1971  3243				   .condpart9
   1972  3243		       a5 ea		      LDA	z
   1973  3245		       09 01		      ORA	#1
   1974  3247		       85 ea		      STA	z
   1975  3249				   .skipL056
   1976  3249				   .L057		;  if neighbors  >  3 then flipNeeded	=  1
   1977  3249
   1978  3249		       a9 03		      LDA	#3
   1979  324b		       c5 d2		      CMP	neighbors
   1980  324d		       b0 06		      BCS	.skipL057
   1981  324f				   .condpart10
   1982  324f		       a5 ea		      LDA	z
   1983  3251		       09 01		      ORA	#1
   1984  3253		       85 ea		      STA	z
   1985  3255				   .skipL057
   1986  3255				   .L058		;  goto __doneChecking
   1987  3255
   1988  3255		       4c 64 52 	      jmp	.__doneChecking
   1989  3258
   1990  3258				   .__deadCellChecks
   1991  3258							; __deadCellChecks
   1992  3258
   1993  3258				   .L059		;  if neighbors  =  3 then flipNeeded	=  1
   1994  3258
   1995  3258		       a5 d2		      LDA	neighbors
   1996  325a		       c9 03		      CMP	#3
   1997  325c		       d0 06		      BNE	.skipL059
   1998  325e				   .condpart11
   1999  325e		       a5 ea		      LDA	z
   2000  3260		       09 01		      ORA	#1
   2001  3262		       85 ea		      STA	z
   2002  3264				   .skipL059
   2003  3264				   .__doneChecking
   2004  3264							; __doneChecking
   2005  3264
   2006  3264				   .
   2007  3264							;
   2008  3264
   2009  3264				   .
   2010  3264							;
   2011  3264
   2012  3264				   .L060		;  if !flipNeeded goto __doneStackPush
   2013  3264
   2014  3264		       a5 ea		      LDA	z
   2015  3266		       4a		      LSR
   2016  3267					      if	((* - .__doneStackPush) < 127) && ((* - .__doneStackPush) > -128)
   2017  3267		       90 0c		      bcc	.__doneStackPush
   2018  3269				  -	      else
   2019  3269				  -	      bcs	.0skip__doneStackPush
   2020  3269				  -	      jmp	.__doneStackPush
   2021  3269				  -.0skip__doneStackPush
   2022  3269					      endif
   2023  3269				   .
   2024  3269							;
   2025  3269
   2026  3269				   .
   2027  3269							;
   2028  3269
   2029  3269				   .L061		;  push x y
   2030  3269
   2031  3269		       a5 e8		      lda	x
   2032  326b		       8d 67 10 	      sta	DF7PUSH
   2033  326e		       a5 e9		      lda	y
   2034  3270		       8d 67 10 	      sta	DF7PUSH
   2035  3273				   .L062		;  stackCounter  =  stackCounter  +  1
   2036  3273
   2037  3273		       e6 d1		      INC	stackCounter
   2038  3275				   .__doneStackPush
   2039  3275							; __doneStackPush
   2040  3275
   2041  3275				   .
   2042  3275							;
   2043  3275
   2044  3275				   .L063		;  gosub DrawUpdate
   2045  3275
   2046  3275		       20 e5 52 	      jsr	.DrawUpdate
   2047  3278
   2048  3278				   .L064		;  next
   2049  3278
   2050  3278		       a5 e8		      LDA	x
   2051  327a		       c9 1e		      CMP	#30
   2052  327c
   2053  327c		       e6 e8		      INC	x
   2054  327e				  -	      if	((* - .L036forx) < 127) && ((* - .L036forx) > -128)
   2055  327e				  -	      bcc	.L036forx
   2056  327e					      else
   2057  327e		       b0 03		      bcs	.1skipL036forx
   2058  3280		       4c 91 50 	      jmp	.L036forx
   2059  3283				   .1skipL036forx
   2060  3283					      endif
   2061  3283				   .L065		;  next
   2062  3283
   2063  3283		       a5 e9		      LDA	y
   2064  3285		       c9 14		      CMP	#20
   2065  3287
   2066  3287		       e6 e9		      INC	y
   2067  3289				  -	      if	((* - .L035fory) < 127) && ((* - .L035fory) > -128)
   2068  3289				  -	      bcc	.L035fory
   2069  3289					      else
   2070  3289		       b0 03		      bcs	.2skipL035fory
   2071  328b		       4c 8d 50 	      jmp	.L035fory
   2072  328e				   .2skipL035fory
   2073  328e					      endif
   2074  328e				   .
   2075  328e							;
   2076  328e
   2077  328e				   .
   2078  328e							;
   2079  328e
   2080  328e				   .L066		;  for tmp  =	stackCounter to 1 step -1
   2081  328e
   2082  328e		       a5 d1		      LDA	stackCounter
   2083  3290		       85 d5		      STA	tmp
   2084  3292				   .L066fortmp
   2085  3292				   .L067		;  pull x y
   2086  3292
   2087  3292		       ad 0f 10 	      lda	DF7DATA
   2088  3295		       85 e9		      sta	y
   2089  3297		       ad 0f 10 	      lda	DF7DATA
   2090  329a		       85 e8		      sta	x
   2091  329c				   .L068		;  pfpixel x y flip
   2092  329c
   2093  329c		       a9 a4		      lda	#<C_function
   2094  329e		       8d 50 10 	      sta	DF0LOW
   2095  32a1		       a9 01		      lda	#(>C_function) & $0F
   2096  32a3		       8d 68 10 	      sta	DF0HI
   2097  32a6		       a2 0e		      LDX	#14
   2098  32a8		       8e 78 10 	      STX	DF0WRITE
   2099  32ab		       8e 78 10 	      STX	DF0WRITE
   2100  32ae		       a4 e9		      LDY	y
   2101  32b0		       8c 78 10 	      STY	DF0WRITE
   2102  32b3		       a5 e8		      LDA	x
   2103  32b5		       8d 78 10 	      STA	DF0WRITE
   2104  32b8		       a9 ff		      lda	#255
   2105  32ba		       8d 5a 10 	      sta	CALLFUNCTION
   2106  32bd				   .
   2107  32bd							;
   2108  32bd
   2109  32bd				   .L069		;  gosub DrawUpdate
   2110  32bd
   2111  32bd		       20 e5 52 	      jsr	.DrawUpdate
   2112  32c0
   2113  32c0				   .L070		;  next
   2114  32c0
   2115  32c0		       a5 d5		      LDA	tmp
   2116  32c2		       18		      CLC
   2117  32c3		       69 ff		      ADC	#-1
   2118  32c5
   2119  32c5					      if	((* - .L066fortmp_failsafe) < 127) && ((* - .L066fortmp_failsafe) > -128)
   2120  32c5		       90 06		      bcc	.L066fortmp_failsafe
   2121  32c7				  -	      else
   2122  32c7				  -	      bcs	.3skipL066fortmp_failsafe
   2123  32c7				  -	      jmp	.L066fortmp_failsafe
   2124  32c7				  -.3skipL066fortmp_failsafe
   2125  32c7					      endif
   2126  32c7		       85 d5		      STA	tmp
   2127  32c9		       c9 01		      CMP	#1
   2128  32cb					      if	((* - .L066fortmp) < 127) && ((* - .L066fortmp) > -128)
   2129  32cb		       b0 c5		      bcs	.L066fortmp
   2130  32cd				  -	      else
   2131  32cd				  -	      bcc	.4skipL066fortmp
   2132  32cd				  -	      jmp	.L066fortmp
   2133  32cd				  -.4skipL066fortmp
   2134  32cd					      endif
   2135  32cd				   .L066fortmp_failsafe
   2136  32cd				   .
   2137  32cd							;
   2138  32cd
   2139  32cd				   .
   2140  32cd							;
   2141  32cd
   2142  32cd				   .L071		;  score  =  score  +	1
   2143  32cd
   2144  32cd		       f8		      SED
   2145  32ce		       18		      CLC
   2146  32cf		       a5 ba		      LDA	score+2
   2147  32d1		       69 01		      ADC	#$01
   2148  32d3		       85 ba		      STA	score+2
   2149  32d5		       a5 b9		      LDA	score+1
   2150  32d7		       69 00		      ADC	#$00
   2151  32d9		       85 b9		      STA	score+1
   2152  32db		       a5 b8		      LDA	score
   2153  32dd		       69 00		      ADC	#$00
   2154  32df		       85 b8		      STA	score
   2155  32e1		       d8		      CLD
   2156  32e2				   .L072		;  goto MainLoop
   2157  32e2
   2158  32e2		       4c 85 50 	      jmp	.MainLoop
   2159  32e5
   2160  32e5				   .
   2161  32e5							;
   2162  32e5
   2163  32e5				   .
   2164  32e5							;
   2165  32e5
   2166  32e5				   .
   2167  32e5							;
   2168  32e5
   2169  32e5				   .
   2170  32e5							;
   2171  32e5
   2172  32e5				   .
   2173  32e5							;
   2174  32e5
   2175  32e5				   .
   2176  32e5							;
   2177  32e5
   2178  32e5				   .
   2179  32e5							;
   2180  32e5
   2181  32e5				   .
   2182  32e5							;
   2183  32e5
   2184  32e5				   .
   2185  32e5							;
   2186  32e5
   2187  32e5				   .DrawUpdate
   2188  32e5							; DrawUpdate
   2189  32e5
   2190  32e5				   .
   2191  32e5							;
   2192  32e5
   2193  32e5				   .L073		;  if !switchreset  &&  resetFlag then resetFlag  =  0
   2194  32e5
   2195  32e5		       a9 01		      lda	#1
   2196  32e7		       2c 82 02 	      bit	SWCHB
   2197  32ea		       f0 0c		      BEQ	.skipL073
   2198  32ec				   .condpart12
   2199  32ec		       a5 ea		      LDA	z
   2200  32ee		       29 02		      AND	#2
   2201  32f0		       f0 06		      BEQ	.skip12then
   2202  32f2				   .condpart13
   2203  32f2		       a5 ea		      LDA	z
   2204  32f4		       29 fd		      AND	#253
   2205  32f6		       85 ea		      STA	z
   2206  32f8				   .skip12then
   2207  32f8				   .skipL073
   2208  32f8				   .L074		;  if switchreset  &&	!resetFlag then goto ChangeGameAndReset bank4
   2209  32f8
   2210  32f8		       a9 01		      lda	#1
   2211  32fa		       2c 82 02 	      bit	SWCHB
   2212  32fd		       d0 18		      BNE	.skipL074
   2213  32ff				   .condpart14
   2214  32ff		       a5 ea		      LDA	z
   2215  3301		       29 02		      AND	#2
   2216  3303		       d0 12		      BNE	.skip14then
   2217  3305				   .condpart15
   2218  3305		       85 81		      sta	temp7
   2219  3307		       a9 71		      lda	#>(.ChangeGameAndReset-1)
   2220  3309		       48		      pha
   2221  330a		       a9 bd		      lda	#<(.ChangeGameAndReset-1)
   2222  330c		       48		      pha
   2223  330d		       a5 81		      lda	temp7
   2224  330f		       48		      pha
   2225  3310		       8a		      txa
   2226  3311		       48		      pha
   2227  3312		       a2 04		      ldx	#4
   2228  3314		       4c ee df 	      jmp	BS_jsr
   2229  3317				   .skip14then
   2230  3317				   .skipL074
   2231  3317				   .
   2232  3317							;
   2233  3317
   2234  3317				   .
   2235  3317							;
   2236  3317
   2237  3317				   .L075		;  if drawCounter  <  REDRAW_FRAME then drawCounter  =  drawCounter  +  1 else drawCounter  =	0
   2238  3317
   2239  3317		       a5 d6		      LDA	drawCounter
   2240  3319		       c9 04		      CMP	#4
   2241  331b		       b0 05		      BCS	.skipL075
   2242  331d				   .condpart16
   2243  331d		       e6 d6		      INC	drawCounter
   2244  331f		       4c 26 53 	      jmp	.skipelse0
   2245  3322				   .skipL075
   2246  3322		       a9 00		      LDA	#0
   2247  3324		       85 d6		      STA	drawCounter
   2248  3326				   .skipelse0
   2249  3326				   .L076		;  if drawCounter  <>	0 then return
   2250  3326
   2251  3326		       a5 d6		      LDA	drawCounter
   2252  3328		       c9 00		      CMP	#0
   2253  332a		       f0 0d		      BEQ	.skipL076
   2254  332c				   .condpart17
   2255  332c		       ba		      tsx
   2256  332d		       b5 02		      lda	2,x	; check return address
   2257  332f		       49 53		      eor	#(>*)	; vs. current PCH
   2258  3331		       29 e0		      and	#$E0	;  mask off all but top 3 bits
   2259  3333		       f0 03		      beq	*+5	; if equal, do normal return
   2260  3335		       4c e0 df 	      JMP	BS_return
   2261  3338		       60		      RTS
   2262  3339				   .skipL076
   2263  3339				   .
   2264  3339							;
   2265  3339
   2266  3339				   .
   2267  3339							;
   2268  3339
   2269  3339				   .L077		;  pfcolors:
   2270  3339
   2271  3339		       a9 08		      LDA	#<PFCOLS
   2272  333b		       8d 50 10 	      STA	DF0LOW
   2273  333e		       a9 0a		      LDA	#(>PFCOLS) & $0F
   2274  3340		       8d 68 10 	      STA	DF0HI
   2275  3343		       a9 a8		      LDA	#<playfieldcolorL077
   2276  3345		       8d 59 10 	      STA	PARAMETER
   2277  3348		       a9 61		      LDA	#((>playfieldcolorL077) & $0f) | (((>playfieldcolorL077) / 2) & $70)
   2278  334a		       8d 59 10 	      STA	PARAMETER
   2279  334d		       a9 00		      LDA	#0
   2280  334f		       8d 59 10 	      STA	PARAMETER
   2281  3352		       a9 01		      LDA	#1
   2282  3354		       8d 59 10 	      STA	PARAMETER
   2283  3357		       a9 01		      LDA	#1
   2284  3359		       8d 5a 10 	      STA	CALLFUNCTION
   2285  335c				   .L078		;  bkcolors:
   2286  335c
   2287  335c		       a9 a5		      LDA	#<BKCOLS
   2288  335e		       8d 50 10 	      STA	DF0LOW
   2289  3361		       a9 0b		      LDA	#(>BKCOLS) & $0F
   2290  3363		       8d 68 10 	      STA	DF0HI
   2291  3366		       a9 a9		      LDA	#<backgroundcolorL078
   2292  3368		       8d 59 10 	      STA	PARAMETER
   2293  336b		       a9 61		      LDA	#((>backgroundcolorL078) & $0f) | (((>backgroundcolorL078) / 2) & $70)
   2294  336d		       8d 59 10 	      STA	PARAMETER
   2295  3370		       a9 00		      LDA	#0
   2296  3372		       8d 59 10 	      STA	PARAMETER
   2297  3375		       a9 01		      LDA	#1
   2298  3377		       8d 59 10 	      STA	PARAMETER
   2299  337a		       a9 01		      LDA	#1
   2300  337c		       8d 5a 10 	      STA	CALLFUNCTION
   2301  337f				   .
   2302  337f							;
   2303  337f
   2304  337f				   .L079		;  DF6FRACINC	=  1  :  DF4FRACINC  =	1
   2305  337f
   2306  337f		       a9 01		      LDA	#1
   2307  3381		       8d 3e 10 	      STA	DF6FRACINC
   2308  3384		       8d 3c 10 	      STA	DF4FRACINC
   2309  3387				   .L080		;  DF0FRACINC	=  RES	:  DF1FRACINC  =  RES
   2310  3387
   2311  3387		       a9 20		      LDA	#32
   2312  3389		       8d 38 10 	      STA	DF0FRACINC
   2313  338c		       8d 39 10 	      STA	DF1FRACINC
   2314  338f				   .L081		;  DF2FRACINC	=  RES	:  DF3FRACINC  =  RES
   2315  338f
   2316  338f		       a9 20		      LDA	#32
   2317  3391		       8d 3a 10 	      STA	DF2FRACINC
   2318  3394		       8d 3b 10 	      STA	DF3FRACINC
   2319  3397				   .
   2320  3397							;
   2321  3397
   2322  3397				   .L082		;  drawscreen
   2323  3397
   2324  3397		       85 81		      sta	temp7
   2325  3399		       a9 53		      lda	#>(ret_point3-1)
   2326  339b		       48		      pha
   2327  339c		       a9 ae		      lda	#<(ret_point3-1)
   2328  339e		       48		      pha
   2329  339f		       a9 19		      lda	#>(drawscreen-1)
   2330  33a1		       48		      pha
   2331  33a2		       a9 50		      lda	#<(drawscreen-1)
   2332  33a4		       48		      pha
   2333  33a5		       a5 81		      lda	temp7
   2334  33a7		       48		      pha
   2335  33a8		       8a		      txa
   2336  33a9		       48		      pha
   2337  33aa		       a2 01		      ldx	#1
   2338  33ac		       4c ee df 	      jmp	BS_jsr
   2339  33af				   ret_point3
   2340  33af				   .L083		;  return
   2341  33af
   2342  33af		       ba		      tsx
   2343  33b0		       b5 02		      lda	2,x	; check return address
   2344  33b2		       49 53		      eor	#(>*)	; vs. current PCH
   2345  33b4		       29 e0		      and	#$E0	;  mask off all but top 3 bits
   2346  33b6		       f0 03		      beq	*+5	; if equal, do normal return
   2347  33b8		       4c e0 df 	      JMP	BS_return
   2348  33bb		       60		      RTS
   2349  33bc				   .
   2350  33bc							;
   2351  33bc
   2352  33bc				   .
   2353  33bc							;
   2354  33bc
   2355  33bc				   .
   2356  33bc							;
   2357  33bc
   2358  33bc				   .
   2359  33bc							;
   2360  33bc
   2361  33bc				   .L084		;  bank 4
   2362  33bc
   2363  33bc					      if	ECHO3
      3096 bytes of ROM space left in bank 3
   2364  33bc					      echo	"    ",[(start_bank3 - *)]d , "bytes of ROM space left in bank 3")
   2365  33bc					      endif
   2366  33bc		       00 01	   ECHO3      =	1
   2367  3fd4					      ORG	$3FF4-bscode_length
   2368  3fd4					      RORG	$5FF4-bscode_length
   2369  3fd4		       a2 ff	   start_bank3 ldx	#$ff
   2370  3fd6					      ifconst	FASTFETCH	; using DPC+
   2371  3fd6		       8e 58 10 	      stx	FASTFETCH
   2372  3fd9					      endif
   2373  3fd9		       9a		      txs
   2374  3fda				  -	      if	bankswitch == 64
   2375  3fda				  -	      lda	#(((>(start-1)) & $0F) | $F0)
   2376  3fda					      else
   2377  3fda		       a9 18		      lda	#>(start-1)
   2378  3fdc					      endif
   2379  3fdc		       48		      pha
   2380  3fdd		       a9 eb		      lda	#<(start-1)
   2381  3fdf		       48		      pha
   2382  3fe0		       48		      pha
   2383  3fe1		       8a		      txa
   2384  3fe2		       48		      pha
   2385  3fe3		       ba		      tsx
   2386  3fe4					      if	bankswitch != 64
   2387  3fe4		       b5 04		      lda	4,x	; get high byte of return address
   2388  3fe6		       2a		      rol
   2389  3fe7		       2a		      rol
   2390  3fe8		       2a		      rol
   2391  3fe9		       2a		      rol
   2392  3fea		       29 07		      and	#bs_mask	;1 3 or 7 for F8/F6/F4
   2393  3fec		       aa		      tax
   2394  3fed		       e8		      inx
   2395  3fee				  -	      else
   2396  3fee				  -	      lda	4,x	; get high byte of return address
   2397  3fee				  -	      tay
   2398  3fee				  -	      ora	#$10	; change our bank nibble into a valid rom mirror
   2399  3fee				  -	      sta	4,x
   2400  3fee				  -	      tya
   2401  3fee				  -	      lsr
   2402  3fee				  -	      lsr
   2403  3fee				  -	      lsr
   2404  3fee				  -	      lsr
   2405  3fee				  -	      tax
   2406  3fee				  -	      inx
   2407  3fee					      endif
   2408  3fee		       bd f5 1f 	      lda	bankswitch_hotspot-1,x
   2409  3ff1		       68		      pla
   2410  3ff2		       aa		      tax
   2411  3ff3		       68		      pla
   2412  3ff4		       60		      rts
   2413  3ff5				  -	      if	((* & $1FFF) > ((bankswitch_hotspot & $1FFF) - 1))
   2414  3ff5				  -	      echo	"WARNING: size parameter in banksw.asm too small - the program probably will not work."
   2415  3ff5				  -	      echo	"Change to",[(*-begin_bscode+1)&$FF]d,"and try again."
   2416  3ff5					      endif
   2417  3ffc					      ORG	$3FFC
   2418  3ffc					      RORG	$5FFC
   2419  3ffc		       d4 5f		      .word.w	start_bank3
   2420  3ffe		       d4 5f		      .word.w	start_bank3
   2421  4000					      ORG	$4000
   2422  4000					      RORG	$7000
   2423  4000					      repeat	129
   2424  4000		       00		      .byte.b	0
   2423  4000					      repend
   2424  4001		       00		      .byte.b	0
   2423  4001					      repend
   2424  4002		       00		      .byte.b	0
   2423  4002					      repend
   2424  4003		       00		      .byte.b	0
   2423  4003					      repend
   2424  4004		       00		      .byte.b	0
   2423  4004					      repend
   2424  4005		       00		      .byte.b	0
   2423  4005					      repend
   2424  4006		       00		      .byte.b	0
   2423  4006					      repend
   2424  4007		       00		      .byte.b	0
   2423  4007					      repend
   2424  4008		       00		      .byte.b	0
   2423  4008					      repend
   2424  4009		       00		      .byte.b	0
   2423  4009					      repend
   2424  400a		       00		      .byte.b	0
   2423  400a					      repend
   2424  400b		       00		      .byte.b	0
   2423  400b					      repend
   2424  400c		       00		      .byte.b	0
   2423  400c					      repend
   2424  400d		       00		      .byte.b	0
   2423  400d					      repend
   2424  400e		       00		      .byte.b	0
   2423  400e					      repend
   2424  400f		       00		      .byte.b	0
   2423  400f					      repend
   2424  4010		       00		      .byte.b	0
   2423  4010					      repend
   2424  4011		       00		      .byte.b	0
   2423  4011					      repend
   2424  4012		       00		      .byte.b	0
   2423  4012					      repend
   2424  4013		       00		      .byte.b	0
   2423  4013					      repend
   2424  4014		       00		      .byte.b	0
   2423  4014					      repend
   2424  4015		       00		      .byte.b	0
   2423  4015					      repend
   2424  4016		       00		      .byte.b	0
   2423  4016					      repend
   2424  4017		       00		      .byte.b	0
   2423  4017					      repend
   2424  4018		       00		      .byte.b	0
   2423  4018					      repend
   2424  4019		       00		      .byte.b	0
   2423  4019					      repend
   2424  401a		       00		      .byte.b	0
   2423  401a					      repend
   2424  401b		       00		      .byte.b	0
   2423  401b					      repend
   2424  401c		       00		      .byte.b	0
   2423  401c					      repend
   2424  401d		       00		      .byte.b	0
   2423  401d					      repend
   2424  401e		       00		      .byte.b	0
   2423  401e					      repend
   2424  401f		       00		      .byte.b	0
   2423  401f					      repend
   2424  4020		       00		      .byte.b	0
   2423  4020					      repend
   2424  4021		       00		      .byte.b	0
   2423  4021					      repend
   2424  4022		       00		      .byte.b	0
   2423  4022					      repend
   2424  4023		       00		      .byte.b	0
   2423  4023					      repend
   2424  4024		       00		      .byte.b	0
   2423  4024					      repend
   2424  4025		       00		      .byte.b	0
   2423  4025					      repend
   2424  4026		       00		      .byte.b	0
   2423  4026					      repend
   2424  4027		       00		      .byte.b	0
   2423  4027					      repend
   2424  4028		       00		      .byte.b	0
   2423  4028					      repend
   2424  4029		       00		      .byte.b	0
   2423  4029					      repend
   2424  402a		       00		      .byte.b	0
   2423  402a					      repend
   2424  402b		       00		      .byte.b	0
   2423  402b					      repend
   2424  402c		       00		      .byte.b	0
   2423  402c					      repend
   2424  402d		       00		      .byte.b	0
   2423  402d					      repend
   2424  402e		       00		      .byte.b	0
   2423  402e					      repend
   2424  402f		       00		      .byte.b	0
   2423  402f					      repend
   2424  4030		       00		      .byte.b	0
   2423  4030					      repend
   2424  4031		       00		      .byte.b	0
   2423  4031					      repend
   2424  4032		       00		      .byte.b	0
   2423  4032					      repend
   2424  4033		       00		      .byte.b	0
   2423  4033					      repend
   2424  4034		       00		      .byte.b	0
   2423  4034					      repend
   2424  4035		       00		      .byte.b	0
   2423  4035					      repend
   2424  4036		       00		      .byte.b	0
   2423  4036					      repend
   2424  4037		       00		      .byte.b	0
   2423  4037					      repend
   2424  4038		       00		      .byte.b	0
   2423  4038					      repend
   2424  4039		       00		      .byte.b	0
   2423  4039					      repend
   2424  403a		       00		      .byte.b	0
   2423  403a					      repend
   2424  403b		       00		      .byte.b	0
   2423  403b					      repend
   2424  403c		       00		      .byte.b	0
   2423  403c					      repend
   2424  403d		       00		      .byte.b	0
   2423  403d					      repend
   2424  403e		       00		      .byte.b	0
   2423  403e					      repend
   2424  403f		       00		      .byte.b	0
   2423  403f					      repend
   2424  4040		       00		      .byte.b	0
   2423  4040					      repend
   2424  4041		       00		      .byte.b	0
   2423  4041					      repend
   2424  4042		       00		      .byte.b	0
   2423  4042					      repend
   2424  4043		       00		      .byte.b	0
   2423  4043					      repend
   2424  4044		       00		      .byte.b	0
   2423  4044					      repend
   2424  4045		       00		      .byte.b	0
   2423  4045					      repend
   2424  4046		       00		      .byte.b	0
   2423  4046					      repend
   2424  4047		       00		      .byte.b	0
   2423  4047					      repend
   2424  4048		       00		      .byte.b	0
   2423  4048					      repend
   2424  4049		       00		      .byte.b	0
   2423  4049					      repend
   2424  404a		       00		      .byte.b	0
   2423  404a					      repend
   2424  404b		       00		      .byte.b	0
   2423  404b					      repend
   2424  404c		       00		      .byte.b	0
   2423  404c					      repend
   2424  404d		       00		      .byte.b	0
   2423  404d					      repend
   2424  404e		       00		      .byte.b	0
   2423  404e					      repend
   2424  404f		       00		      .byte.b	0
   2423  404f					      repend
   2424  4050		       00		      .byte.b	0
   2423  4050					      repend
   2424  4051		       00		      .byte.b	0
   2423  4051					      repend
   2424  4052		       00		      .byte.b	0
   2423  4052					      repend
   2424  4053		       00		      .byte.b	0
   2423  4053					      repend
   2424  4054		       00		      .byte.b	0
   2423  4054					      repend
   2424  4055		       00		      .byte.b	0
   2423  4055					      repend
   2424  4056		       00		      .byte.b	0
   2423  4056					      repend
   2424  4057		       00		      .byte.b	0
   2423  4057					      repend
   2424  4058		       00		      .byte.b	0
   2423  4058					      repend
   2424  4059		       00		      .byte.b	0
   2423  4059					      repend
   2424  405a		       00		      .byte.b	0
   2423  405a					      repend
   2424  405b		       00		      .byte.b	0
   2423  405b					      repend
   2424  405c		       00		      .byte.b	0
   2423  405c					      repend
   2424  405d		       00		      .byte.b	0
   2423  405d					      repend
   2424  405e		       00		      .byte.b	0
   2423  405e					      repend
   2424  405f		       00		      .byte.b	0
   2423  405f					      repend
   2424  4060		       00		      .byte.b	0
   2423  4060					      repend
   2424  4061		       00		      .byte.b	0
   2423  4061					      repend
   2424  4062		       00		      .byte.b	0
   2423  4062					      repend
   2424  4063		       00		      .byte.b	0
   2423  4063					      repend
   2424  4064		       00		      .byte.b	0
   2423  4064					      repend
   2424  4065		       00		      .byte.b	0
   2423  4065					      repend
   2424  4066		       00		      .byte.b	0
   2423  4066					      repend
   2424  4067		       00		      .byte.b	0
   2423  4067					      repend
   2424  4068		       00		      .byte.b	0
   2423  4068					      repend
   2424  4069		       00		      .byte.b	0
   2423  4069					      repend
   2424  406a		       00		      .byte.b	0
   2423  406a					      repend
   2424  406b		       00		      .byte.b	0
   2423  406b					      repend
   2424  406c		       00		      .byte.b	0
   2423  406c					      repend
   2424  406d		       00		      .byte.b	0
   2423  406d					      repend
   2424  406e		       00		      .byte.b	0
   2423  406e					      repend
   2424  406f		       00		      .byte.b	0
   2423  406f					      repend
   2424  4070		       00		      .byte.b	0
   2423  4070					      repend
   2424  4071		       00		      .byte.b	0
   2423  4071					      repend
   2424  4072		       00		      .byte.b	0
   2423  4072					      repend
   2424  4073		       00		      .byte.b	0
   2423  4073					      repend
   2424  4074		       00		      .byte.b	0
   2423  4074					      repend
   2424  4075		       00		      .byte.b	0
   2423  4075					      repend
   2424  4076		       00		      .byte.b	0
   2423  4076					      repend
   2424  4077		       00		      .byte.b	0
   2423  4077					      repend
   2424  4078		       00		      .byte.b	0
   2423  4078					      repend
   2424  4079		       00		      .byte.b	0
   2423  4079					      repend
   2424  407a		       00		      .byte.b	0
   2423  407a					      repend
   2424  407b		       00		      .byte.b	0
   2423  407b					      repend
   2424  407c		       00		      .byte.b	0
   2423  407c					      repend
   2424  407d		       00		      .byte.b	0
   2423  407d					      repend
   2424  407e		       00		      .byte.b	0
   2423  407e					      repend
   2424  407f		       00		      .byte.b	0
   2423  407f					      repend
   2424  4080		       00		      .byte.b	0
   2425  4081					      repend
   2426  4081				   .L085		;  temp1 = temp1
   2427  4081
   2428  4081		       a5 cb		      LDA	temp1
   2429  4083		       85 cb		      STA	temp1
   2430  4085				   .
   2431  4085							;
   2432  4085
   2433  4085				   .
   2434  4085							;
   2435  4085
   2436  4085				   .
   2437  4085							;
   2438  4085
   2439  4085				   .
   2440  4085							;
   2441  4085
   2442  4085				   .
   2443  4085							;
   2444  4085
   2445  4085				   .SelectSeed
   2446  4085							; SelectSeed
   2447  4085
   2448  4085				   .L086		;  on startingSeed gosub SeedRandom SeedGlider SeedExploders SeedMix SeedShip
   2449  4085
   2450  4085		       a9 70		      lda	#>(ongosub0-1)
   2451  4087		       48		      PHA
   2452  4088		       a9 9f		      lda	#<(ongosub0-1)
   2453  408a		       48		      PHA
   2454  408b		       a6 d7		      LDX	startingSeed
   2455  408d		       bd 96 70 	      LDA	.L086jumptablehi,x
   2456  4090		       48		      PHA
   2457  4091		       bd 9b 70 	      LDA	.L086jumptablelo,x
   2458  4094		       48		      PHA
   2459  4095		       60		      RTS
   2460  4096				   .L086jumptablehi
   2461  4096		       70		      .byte.b	>(.SeedRandom-1)
   2462  4097		       71		      .byte.b	>(.SeedGlider-1)
   2463  4098		       71		      .byte.b	>(.SeedExploders-1)
   2464  4099		       71		      .byte.b	>(.SeedMix-1)
   2465  409a		       71		      .byte.b	>(.SeedShip-1)
   2466  409b				   .L086jumptablelo
   2467  409b		       ac		      .byte.b	<(.SeedRandom-1)
   2468  409c		       11		      .byte.b	<(.SeedGlider-1)
   2469  409d		       3c		      .byte.b	<(.SeedExploders-1)
   2470  409e		       67		      .byte.b	<(.SeedMix-1)
   2471  409f		       92		      .byte.b	<(.SeedShip-1)
   2472  40a0				   ongosub0
   2473  40a0				   .L087		;  return
   2474  40a0
   2475  40a0		       ba		      tsx
   2476  40a1		       b5 02		      lda	2,x	; check return address
   2477  40a3		       49 70		      eor	#(>*)	; vs. current PCH
   2478  40a5		       29 e0		      and	#$E0	;  mask off all but top 3 bits
   2479  40a7		       f0 03		      beq	*+5	; if equal, do normal return
   2480  40a9		       4c e0 df 	      JMP	BS_return
   2481  40ac		       60		      RTS
   2482  40ad				   .
   2483  40ad							;
   2484  40ad
   2485  40ad				   .
   2486  40ad							;
   2487  40ad
   2488  40ad				   .
   2489  40ad							;
   2490  40ad
   2491  40ad				   .
   2492  40ad							;
   2493  40ad
   2494  40ad				   .
   2495  40ad							;
   2496  40ad
   2497  40ad				   .SeedRandom
   2498  40ad							; SeedRandom
   2499  40ad
   2500  40ad				   .L088		;  for y  =  1 to MAXY
   2501  40ad
   2502  40ad		       a9 01		      LDA	#1
   2503  40af		       85 e9		      STA	y
   2504  40b1				   .L088fory
   2505  40b1				   .L089		;  for x  =  1 to MAXX
   2506  40b1
   2507  40b1		       a9 01		      LDA	#1
   2508  40b3		       85 e8		      STA	x
   2509  40b5				   .L089forx
   2510  40b5				   .L090		;  if rand  <	FILLVALUE then pfpixel x y on
   2511  40b5
   2512  40b5		       ad 00 10 	      LDA	rand
   2513  40b8		       c9 32		      CMP	#50
   2514  40ba		       b0 21		      BCS	.skipL090
   2515  40bc				   .condpart18
   2516  40bc		       a9 a4		      lda	#<C_function
   2517  40be		       8d 50 10 	      sta	DF0LOW
   2518  40c1		       a9 01		      lda	#(>C_function) & $0F
   2519  40c3		       8d 68 10 	      sta	DF0HI
   2520  40c6		       a2 0c		      LDX	#12
   2521  40c8		       8e 78 10 	      STX	DF0WRITE
   2522  40cb		       8e 78 10 	      STX	DF0WRITE
   2523  40ce		       a4 e9		      LDY	y
   2524  40d0		       8c 78 10 	      STY	DF0WRITE
   2525  40d3		       a5 e8		      LDA	x
   2526  40d5		       8d 78 10 	      STA	DF0WRITE
   2527  40d8		       a9 ff		      lda	#255
   2528  40da		       8d 5a 10 	      sta	CALLFUNCTION
   2529  40dd				   .skipL090
   2530  40dd				   .L091		;  next
   2531  40dd
   2532  40dd		       a5 e8		      LDA	x
   2533  40df		       c9 1e		      CMP	#30
   2534  40e1
   2535  40e1		       e6 e8		      INC	x
   2536  40e3					      if	((* - .L089forx) < 127) && ((* - .L089forx) > -128)
   2537  40e3		       90 d0		      bcc	.L089forx
   2538  40e5				  -	      else
   2539  40e5				  -	      bcs	.5skipL089forx
   2540  40e5				  -	      jmp	.L089forx
   2541  40e5				  -.5skipL089forx
   2542  40e5					      endif
   2543  40e5				   .L092		;  drawscreen
   2544  40e5
   2545  40e5		       85 81		      sta	temp7
   2546  40e7		       a9 70		      lda	#>(ret_point4-1)
   2547  40e9		       48		      pha
   2548  40ea		       a9 fc		      lda	#<(ret_point4-1)
   2549  40ec		       48		      pha
   2550  40ed		       a9 19		      lda	#>(drawscreen-1)
   2551  40ef		       48		      pha
   2552  40f0		       a9 50		      lda	#<(drawscreen-1)
   2553  40f2		       48		      pha
   2554  40f3		       a5 81		      lda	temp7
   2555  40f5		       48		      pha
   2556  40f6		       8a		      txa
   2557  40f7		       48		      pha
   2558  40f8		       a2 01		      ldx	#1
   2559  40fa		       4c ee df 	      jmp	BS_jsr
   2560  40fd				   ret_point4
   2561  40fd				   .L093		;  next
   2562  40fd
   2563  40fd		       a5 e9		      LDA	y
   2564  40ff		       c9 14		      CMP	#20
   2565  4101
   2566  4101		       e6 e9		      INC	y
   2567  4103					      if	((* - .L088fory) < 127) && ((* - .L088fory) > -128)
   2568  4103		       90 ac		      bcc	.L088fory
   2569  4105				  -	      else
   2570  4105				  -	      bcs	.6skipL088fory
   2571  4105				  -	      jmp	.L088fory
   2572  4105				  -.6skipL088fory
   2573  4105					      endif
   2574  4105				   .L094		;  return
   2575  4105
   2576  4105		       ba		      tsx
   2577  4106		       b5 02		      lda	2,x	; check return address
   2578  4108		       49 71		      eor	#(>*)	; vs. current PCH
   2579  410a		       29 e0		      and	#$E0	;  mask off all but top 3 bits
   2580  410c		       f0 03		      beq	*+5	; if equal, do normal return
   2581  410e		       4c e0 df 	      JMP	BS_return
   2582  4111		       60		      RTS
   2583  4112				   .
   2584  4112							;
   2585  4112
   2586  4112				   .
   2587  4112							;
   2588  4112
   2589  4112				   .
   2590  4112							;
   2591  4112
   2592  4112				   .
   2593  4112							;
   2594  4112
   2595  4112				   .
   2596  4112							;
   2597  4112
   2598  4112				   .SeedGlider
   2599  4112							; SeedGlider
   2600  4112
   2601  4112				   .L095		;  playfield:
   2602  4112
   2603  4112		       a0 11		      ldy	#17
   2604  4114		       a9 aa		      LDA	#<PF_data1
   2605  4116		       a2 61		      LDX	#((>PF_data1) & $0f) | (((>PF_data1) / 2) & $70)
   2606  4118		       85 81		      sta	temp7
   2607  411a		       a9 71		      lda	#>(ret_point5-1)
   2608  411c		       48		      pha
   2609  411d		       a9 2f		      lda	#<(ret_point5-1)
   2610  411f		       48		      pha
   2611  4120		       a9 1e		      lda	#>(pfsetup-1)
   2612  4122		       48		      pha
   2613  4123		       a9 8b		      lda	#<(pfsetup-1)
   2614  4125		       48		      pha
   2615  4126		       a5 81		      lda	temp7
   2616  4128		       48		      pha
   2617  4129		       8a		      txa
   2618  412a		       48		      pha
   2619  412b		       a2 01		      ldx	#1
   2620  412d		       4c ee df 	      jmp	BS_jsr
   2621  4130				   ret_point5
   2622  4130				   .L096		;  return
   2623  4130
   2624  4130		       ba		      tsx
   2625  4131		       b5 02		      lda	2,x	; check return address
   2626  4133		       49 71		      eor	#(>*)	; vs. current PCH
   2627  4135		       29 e0		      and	#$E0	;  mask off all but top 3 bits
   2628  4137		       f0 03		      beq	*+5	; if equal, do normal return
   2629  4139		       4c e0 df 	      JMP	BS_return
   2630  413c		       60		      RTS
   2631  413d				   .
   2632  413d							;
   2633  413d
   2634  413d				   .
   2635  413d							;
   2636  413d
   2637  413d				   .
   2638  413d							;
   2639  413d
   2640  413d				   .
   2641  413d							;
   2642  413d
   2643  413d				   .
   2644  413d							;
   2645  413d
   2646  413d				   .SeedExploders
   2647  413d							; SeedExploders
   2648  413d
   2649  413d				   .L097		;  playfield:
   2650  413d
   2651  413d		       a0 11		      ldy	#17
   2652  413f		       a9 ee		      LDA	#<PF_data2
   2653  4141		       a2 61		      LDX	#((>PF_data2) & $0f) | (((>PF_data2) / 2) & $70)
   2654  4143		       85 81		      sta	temp7
   2655  4145		       a9 71		      lda	#>(ret_point6-1)
   2656  4147		       48		      pha
   2657  4148		       a9 5a		      lda	#<(ret_point6-1)
   2658  414a		       48		      pha
   2659  414b		       a9 1e		      lda	#>(pfsetup-1)
   2660  414d		       48		      pha
   2661  414e		       a9 8b		      lda	#<(pfsetup-1)
   2662  4150		       48		      pha
   2663  4151		       a5 81		      lda	temp7
   2664  4153		       48		      pha
   2665  4154		       8a		      txa
   2666  4155		       48		      pha
   2667  4156		       a2 01		      ldx	#1
   2668  4158		       4c ee df 	      jmp	BS_jsr
   2669  415b				   ret_point6
   2670  415b				   .L098		;  return
   2671  415b
   2672  415b		       ba		      tsx
   2673  415c		       b5 02		      lda	2,x	; check return address
   2674  415e		       49 71		      eor	#(>*)	; vs. current PCH
   2675  4160		       29 e0		      and	#$E0	;  mask off all but top 3 bits
   2676  4162		       f0 03		      beq	*+5	; if equal, do normal return
   2677  4164		       4c e0 df 	      JMP	BS_return
   2678  4167		       60		      RTS
   2679  4168				   .
   2680  4168							;
   2681  4168
   2682  4168				   .
   2683  4168							;
   2684  4168
   2685  4168				   .
   2686  4168							;
   2687  4168
   2688  4168				   .
   2689  4168							;
   2690  4168
   2691  4168				   .
   2692  4168							;
   2693  4168
   2694  4168				   .SeedMix
   2695  4168							; SeedMix
   2696  4168
   2697  4168				   .L099		;  playfield:
   2698  4168
   2699  4168		       a0 11		      ldy	#17
   2700  416a		       a9 32		      LDA	#<PF_data3
   2701  416c		       a2 62		      LDX	#((>PF_data3) & $0f) | (((>PF_data3) / 2) & $70)
   2702  416e		       85 81		      sta	temp7
   2703  4170		       a9 71		      lda	#>(ret_point7-1)
   2704  4172		       48		      pha
   2705  4173		       a9 85		      lda	#<(ret_point7-1)
   2706  4175		       48		      pha
   2707  4176		       a9 1e		      lda	#>(pfsetup-1)
   2708  4178		       48		      pha
   2709  4179		       a9 8b		      lda	#<(pfsetup-1)
   2710  417b		       48		      pha
   2711  417c		       a5 81		      lda	temp7
   2712  417e		       48		      pha
   2713  417f		       8a		      txa
   2714  4180		       48		      pha
   2715  4181		       a2 01		      ldx	#1
   2716  4183		       4c ee df 	      jmp	BS_jsr
   2717  4186				   ret_point7
   2718  4186				   .L0100		;  return
   2719  4186
   2720  4186		       ba		      tsx
   2721  4187		       b5 02		      lda	2,x	; check return address
   2722  4189		       49 71		      eor	#(>*)	; vs. current PCH
   2723  418b		       29 e0		      and	#$E0	;  mask off all but top 3 bits
   2724  418d		       f0 03		      beq	*+5	; if equal, do normal return
   2725  418f		       4c e0 df 	      JMP	BS_return
   2726  4192		       60		      RTS
   2727  4193				   .
   2728  4193							;
   2729  4193
   2730  4193				   .
   2731  4193							;
   2732  4193
   2733  4193				   .
   2734  4193							;
   2735  4193
   2736  4193				   .
   2737  4193							;
   2738  4193
   2739  4193				   .
   2740  4193							;
   2741  4193
   2742  4193				   .SeedShip
   2743  4193							; SeedShip
   2744  4193
   2745  4193				   .L0101		;  playfield:
   2746  4193
   2747  4193		       a0 11		      ldy	#17
   2748  4195		       a9 76		      LDA	#<PF_data4
   2749  4197		       a2 62		      LDX	#((>PF_data4) & $0f) | (((>PF_data4) / 2) & $70)
   2750  4199		       85 81		      sta	temp7
   2751  419b		       a9 71		      lda	#>(ret_point8-1)
   2752  419d		       48		      pha
   2753  419e		       a9 b0		      lda	#<(ret_point8-1)
   2754  41a0		       48		      pha
   2755  41a1		       a9 1e		      lda	#>(pfsetup-1)
   2756  41a3		       48		      pha
   2757  41a4		       a9 8b		      lda	#<(pfsetup-1)
   2758  41a6		       48		      pha
   2759  41a7		       a5 81		      lda	temp7
   2760  41a9		       48		      pha
   2761  41aa		       8a		      txa
   2762  41ab		       48		      pha
   2763  41ac		       a2 01		      ldx	#1
   2764  41ae		       4c ee df 	      jmp	BS_jsr
   2765  41b1				   ret_point8
   2766  41b1				   .L0102		;  return
   2767  41b1
   2768  41b1		       ba		      tsx
   2769  41b2		       b5 02		      lda	2,x	; check return address
   2770  41b4		       49 71		      eor	#(>*)	; vs. current PCH
   2771  41b6		       29 e0		      and	#$E0	;  mask off all but top 3 bits
   2772  41b8		       f0 03		      beq	*+5	; if equal, do normal return
   2773  41ba		       4c e0 df 	      JMP	BS_return
   2774  41bd		       60		      RTS
   2775  41be				   .
   2776  41be							;
   2777  41be
   2778  41be				   .
   2779  41be							;
   2780  41be
   2781  41be				   .
   2782  41be							;
   2783  41be
   2784  41be				   .
   2785  41be							;
   2786  41be
   2787  41be				   .
   2788  41be							;
   2789  41be
   2790  41be				   .ChangeGameAndReset
   2791  41be							; ChangeGameAndReset
   2792  41be
   2793  41be				   .L0103		;  resetFlag  =  1
   2794  41be
   2795  41be		       a5 ea		      LDA	z
   2796  41c0		       09 02		      ORA	#2
   2797  41c2		       85 ea		      STA	z
   2798  41c4				   .L0104		;  pop
   2799  41c4
   2800  41c4		       68		      pla
   2801  41c5		       68		      pla
   2802  41c6				   .L0105		;  startingSeed  =  startingSeed  +  1
   2803  41c6
   2804  41c6		       e6 d7		      INC	startingSeed
   2805  41c8				   .L0106		;  if startingSeed  >	4 then startingSeed  =	0
   2806  41c8
   2807  41c8		       a9 04		      LDA	#4
   2808  41ca		       c5 d7		      CMP	startingSeed
   2809  41cc		       b0 04		      BCS	.skipL0106
   2810  41ce				   .condpart19
   2811  41ce		       a9 00		      LDA	#0
   2812  41d0		       85 d7		      STA	startingSeed
   2813  41d2				   .skipL0106
   2814  41d2				   .L0107		;  pfclear
   2815  41d2
   2816  41d2		       a9 a4		      lda	#<C_function
   2817  41d4		       8d 50 10 	      sta	DF0LOW
   2818  41d7		       a9 01		      lda	#(>C_function) & $0F
   2819  41d9		       8d 68 10 	      sta	DF0HI
   2820  41dc		       a2 1c		      ldx	#28
   2821  41de		       8e 78 10 	      stx	DF0WRITE
   2822  41e1		       a9 00		      LDA	#0
   2823  41e3		       8d 78 10 	      sta	DF0WRITE
   2824  41e6		       a9 ff		      lda	#255
   2825  41e8		       8d 5a 10 	      sta	CALLFUNCTION
   2826  41eb				   .L0108		;  drawscreen
   2827  41eb
   2828  41eb		       85 81		      sta	temp7
   2829  41ed		       a9 72		      lda	#>(ret_point9-1)
   2830  41ef		       48		      pha
   2831  41f0		       a9 02		      lda	#<(ret_point9-1)
   2832  41f2		       48		      pha
   2833  41f3		       a9 19		      lda	#>(drawscreen-1)
   2834  41f5		       48		      pha
   2835  41f6		       a9 50		      lda	#<(drawscreen-1)
   2836  41f8		       48		      pha
   2837  41f9		       a5 81		      lda	temp7
   2838  41fb		       48		      pha
   2839  41fc		       8a		      txa
   2840  41fd		       48		      pha
   2841  41fe		       a2 01		      ldx	#1
   2842  4200		       4c ee df 	      jmp	BS_jsr
   2843  4203				   ret_point9
   2844  4203				   .L0109		;  score  =  0
   2845  4203
   2846  4203		       a9 00		      LDA	#$00
   2847  4205		       85 ba		      STA	score+2
   2848  4207		       a9 00		      LDA	#$00
   2849  4209		       85 b9		      STA	score+1
   2850  420b		       a9 00		      LDA	#$00
   2851  420d		       85 b8		      STA	score
   2852  420f				   .L0110		;  stack 0  :	stackCounter  =  0
   2853  420f
   2854  420f		       a9 a5		      lda	#<(STACKbegin+0)
   2855  4211		       8d 57 10 	      STA	DF7LOW
   2856  4214		       a9 0c		      lda	#(>(STACKbegin+0)) & $0F
   2857  4216		       8d 6f 10 	      STA	DF7HI
   2858  4219		       a9 00		      LDA	#0
   2859  421b		       85 d1		      STA	stackCounter
   2860  421d				   .L0111		;  gosub SelectSeed
   2861  421d
   2862  421d		       20 85 70 	      jsr	.SelectSeed
   2863  4220
   2864  4220				   .L0112		;  goto MainLoop bank3
   2865  4220
   2866  4220		       85 81		      sta	temp7
   2867  4222		       a9 50		      lda	#>(.MainLoop-1)
   2868  4224		       48		      pha
   2869  4225		       a9 84		      lda	#<(.MainLoop-1)
   2870  4227		       48		      pha
   2871  4228		       a5 81		      lda	temp7
   2872  422a		       48		      pha
   2873  422b		       8a		      txa
   2874  422c		       48		      pha
   2875  422d		       a2 03		      ldx	#3
   2876  422f		       4c ee df 	      jmp	BS_jsr
   2877  4232				   .
   2878  4232							;
   2879  4232
   2880  4232				   .
   2881  4232							;
   2882  4232
   2883  4232				   .
   2884  4232							;
   2885  4232
   2886  4232				   .L0113		;  bank 5
   2887  4232
   2888  4232					      if	ECHO4
      3490 bytes of ROM space left in bank 4
   2889  4232					      echo	"    ",[(start_bank4 - *)]d , "bytes of ROM space left in bank 4")
   2890  4232					      endif
   2891  4232		       00 01	   ECHO4      =	1
   2892  4fd4					      ORG	$4FF4-bscode_length
   2893  4fd4					      RORG	$7FF4-bscode_length
   2894  4fd4		       a2 ff	   start_bank4 ldx	#$ff
   2895  4fd6					      ifconst	FASTFETCH	; using DPC+
   2896  4fd6		       8e 58 10 	      stx	FASTFETCH
   2897  4fd9					      endif
   2898  4fd9		       9a		      txs
   2899  4fda				  -	      if	bankswitch == 64
   2900  4fda				  -	      lda	#(((>(start-1)) & $0F) | $F0)
   2901  4fda					      else
   2902  4fda		       a9 18		      lda	#>(start-1)
   2903  4fdc					      endif
   2904  4fdc		       48		      pha
   2905  4fdd		       a9 eb		      lda	#<(start-1)
   2906  4fdf		       48		      pha
   2907  4fe0		       48		      pha
   2908  4fe1		       8a		      txa
   2909  4fe2		       48		      pha
   2910  4fe3		       ba		      tsx
   2911  4fe4					      if	bankswitch != 64
   2912  4fe4		       b5 04		      lda	4,x	; get high byte of return address
   2913  4fe6		       2a		      rol
   2914  4fe7		       2a		      rol
   2915  4fe8		       2a		      rol
   2916  4fe9		       2a		      rol
   2917  4fea		       29 07		      and	#bs_mask	;1 3 or 7 for F8/F6/F4
   2918  4fec		       aa		      tax
   2919  4fed		       e8		      inx
   2920  4fee				  -	      else
   2921  4fee				  -	      lda	4,x	; get high byte of return address
   2922  4fee				  -	      tay
   2923  4fee				  -	      ora	#$10	; change our bank nibble into a valid rom mirror
   2924  4fee				  -	      sta	4,x
   2925  4fee				  -	      tya
   2926  4fee				  -	      lsr
   2927  4fee				  -	      lsr
   2928  4fee				  -	      lsr
   2929  4fee				  -	      lsr
   2930  4fee				  -	      tax
   2931  4fee				  -	      inx
   2932  4fee					      endif
   2933  4fee		       bd f5 1f 	      lda	bankswitch_hotspot-1,x
   2934  4ff1		       68		      pla
   2935  4ff2		       aa		      tax
   2936  4ff3		       68		      pla
   2937  4ff4		       60		      rts
   2938  4ff5				  -	      if	((* & $1FFF) > ((bankswitch_hotspot & $1FFF) - 1))
   2939  4ff5				  -	      echo	"WARNING: size parameter in banksw.asm too small - the program probably will not work."
   2940  4ff5				  -	      echo	"Change to",[(*-begin_bscode+1)&$FF]d,"and try again."
   2941  4ff5					      endif
   2942  4ffc					      ORG	$4FFC
   2943  4ffc					      RORG	$7FFC
   2944  4ffc		       d4 7f		      .word.w	start_bank4
   2945  4ffe		       d4 7f		      .word.w	start_bank4
   2946  5000					      ORG	$5000
   2947  5000					      RORG	$9000
   2948  5000					      repeat	129
   2949  5000		       00		      .byte.b	0
   2948  5000					      repend
   2949  5001		       00		      .byte.b	0
   2948  5001					      repend
   2949  5002		       00		      .byte.b	0
   2948  5002					      repend
   2949  5003		       00		      .byte.b	0
   2948  5003					      repend
   2949  5004		       00		      .byte.b	0
   2948  5004					      repend
   2949  5005		       00		      .byte.b	0
   2948  5005					      repend
   2949  5006		       00		      .byte.b	0
   2948  5006					      repend
   2949  5007		       00		      .byte.b	0
   2948  5007					      repend
   2949  5008		       00		      .byte.b	0
   2948  5008					      repend
   2949  5009		       00		      .byte.b	0
   2948  5009					      repend
   2949  500a		       00		      .byte.b	0
   2948  500a					      repend
   2949  500b		       00		      .byte.b	0
   2948  500b					      repend
   2949  500c		       00		      .byte.b	0
   2948  500c					      repend
   2949  500d		       00		      .byte.b	0
   2948  500d					      repend
   2949  500e		       00		      .byte.b	0
   2948  500e					      repend
   2949  500f		       00		      .byte.b	0
   2948  500f					      repend
   2949  5010		       00		      .byte.b	0
   2948  5010					      repend
   2949  5011		       00		      .byte.b	0
   2948  5011					      repend
   2949  5012		       00		      .byte.b	0
   2948  5012					      repend
   2949  5013		       00		      .byte.b	0
   2948  5013					      repend
   2949  5014		       00		      .byte.b	0
   2948  5014					      repend
   2949  5015		       00		      .byte.b	0
   2948  5015					      repend
   2949  5016		       00		      .byte.b	0
   2948  5016					      repend
   2949  5017		       00		      .byte.b	0
   2948  5017					      repend
   2949  5018		       00		      .byte.b	0
   2948  5018					      repend
   2949  5019		       00		      .byte.b	0
   2948  5019					      repend
   2949  501a		       00		      .byte.b	0
   2948  501a					      repend
   2949  501b		       00		      .byte.b	0
   2948  501b					      repend
   2949  501c		       00		      .byte.b	0
   2948  501c					      repend
   2949  501d		       00		      .byte.b	0
   2948  501d					      repend
   2949  501e		       00		      .byte.b	0
   2948  501e					      repend
   2949  501f		       00		      .byte.b	0
   2948  501f					      repend
   2949  5020		       00		      .byte.b	0
   2948  5020					      repend
   2949  5021		       00		      .byte.b	0
   2948  5021					      repend
   2949  5022		       00		      .byte.b	0
   2948  5022					      repend
   2949  5023		       00		      .byte.b	0
   2948  5023					      repend
   2949  5024		       00		      .byte.b	0
   2948  5024					      repend
   2949  5025		       00		      .byte.b	0
   2948  5025					      repend
   2949  5026		       00		      .byte.b	0
   2948  5026					      repend
   2949  5027		       00		      .byte.b	0
   2948  5027					      repend
   2949  5028		       00		      .byte.b	0
   2948  5028					      repend
   2949  5029		       00		      .byte.b	0
   2948  5029					      repend
   2949  502a		       00		      .byte.b	0
   2948  502a					      repend
   2949  502b		       00		      .byte.b	0
   2948  502b					      repend
   2949  502c		       00		      .byte.b	0
   2948  502c					      repend
   2949  502d		       00		      .byte.b	0
   2948  502d					      repend
   2949  502e		       00		      .byte.b	0
   2948  502e					      repend
   2949  502f		       00		      .byte.b	0
   2948  502f					      repend
   2949  5030		       00		      .byte.b	0
   2948  5030					      repend
   2949  5031		       00		      .byte.b	0
   2948  5031					      repend
   2949  5032		       00		      .byte.b	0
   2948  5032					      repend
   2949  5033		       00		      .byte.b	0
   2948  5033					      repend
   2949  5034		       00		      .byte.b	0
   2948  5034					      repend
   2949  5035		       00		      .byte.b	0
   2948  5035					      repend
   2949  5036		       00		      .byte.b	0
   2948  5036					      repend
   2949  5037		       00		      .byte.b	0
   2948  5037					      repend
   2949  5038		       00		      .byte.b	0
   2948  5038					      repend
   2949  5039		       00		      .byte.b	0
   2948  5039					      repend
   2949  503a		       00		      .byte.b	0
   2948  503a					      repend
   2949  503b		       00		      .byte.b	0
   2948  503b					      repend
   2949  503c		       00		      .byte.b	0
   2948  503c					      repend
   2949  503d		       00		      .byte.b	0
   2948  503d					      repend
   2949  503e		       00		      .byte.b	0
   2948  503e					      repend
   2949  503f		       00		      .byte.b	0
   2948  503f					      repend
   2949  5040		       00		      .byte.b	0
   2948  5040					      repend
   2949  5041		       00		      .byte.b	0
   2948  5041					      repend
   2949  5042		       00		      .byte.b	0
   2948  5042					      repend
   2949  5043		       00		      .byte.b	0
   2948  5043					      repend
   2949  5044		       00		      .byte.b	0
   2948  5044					      repend
   2949  5045		       00		      .byte.b	0
   2948  5045					      repend
   2949  5046		       00		      .byte.b	0
   2948  5046					      repend
   2949  5047		       00		      .byte.b	0
   2948  5047					      repend
   2949  5048		       00		      .byte.b	0
   2948  5048					      repend
   2949  5049		       00		      .byte.b	0
   2948  5049					      repend
   2949  504a		       00		      .byte.b	0
   2948  504a					      repend
   2949  504b		       00		      .byte.b	0
   2948  504b					      repend
   2949  504c		       00		      .byte.b	0
   2948  504c					      repend
   2949  504d		       00		      .byte.b	0
   2948  504d					      repend
   2949  504e		       00		      .byte.b	0
   2948  504e					      repend
   2949  504f		       00		      .byte.b	0
   2948  504f					      repend
   2949  5050		       00		      .byte.b	0
   2948  5050					      repend
   2949  5051		       00		      .byte.b	0
   2948  5051					      repend
   2949  5052		       00		      .byte.b	0
   2948  5052					      repend
   2949  5053		       00		      .byte.b	0
   2948  5053					      repend
   2949  5054		       00		      .byte.b	0
   2948  5054					      repend
   2949  5055		       00		      .byte.b	0
   2948  5055					      repend
   2949  5056		       00		      .byte.b	0
   2948  5056					      repend
   2949  5057		       00		      .byte.b	0
   2948  5057					      repend
   2949  5058		       00		      .byte.b	0
   2948  5058					      repend
   2949  5059		       00		      .byte.b	0
   2948  5059					      repend
   2949  505a		       00		      .byte.b	0
   2948  505a					      repend
   2949  505b		       00		      .byte.b	0
   2948  505b					      repend
   2949  505c		       00		      .byte.b	0
   2948  505c					      repend
   2949  505d		       00		      .byte.b	0
   2948  505d					      repend
   2949  505e		       00		      .byte.b	0
   2948  505e					      repend
   2949  505f		       00		      .byte.b	0
   2948  505f					      repend
   2949  5060		       00		      .byte.b	0
   2948  5060					      repend
   2949  5061		       00		      .byte.b	0
   2948  5061					      repend
   2949  5062		       00		      .byte.b	0
   2948  5062					      repend
   2949  5063		       00		      .byte.b	0
   2948  5063					      repend
   2949  5064		       00		      .byte.b	0
   2948  5064					      repend
   2949  5065		       00		      .byte.b	0
   2948  5065					      repend
   2949  5066		       00		      .byte.b	0
   2948  5066					      repend
   2949  5067		       00		      .byte.b	0
   2948  5067					      repend
   2949  5068		       00		      .byte.b	0
   2948  5068					      repend
   2949  5069		       00		      .byte.b	0
   2948  5069					      repend
   2949  506a		       00		      .byte.b	0
   2948  506a					      repend
   2949  506b		       00		      .byte.b	0
   2948  506b					      repend
   2949  506c		       00		      .byte.b	0
   2948  506c					      repend
   2949  506d		       00		      .byte.b	0
   2948  506d					      repend
   2949  506e		       00		      .byte.b	0
   2948  506e					      repend
   2949  506f		       00		      .byte.b	0
   2948  506f					      repend
   2949  5070		       00		      .byte.b	0
   2948  5070					      repend
   2949  5071		       00		      .byte.b	0
   2948  5071					      repend
   2949  5072		       00		      .byte.b	0
   2948  5072					      repend
   2949  5073		       00		      .byte.b	0
   2948  5073					      repend
   2949  5074		       00		      .byte.b	0
   2948  5074					      repend
   2949  5075		       00		      .byte.b	0
   2948  5075					      repend
   2949  5076		       00		      .byte.b	0
   2948  5076					      repend
   2949  5077		       00		      .byte.b	0
   2948  5077					      repend
   2949  5078		       00		      .byte.b	0
   2948  5078					      repend
   2949  5079		       00		      .byte.b	0
   2948  5079					      repend
   2949  507a		       00		      .byte.b	0
   2948  507a					      repend
   2949  507b		       00		      .byte.b	0
   2948  507b					      repend
   2949  507c		       00		      .byte.b	0
   2948  507c					      repend
   2949  507d		       00		      .byte.b	0
   2948  507d					      repend
   2949  507e		       00		      .byte.b	0
   2948  507e					      repend
   2949  507f		       00		      .byte.b	0
   2948  507f					      repend
   2949  5080		       00		      .byte.b	0
   2950  5081					      repend
   2951  5081				   .L0114		;  temp1 = temp1
   2952  5081
   2953  5081		       a5 cb		      LDA	temp1
   2954  5083		       85 cb		      STA	temp1
   2955  5085				   .
   2956  5085							;
   2957  5085
   2958  5085				   .
   2959  5085							;
   2960  5085
   2961  5085				   .L0115		;  bank 6
   2962  5085
   2963  5085					      if	ECHO5
      3919 bytes of ROM space left in bank 5
   2964  5085					      echo	"    ",[(start_bank5 - *)]d , "bytes of ROM space left in bank 5")
   2965  5085					      endif
   2966  5085		       00 01	   ECHO5      =	1
   2967  5fd4					      ORG	$5FF4-bscode_length
   2968  5fd4					      RORG	$9FF4-bscode_length
   2969  5fd4		       a2 ff	   start_bank5 ldx	#$ff
   2970  5fd6					      ifconst	FASTFETCH	; using DPC+
   2971  5fd6		       8e 58 10 	      stx	FASTFETCH
   2972  5fd9					      endif
   2973  5fd9		       9a		      txs
   2974  5fda				  -	      if	bankswitch == 64
   2975  5fda				  -	      lda	#(((>(start-1)) & $0F) | $F0)
   2976  5fda					      else
   2977  5fda		       a9 18		      lda	#>(start-1)
   2978  5fdc					      endif
   2979  5fdc		       48		      pha
   2980  5fdd		       a9 eb		      lda	#<(start-1)
   2981  5fdf		       48		      pha
   2982  5fe0		       48		      pha
   2983  5fe1		       8a		      txa
   2984  5fe2		       48		      pha
   2985  5fe3		       ba		      tsx
   2986  5fe4					      if	bankswitch != 64
   2987  5fe4		       b5 04		      lda	4,x	; get high byte of return address
   2988  5fe6		       2a		      rol
   2989  5fe7		       2a		      rol
   2990  5fe8		       2a		      rol
   2991  5fe9		       2a		      rol
   2992  5fea		       29 07		      and	#bs_mask	;1 3 or 7 for F8/F6/F4
   2993  5fec		       aa		      tax
   2994  5fed		       e8		      inx
   2995  5fee				  -	      else
   2996  5fee				  -	      lda	4,x	; get high byte of return address
   2997  5fee				  -	      tay
   2998  5fee				  -	      ora	#$10	; change our bank nibble into a valid rom mirror
   2999  5fee				  -	      sta	4,x
   3000  5fee				  -	      tya
   3001  5fee				  -	      lsr
   3002  5fee				  -	      lsr
   3003  5fee				  -	      lsr
   3004  5fee				  -	      lsr
   3005  5fee				  -	      tax
   3006  5fee				  -	      inx
   3007  5fee					      endif
   3008  5fee		       bd f5 1f 	      lda	bankswitch_hotspot-1,x
   3009  5ff1		       68		      pla
   3010  5ff2		       aa		      tax
   3011  5ff3		       68		      pla
   3012  5ff4		       60		      rts
   3013  5ff5				  -	      if	((* & $1FFF) > ((bankswitch_hotspot & $1FFF) - 1))
   3014  5ff5				  -	      echo	"WARNING: size parameter in banksw.asm too small - the program probably will not work."
   3015  5ff5				  -	      echo	"Change to",[(*-begin_bscode+1)&$FF]d,"and try again."
   3016  5ff5					      endif
   3017  5ffc					      ORG	$5FFC
   3018  5ffc					      RORG	$9FFC
   3019  5ffc		       d4 9f		      .word.w	start_bank5
   3020  5ffe		       d4 9f		      .word.w	start_bank5
   3021  6000					      ORG	$6000
   3022  6000					      RORG	$B000
   3023  6000					      repeat	129
   3024  6000		       00		      .byte.b	0
   3023  6000					      repend
   3024  6001		       00		      .byte.b	0
   3023  6001					      repend
   3024  6002		       00		      .byte.b	0
   3023  6002					      repend
   3024  6003		       00		      .byte.b	0
   3023  6003					      repend
   3024  6004		       00		      .byte.b	0
   3023  6004					      repend
   3024  6005		       00		      .byte.b	0
   3023  6005					      repend
   3024  6006		       00		      .byte.b	0
   3023  6006					      repend
   3024  6007		       00		      .byte.b	0
   3023  6007					      repend
   3024  6008		       00		      .byte.b	0
   3023  6008					      repend
   3024  6009		       00		      .byte.b	0
   3023  6009					      repend
   3024  600a		       00		      .byte.b	0
   3023  600a					      repend
   3024  600b		       00		      .byte.b	0
   3023  600b					      repend
   3024  600c		       00		      .byte.b	0
   3023  600c					      repend
   3024  600d		       00		      .byte.b	0
   3023  600d					      repend
   3024  600e		       00		      .byte.b	0
   3023  600e					      repend
   3024  600f		       00		      .byte.b	0
   3023  600f					      repend
   3024  6010		       00		      .byte.b	0
   3023  6010					      repend
   3024  6011		       00		      .byte.b	0
   3023  6011					      repend
   3024  6012		       00		      .byte.b	0
   3023  6012					      repend
   3024  6013		       00		      .byte.b	0
   3023  6013					      repend
   3024  6014		       00		      .byte.b	0
   3023  6014					      repend
   3024  6015		       00		      .byte.b	0
   3023  6015					      repend
   3024  6016		       00		      .byte.b	0
   3023  6016					      repend
   3024  6017		       00		      .byte.b	0
   3023  6017					      repend
   3024  6018		       00		      .byte.b	0
   3023  6018					      repend
   3024  6019		       00		      .byte.b	0
   3023  6019					      repend
   3024  601a		       00		      .byte.b	0
   3023  601a					      repend
   3024  601b		       00		      .byte.b	0
   3023  601b					      repend
   3024  601c		       00		      .byte.b	0
   3023  601c					      repend
   3024  601d		       00		      .byte.b	0
   3023  601d					      repend
   3024  601e		       00		      .byte.b	0
   3023  601e					      repend
   3024  601f		       00		      .byte.b	0
   3023  601f					      repend
   3024  6020		       00		      .byte.b	0
   3023  6020					      repend
   3024  6021		       00		      .byte.b	0
   3023  6021					      repend
   3024  6022		       00		      .byte.b	0
   3023  6022					      repend
   3024  6023		       00		      .byte.b	0
   3023  6023					      repend
   3024  6024		       00		      .byte.b	0
   3023  6024					      repend
   3024  6025		       00		      .byte.b	0
   3023  6025					      repend
   3024  6026		       00		      .byte.b	0
   3023  6026					      repend
   3024  6027		       00		      .byte.b	0
   3023  6027					      repend
   3024  6028		       00		      .byte.b	0
   3023  6028					      repend
   3024  6029		       00		      .byte.b	0
   3023  6029					      repend
   3024  602a		       00		      .byte.b	0
   3023  602a					      repend
   3024  602b		       00		      .byte.b	0
   3023  602b					      repend
   3024  602c		       00		      .byte.b	0
   3023  602c					      repend
   3024  602d		       00		      .byte.b	0
   3023  602d					      repend
   3024  602e		       00		      .byte.b	0
   3023  602e					      repend
   3024  602f		       00		      .byte.b	0
   3023  602f					      repend
   3024  6030		       00		      .byte.b	0
   3023  6030					      repend
   3024  6031		       00		      .byte.b	0
   3023  6031					      repend
   3024  6032		       00		      .byte.b	0
   3023  6032					      repend
   3024  6033		       00		      .byte.b	0
   3023  6033					      repend
   3024  6034		       00		      .byte.b	0
   3023  6034					      repend
   3024  6035		       00		      .byte.b	0
   3023  6035					      repend
   3024  6036		       00		      .byte.b	0
   3023  6036					      repend
   3024  6037		       00		      .byte.b	0
   3023  6037					      repend
   3024  6038		       00		      .byte.b	0
   3023  6038					      repend
   3024  6039		       00		      .byte.b	0
   3023  6039					      repend
   3024  603a		       00		      .byte.b	0
   3023  603a					      repend
   3024  603b		       00		      .byte.b	0
   3023  603b					      repend
   3024  603c		       00		      .byte.b	0
   3023  603c					      repend
   3024  603d		       00		      .byte.b	0
   3023  603d					      repend
   3024  603e		       00		      .byte.b	0
   3023  603e					      repend
   3024  603f		       00		      .byte.b	0
   3023  603f					      repend
   3024  6040		       00		      .byte.b	0
   3023  6040					      repend
   3024  6041		       00		      .byte.b	0
   3023  6041					      repend
   3024  6042		       00		      .byte.b	0
   3023  6042					      repend
   3024  6043		       00		      .byte.b	0
   3023  6043					      repend
   3024  6044		       00		      .byte.b	0
   3023  6044					      repend
   3024  6045		       00		      .byte.b	0
   3023  6045					      repend
   3024  6046		       00		      .byte.b	0
   3023  6046					      repend
   3024  6047		       00		      .byte.b	0
   3023  6047					      repend
   3024  6048		       00		      .byte.b	0
   3023  6048					      repend
   3024  6049		       00		      .byte.b	0
   3023  6049					      repend
   3024  604a		       00		      .byte.b	0
   3023  604a					      repend
   3024  604b		       00		      .byte.b	0
   3023  604b					      repend
   3024  604c		       00		      .byte.b	0
   3023  604c					      repend
   3024  604d		       00		      .byte.b	0
   3023  604d					      repend
   3024  604e		       00		      .byte.b	0
   3023  604e					      repend
   3024  604f		       00		      .byte.b	0
   3023  604f					      repend
   3024  6050		       00		      .byte.b	0
   3023  6050					      repend
   3024  6051		       00		      .byte.b	0
   3023  6051					      repend
   3024  6052		       00		      .byte.b	0
   3023  6052					      repend
   3024  6053		       00		      .byte.b	0
   3023  6053					      repend
   3024  6054		       00		      .byte.b	0
   3023  6054					      repend
   3024  6055		       00		      .byte.b	0
   3023  6055					      repend
   3024  6056		       00		      .byte.b	0
   3023  6056					      repend
   3024  6057		       00		      .byte.b	0
   3023  6057					      repend
   3024  6058		       00		      .byte.b	0
   3023  6058					      repend
   3024  6059		       00		      .byte.b	0
   3023  6059					      repend
   3024  605a		       00		      .byte.b	0
   3023  605a					      repend
   3024  605b		       00		      .byte.b	0
   3023  605b					      repend
   3024  605c		       00		      .byte.b	0
   3023  605c					      repend
   3024  605d		       00		      .byte.b	0
   3023  605d					      repend
   3024  605e		       00		      .byte.b	0
   3023  605e					      repend
   3024  605f		       00		      .byte.b	0
   3023  605f					      repend
   3024  6060		       00		      .byte.b	0
   3023  6060					      repend
   3024  6061		       00		      .byte.b	0
   3023  6061					      repend
   3024  6062		       00		      .byte.b	0
   3023  6062					      repend
   3024  6063		       00		      .byte.b	0
   3023  6063					      repend
   3024  6064		       00		      .byte.b	0
   3023  6064					      repend
   3024  6065		       00		      .byte.b	0
   3023  6065					      repend
   3024  6066		       00		      .byte.b	0
   3023  6066					      repend
   3024  6067		       00		      .byte.b	0
   3023  6067					      repend
   3024  6068		       00		      .byte.b	0
   3023  6068					      repend
   3024  6069		       00		      .byte.b	0
   3023  6069					      repend
   3024  606a		       00		      .byte.b	0
   3023  606a					      repend
   3024  606b		       00		      .byte.b	0
   3023  606b					      repend
   3024  606c		       00		      .byte.b	0
   3023  606c					      repend
   3024  606d		       00		      .byte.b	0
   3023  606d					      repend
   3024  606e		       00		      .byte.b	0
   3023  606e					      repend
   3024  606f		       00		      .byte.b	0
   3023  606f					      repend
   3024  6070		       00		      .byte.b	0
   3023  6070					      repend
   3024  6071		       00		      .byte.b	0
   3023  6071					      repend
   3024  6072		       00		      .byte.b	0
   3023  6072					      repend
   3024  6073		       00		      .byte.b	0
   3023  6073					      repend
   3024  6074		       00		      .byte.b	0
   3023  6074					      repend
   3024  6075		       00		      .byte.b	0
   3023  6075					      repend
   3024  6076		       00		      .byte.b	0
   3023  6076					      repend
   3024  6077		       00		      .byte.b	0
   3023  6077					      repend
   3024  6078		       00		      .byte.b	0
   3023  6078					      repend
   3024  6079		       00		      .byte.b	0
   3023  6079					      repend
   3024  607a		       00		      .byte.b	0
   3023  607a					      repend
   3024  607b		       00		      .byte.b	0
   3023  607b					      repend
   3024  607c		       00		      .byte.b	0
   3023  607c					      repend
   3024  607d		       00		      .byte.b	0
   3023  607d					      repend
   3024  607e		       00		      .byte.b	0
   3023  607e					      repend
   3024  607f		       00		      .byte.b	0
   3023  607f					      repend
   3024  6080		       00		      .byte.b	0
   3025  6081					      repend
   3026  6081				   .L0116		;  temp1 = temp1
   3027  6081		       a5 cb		      LDA	temp1
   3028  6083		       85 cb		      STA	temp1
   3029  6085					      if	ECHO6
      3919 bytes of ROM space left in bank 6
   3030  6085					      echo	"    ",[(start_bank6 - *)]d , "bytes of ROM space left in bank 6")
   3031  6085					      endif
   3032  6085		       00 01	   ECHO6      =	1
   3033  6fd4					      ORG	$6FF4-bscode_length
   3034  6fd4					      RORG	$BFF4-bscode_length
   3035  6fd4		       a2 ff	   start_bank6 ldx	#$ff
   3036  6fd6					      ifconst	FASTFETCH	; using DPC+
   3037  6fd6		       8e 58 10 	      stx	FASTFETCH
   3038  6fd9					      endif
   3039  6fd9		       9a		      txs
   3040  6fda				  -	      if	bankswitch == 64
   3041  6fda				  -	      lda	#(((>(start-1)) & $0F) | $F0)
   3042  6fda					      else
   3043  6fda		       a9 18		      lda	#>(start-1)
   3044  6fdc					      endif
   3045  6fdc		       48		      pha
   3046  6fdd		       a9 eb		      lda	#<(start-1)
   3047  6fdf		       48		      pha
   3048  6fe0		       48		      pha
   3049  6fe1		       8a		      txa
   3050  6fe2		       48		      pha
   3051  6fe3		       ba		      tsx
   3052  6fe4					      if	bankswitch != 64
   3053  6fe4		       b5 04		      lda	4,x	; get high byte of return address
   3054  6fe6		       2a		      rol
   3055  6fe7		       2a		      rol
   3056  6fe8		       2a		      rol
   3057  6fe9		       2a		      rol
   3058  6fea		       29 07		      and	#bs_mask	;1 3 or 7 for F8/F6/F4
   3059  6fec		       aa		      tax
   3060  6fed		       e8		      inx
   3061  6fee				  -	      else
   3062  6fee				  -	      lda	4,x	; get high byte of return address
   3063  6fee				  -	      tay
   3064  6fee				  -	      ora	#$10	; change our bank nibble into a valid rom mirror
   3065  6fee				  -	      sta	4,x
   3066  6fee				  -	      tya
   3067  6fee				  -	      lsr
   3068  6fee				  -	      lsr
   3069  6fee				  -	      lsr
   3070  6fee				  -	      lsr
   3071  6fee				  -	      tax
   3072  6fee				  -	      inx
   3073  6fee					      endif
   3074  6fee		       bd f5 1f 	      lda	bankswitch_hotspot-1,x
   3075  6ff1		       68		      pla
   3076  6ff2		       aa		      tax
   3077  6ff3		       68		      pla
   3078  6ff4		       60		      rts
   3079  6ff5				  -	      if	((* & $1FFF) > ((bankswitch_hotspot & $1FFF) - 1))
   3080  6ff5				  -	      echo	"WARNING: size parameter in banksw.asm too small - the program probably will not work."
   3081  6ff5				  -	      echo	"Change to",[(*-begin_bscode+1)&$FF]d,"and try again."
   3082  6ff5					      endif
   3083  6ffc					      ORG	$6FFC
   3084  6ffc					      RORG	$BFFC
   3085  6ffc		       d4 bf		      .word.w	start_bank6
   3086  6ffe		       d4 bf		      .word.w	start_bank6
   3087  7000					      ORG	$7000
   3088  7000					      RORG	$D000
   3089  7000					      repeat	129
   3090  7000		       00		      .byte.b	0
   3089  7000					      repend
   3090  7001		       00		      .byte.b	0
   3089  7001					      repend
   3090  7002		       00		      .byte.b	0
   3089  7002					      repend
   3090  7003		       00		      .byte.b	0
   3089  7003					      repend
   3090  7004		       00		      .byte.b	0
   3089  7004					      repend
   3090  7005		       00		      .byte.b	0
   3089  7005					      repend
   3090  7006		       00		      .byte.b	0
   3089  7006					      repend
   3090  7007		       00		      .byte.b	0
   3089  7007					      repend
   3090  7008		       00		      .byte.b	0
   3089  7008					      repend
   3090  7009		       00		      .byte.b	0
   3089  7009					      repend
   3090  700a		       00		      .byte.b	0
   3089  700a					      repend
   3090  700b		       00		      .byte.b	0
   3089  700b					      repend
   3090  700c		       00		      .byte.b	0
   3089  700c					      repend
   3090  700d		       00		      .byte.b	0
   3089  700d					      repend
   3090  700e		       00		      .byte.b	0
   3089  700e					      repend
   3090  700f		       00		      .byte.b	0
   3089  700f					      repend
   3090  7010		       00		      .byte.b	0
   3089  7010					      repend
   3090  7011		       00		      .byte.b	0
   3089  7011					      repend
   3090  7012		       00		      .byte.b	0
   3089  7012					      repend
   3090  7013		       00		      .byte.b	0
   3089  7013					      repend
   3090  7014		       00		      .byte.b	0
   3089  7014					      repend
   3090  7015		       00		      .byte.b	0
   3089  7015					      repend
   3090  7016		       00		      .byte.b	0
   3089  7016					      repend
   3090  7017		       00		      .byte.b	0
   3089  7017					      repend
   3090  7018		       00		      .byte.b	0
   3089  7018					      repend
   3090  7019		       00		      .byte.b	0
   3089  7019					      repend
   3090  701a		       00		      .byte.b	0
   3089  701a					      repend
   3090  701b		       00		      .byte.b	0
   3089  701b					      repend
   3090  701c		       00		      .byte.b	0
   3089  701c					      repend
   3090  701d		       00		      .byte.b	0
   3089  701d					      repend
   3090  701e		       00		      .byte.b	0
   3089  701e					      repend
   3090  701f		       00		      .byte.b	0
   3089  701f					      repend
   3090  7020		       00		      .byte.b	0
   3089  7020					      repend
   3090  7021		       00		      .byte.b	0
   3089  7021					      repend
   3090  7022		       00		      .byte.b	0
   3089  7022					      repend
   3090  7023		       00		      .byte.b	0
   3089  7023					      repend
   3090  7024		       00		      .byte.b	0
   3089  7024					      repend
   3090  7025		       00		      .byte.b	0
   3089  7025					      repend
   3090  7026		       00		      .byte.b	0
   3089  7026					      repend
   3090  7027		       00		      .byte.b	0
   3089  7027					      repend
   3090  7028		       00		      .byte.b	0
   3089  7028					      repend
   3090  7029		       00		      .byte.b	0
   3089  7029					      repend
   3090  702a		       00		      .byte.b	0
   3089  702a					      repend
   3090  702b		       00		      .byte.b	0
   3089  702b					      repend
   3090  702c		       00		      .byte.b	0
   3089  702c					      repend
   3090  702d		       00		      .byte.b	0
   3089  702d					      repend
   3090  702e		       00		      .byte.b	0
   3089  702e					      repend
   3090  702f		       00		      .byte.b	0
   3089  702f					      repend
   3090  7030		       00		      .byte.b	0
   3089  7030					      repend
   3090  7031		       00		      .byte.b	0
   3089  7031					      repend
   3090  7032		       00		      .byte.b	0
   3089  7032					      repend
   3090  7033		       00		      .byte.b	0
   3089  7033					      repend
   3090  7034		       00		      .byte.b	0
   3089  7034					      repend
   3090  7035		       00		      .byte.b	0
   3089  7035					      repend
   3090  7036		       00		      .byte.b	0
   3089  7036					      repend
   3090  7037		       00		      .byte.b	0
   3089  7037					      repend
   3090  7038		       00		      .byte.b	0
   3089  7038					      repend
   3090  7039		       00		      .byte.b	0
   3089  7039					      repend
   3090  703a		       00		      .byte.b	0
   3089  703a					      repend
   3090  703b		       00		      .byte.b	0
   3089  703b					      repend
   3090  703c		       00		      .byte.b	0
   3089  703c					      repend
   3090  703d		       00		      .byte.b	0
   3089  703d					      repend
   3090  703e		       00		      .byte.b	0
   3089  703e					      repend
   3090  703f		       00		      .byte.b	0
   3089  703f					      repend
   3090  7040		       00		      .byte.b	0
   3089  7040					      repend
   3090  7041		       00		      .byte.b	0
   3089  7041					      repend
   3090  7042		       00		      .byte.b	0
   3089  7042					      repend
   3090  7043		       00		      .byte.b	0
   3089  7043					      repend
   3090  7044		       00		      .byte.b	0
   3089  7044					      repend
   3090  7045		       00		      .byte.b	0
   3089  7045					      repend
   3090  7046		       00		      .byte.b	0
   3089  7046					      repend
   3090  7047		       00		      .byte.b	0
   3089  7047					      repend
   3090  7048		       00		      .byte.b	0
   3089  7048					      repend
   3090  7049		       00		      .byte.b	0
   3089  7049					      repend
   3090  704a		       00		      .byte.b	0
   3089  704a					      repend
   3090  704b		       00		      .byte.b	0
   3089  704b					      repend
   3090  704c		       00		      .byte.b	0
   3089  704c					      repend
   3090  704d		       00		      .byte.b	0
   3089  704d					      repend
   3090  704e		       00		      .byte.b	0
   3089  704e					      repend
   3090  704f		       00		      .byte.b	0
   3089  704f					      repend
   3090  7050		       00		      .byte.b	0
   3089  7050					      repend
   3090  7051		       00		      .byte.b	0
   3089  7051					      repend
   3090  7052		       00		      .byte.b	0
   3089  7052					      repend
   3090  7053		       00		      .byte.b	0
   3089  7053					      repend
   3090  7054		       00		      .byte.b	0
   3089  7054					      repend
   3090  7055		       00		      .byte.b	0
   3089  7055					      repend
   3090  7056		       00		      .byte.b	0
   3089  7056					      repend
   3090  7057		       00		      .byte.b	0
   3089  7057					      repend
   3090  7058		       00		      .byte.b	0
   3089  7058					      repend
   3090  7059		       00		      .byte.b	0
   3089  7059					      repend
   3090  705a		       00		      .byte.b	0
   3089  705a					      repend
   3090  705b		       00		      .byte.b	0
   3089  705b					      repend
   3090  705c		       00		      .byte.b	0
   3089  705c					      repend
   3090  705d		       00		      .byte.b	0
   3089  705d					      repend
   3090  705e		       00		      .byte.b	0
   3089  705e					      repend
   3090  705f		       00		      .byte.b	0
   3089  705f					      repend
   3090  7060		       00		      .byte.b	0
   3089  7060					      repend
   3090  7061		       00		      .byte.b	0
   3089  7061					      repend
   3090  7062		       00		      .byte.b	0
   3089  7062					      repend
   3090  7063		       00		      .byte.b	0
   3089  7063					      repend
   3090  7064		       00		      .byte.b	0
   3089  7064					      repend
   3090  7065		       00		      .byte.b	0
   3089  7065					      repend
   3090  7066		       00		      .byte.b	0
   3089  7066					      repend
   3090  7067		       00		      .byte.b	0
   3089  7067					      repend
   3090  7068		       00		      .byte.b	0
   3089  7068					      repend
   3090  7069		       00		      .byte.b	0
   3089  7069					      repend
   3090  706a		       00		      .byte.b	0
   3089  706a					      repend
   3090  706b		       00		      .byte.b	0
   3089  706b					      repend
   3090  706c		       00		      .byte.b	0
   3089  706c					      repend
   3090  706d		       00		      .byte.b	0
   3089  706d					      repend
   3090  706e		       00		      .byte.b	0
   3089  706e					      repend
   3090  706f		       00		      .byte.b	0
   3089  706f					      repend
   3090  7070		       00		      .byte.b	0
   3089  7070					      repend
   3090  7071		       00		      .byte.b	0
   3089  7071					      repend
   3090  7072		       00		      .byte.b	0
   3089  7072					      repend
   3090  7073		       00		      .byte.b	0
   3089  7073					      repend
   3090  7074		       00		      .byte.b	0
   3089  7074					      repend
   3090  7075		       00		      .byte.b	0
   3089  7075					      repend
   3090  7076		       00		      .byte.b	0
   3089  7076					      repend
   3090  7077		       00		      .byte.b	0
   3089  7077					      repend
   3090  7078		       00		      .byte.b	0
   3089  7078					      repend
   3090  7079		       00		      .byte.b	0
   3089  7079					      repend
   3090  707a		       00		      .byte.b	0
   3089  707a					      repend
   3090  707b		       00		      .byte.b	0
   3089  707b					      repend
   3090  707c		       00		      .byte.b	0
   3089  707c					      repend
   3090  707d		       00		      .byte.b	0
   3089  707d					      repend
   3090  707e		       00		      .byte.b	0
   3089  707e					      repend
   3090  707f		       00		      .byte.b	0
   3089  707f					      repend
   3090  7080		       00		      .byte.b	0
   3091  7081					      repend
   3092  7081							;----------------------------------------
   3093  7081							; Display Data
   3094  7081							;----------------------------------------
   3095  7081							; The Display Data bank is copied into RAM when DPC+ initializes the cartridge.
   3096  7081							; This allows us to manipulate the data during run-time, but have a known
   3097  7081							; starting state when the Atari is first turned on.
   3098  7081							;
   3099  7081							; Unlike normal Atari VCS/2600 sprite definitions, the sprite data in the
   3100  7081							; Display Data bank is stored right-side-up.
   3101  7081							;
   3102  7081							;----------------------------------------
   3103  7081
   3104  7081				   Zeros32
   3105  7081		       00 84	   SOUND_OFF  =	(* & $1fff)/32
   3106  7081				   DisplayDataDigitBlank
   3107  7081		       00		      .byte.b	0	;--
   3108  7082		       00		      .byte.b	0	;--
   3109  7083		       00		      .byte.b	0	;--
   3110  7084		       00		      .byte.b	0	;--
   3111  7085		       00		      .byte.b	0	;--
   3112  7086		       00		      .byte.b	0	;--
   3113  7087		       00		      .byte.b	0	;--
   3114  7088		       00		      .byte.b	0	;--
   3115  7089
   3116  7089							;	align 32
   3117  7089							;Zeros32:
   3118  7089							;SOUND_OFF = (* & $1fff)/32
   3119  7089							;	.byte 0,0,0,0,0,0,0,0
   3120  7089		       00 00 00 00*	      .byte.b	0,0,0,0,0,0,0,0
   3121  7091		       00 00 00 00*	      .byte.b	0,0,0,0,0,0,0,0
   3122  7099		       00 00 00 00*	      .byte.b	0,0,0,0,0,0,0,0
   3123  70a1
   3124  70a1		       00 85	   SINE_WAVE  =	(* & $1fff)/32
   3125  70a1		       03 03 03 04*	      .byte.b	3,3,3,4,4,5,5,5
   3126  70a9		       05 05 05 05*	      .byte.b	5,5,5,5,4,4,3,3
   3127  70b1		       03 02 02 01*	      .byte.b	3,2,2,1,1,0,0,0
   3128  70b9		       00 00 00 00*	      .byte.b	0,0,0,0,1,1,2,2
   3129  70c1
   3130  70e0		       00 00 00 00*	      align	32
   3131  70e0		       00 87	   TRIANGLE_WAVE =	(* & $1fff)/32
   3132  70e0		       00 00 01 01*	      .byte.b	0,0,1,1,1,2,2,2
   3133  70e8		       03 03 03 04*	      .byte.b	3,3,3,4,4,4,5,5
   3134  70f0		       05 05 04 04*	      .byte.b	5,5,4,4,4,3,3,3
   3135  70f8		       02 02 02 01*	      .byte.b	2,2,2,1,1,1,0,0
   3136  7100
   3137  7100					      align	32
   3138  7100		       00 88	   SAWTOOTH_WAVE =	(* & $1fff)/32
   3139  7100		       00 00 00 00*	      .byte.b	0,0,0,0,1,1,1,1
   3140  7108		       01 01 02 02*	      .byte.b	1,1,2,2,2,2,2,2
   3141  7110		       03 03 03 03*	      .byte.b	3,3,3,3,3,3,4,4
   3142  7118		       04 04 04 04*	      .byte.b	4,4,4,4,5,5,5,5
   3143  7120
   3144  7120					      align	32
   3145  7120		       00 89	   SQUARE_WAVE_VOL5 =	(* & $1fff)/32
   3146  7120		       00 00 00 00*	      .byte.b	0,0,0,0,0,0,0,0
   3147  7128		       00 00 00 00*	      .byte.b	0,0,0,0,0,0,0,0
   3148  7130		       05 05 05 05*	      .byte.b	5,5,5,5,5,5,5,5
   3149  7138		       05 05 05 05*	      .byte.b	5,5,5,5,5,5,5,5
   3150  7140
   3151  7140					      align	32
   3152  7140		       00 8a	   SQUARE_WAVE_VOL4 =	(* & $1fff)/32
   3153  7140		       00 00 00 00*	      .byte.b	0,0,0,0,0,0,0,0
   3154  7148		       00 00 00 00*	      .byte.b	0,0,0,0,0,0,0,0
   3155  7150		       04 04 04 04*	      .byte.b	4,4,4,4,4,4,4,4
   3156  7158		       04 04 04 04*	      .byte.b	4,4,4,4,4,4,4,4
   3157  7160
   3158  7160					      align	32
   3159  7160		       00 8b	   SQUARE_WAVE_VOL3 =	(* & $1fff)/32
   3160  7160		       00 00 00 00*	      .byte.b	0,0,0,0,0,0,0,0
   3161  7168		       00 00 00 00*	      .byte.b	0,0,0,0,0,0,0,0
   3162  7170		       03 03 03 03*	      .byte.b	3,3,3,3,3,3,3,3
   3163  7178		       03 03 03 03*	      .byte.b	3,3,3,3,3,3,3,3
   3164  7180
   3165  7180					      align	32
   3166  7180		       00 8c	   NOISE_WAVE =	(* & $1fff)/32
   3167  7180		       07 01 09 0a*	      .byte.b	7, 1, 9,10, 2, 8, 8,14
   3168  7188		       03 0d 08 05*	      .byte.b	3,13, 8, 5,12, 2, 3, 7
   3169  7190		       07 01 08 04*	      .byte.b	7, 1, 8, 4,15, 1,13, 5
   3170  7198		       08 05 0b 06*	      .byte.b	8, 5,11, 6, 8, 7, 9, 2
   3171  71a0
   3172  71a0							; low and high byte of address table (for ROMdata array in C)
   3173  71a0		       56		      .byte.b	<fetcher_address_table
   3174  71a1		       0d		      .byte.b	((>fetcher_address_table) & $0f) | (((>fetcher_address_table) / 2) & $70)
   3175  71a2		       00		      .byte.b	0
   3176  71a3		       00		      .byte.b	0
   3177  71a4				   FETCHER_BEGIN
   3178  71a4		       10		      .byte.b	16
   3179  71a5		       10		      .byte.b	16
   3180  71a6		       10		      .byte.b	16
   3181  71a7		       10		      .byte.b	16	; to zero-fill on boot
   3182  71a8							;bB.asm
   3183  71a8							; bB.asm file is split here
   3184  71a8				   playfieldcolorL077
   3185  71a8		       3c		      .byte.b	$3c
   3186  71a9				   backgroundcolorL078
   3187  71a9		       00		      .byte.b	$00
   3188  71aa				   PF_data1
   3189  71aa		       00		      .byte.b	%00000000
   3190  71ab		       00		      .byte.b	%00000000
   3191  71ac		       00		      .byte.b	%00000000
   3192  71ad		       00		      .byte.b	%00000000
   3193  71ae		       00		      .byte.b	%00000000
   3194  71af		       00		      .byte.b	%00000000
   3195  71b0		       00		      .byte.b	%00000000
   3196  71b1		       00		      .byte.b	%00000000
   3197  71b2		       00		      .byte.b	%00000000
   3198  71b3		       00		      .byte.b	%00000000
   3199  71b4		       00		      .byte.b	%00000000
   3200  71b5		       00		      .byte.b	%00000000
   3201  71b6		       00		      .byte.b	%00000000
   3202  71b7		       00		      .byte.b	%00000000
   3203  71b8		       00		      .byte.b	%00000000
   3204  71b9		       00		      .byte.b	%00000000
   3205  71ba		       00		      .byte.b	%00000000
   3206  71bb		       00		      .byte.b	%00000000
   3207  71bc		       00		      .byte.b	%00000000
   3208  71bd		       00		      .byte.b	%00000000
   3209  71be		       00		      .byte.b	%00000000
   3210  71bf		       00		      .byte.b	%00000000
   3211  71c0		       00		      .byte.b	%00000000
   3212  71c1		       00		      .byte.b	%00000000
   3213  71c2		       00		      .byte.b	%00000000
   3214  71c3		       00		      .byte.b	%00000000
   3215  71c4		       00		      .byte.b	%00000000
   3216  71c5		       00		      .byte.b	%00000000
   3217  71c6		       00		      .byte.b	%00000000
   3218  71c7		       00		      .byte.b	%00000000
   3219  71c8		       00		      .byte.b	%00000000
   3220  71c9		       00		      .byte.b	%00000000
   3221  71ca		       00		      .byte.b	%00000000
   3222  71cb		       00		      .byte.b	%00000000
   3223  71cc		       00		      .byte.b	%00000000
   3224  71cd		       00		      .byte.b	%00000000
   3225  71ce		       00		      .byte.b	%00000000
   3226  71cf		       10		      .byte.b	%00010000
   3227  71d0		       20		      .byte.b	%00100000
   3228  71d1		       38		      .byte.b	%00111000
   3229  71d2		       00		      .byte.b	%00000000
   3230  71d3		       00		      .byte.b	%00000000
   3231  71d4		       00		      .byte.b	%00000000
   3232  71d5		       00		      .byte.b	%00000000
   3233  71d6		       00		      .byte.b	%00000000
   3234  71d7		       00		      .byte.b	%00000000
   3235  71d8		       00		      .byte.b	%00000000
   3236  71d9		       00		      .byte.b	%00000000
   3237  71da		       00		      .byte.b	%00000000
   3238  71db		       00		      .byte.b	%00000000
   3239  71dc		       00		      .byte.b	%00000000
   3240  71dd		       00		      .byte.b	%00000000
   3241  71de		       00		      .byte.b	%00000000
   3242  71df		       00		      .byte.b	%00000000
   3243  71e0		       00		      .byte.b	%00000000
   3244  71e1		       00		      .byte.b	%00000000
   3245  71e2		       00		      .byte.b	%00000000
   3246  71e3		       00		      .byte.b	%00000000
   3247  71e4		       00		      .byte.b	%00000000
   3248  71e5		       00		      .byte.b	%00000000
   3249  71e6		       00		      .byte.b	%00000000
   3250  71e7		       00		      .byte.b	%00000000
   3251  71e8		       00		      .byte.b	%00000000
   3252  71e9		       00		      .byte.b	%00000000
   3253  71ea		       00		      .byte.b	%00000000
   3254  71eb		       00		      .byte.b	%00000000
   3255  71ec		       00		      .byte.b	%00000000
   3256  71ed		       00		      .byte.b	%00000000
   3257  71ee				   PF_data2
   3258  71ee		       00		      .byte.b	%00000000
   3259  71ef		       00		      .byte.b	%00000000
   3260  71f0		       00		      .byte.b	%00000000
   3261  71f1		       00		      .byte.b	%00000000
   3262  71f2		       00		      .byte.b	%00000000
   3263  71f3		       00		      .byte.b	%00000000
   3264  71f4		       00		      .byte.b	%00000000
   3265  71f5		       00		      .byte.b	%00000000
   3266  71f6		       00		      .byte.b	%00000000
   3267  71f7		       00		      .byte.b	%00000000
   3268  71f8		       00		      .byte.b	%00000000
   3269  71f9		       00		      .byte.b	%00000000
   3270  71fa		       00		      .byte.b	%00000000
   3271  71fb		       00		      .byte.b	%00000000
   3272  71fc		       00		      .byte.b	%00000000
   3273  71fd		       00		      .byte.b	%00000000
   3274  71fe		       00		      .byte.b	%00000000
   3275  71ff		       00		      .byte.b	%00000000
   3276  7200		       00		      .byte.b	%00000000
   3277  7201		       00		      .byte.b	%00000000
   3278  7202		       00		      .byte.b	%00000000
   3279  7203		       00		      .byte.b	%00000000
   3280  7204		       00		      .byte.b	%00000000
   3281  7205		       00		      .byte.b	%00000000
   3282  7206		       00		      .byte.b	%00000000
   3283  7207		       00		      .byte.b	%00000000
   3284  7208		       00		      .byte.b	%00000000
   3285  7209		       00		      .byte.b	%00000000
   3286  720a		       15		      .byte.b	%00010101
   3287  720b		       11		      .byte.b	%00010001
   3288  720c		       11		      .byte.b	%00010001
   3289  720d		       11		      .byte.b	%00010001
   3290  720e		       15		      .byte.b	%00010101
   3291  720f		       00		      .byte.b	%00000000
   3292  7210		       00		      .byte.b	%00000000
   3293  7211		       00		      .byte.b	%00000000
   3294  7212		       00		      .byte.b	%00000000
   3295  7213		       00		      .byte.b	%00000000
   3296  7214		       00		      .byte.b	%00000000
   3297  7215		       00		      .byte.b	%00000000
   3298  7216		       00		      .byte.b	%00000000
   3299  7217		       00		      .byte.b	%00000000
   3300  7218		       00		      .byte.b	%00000000
   3301  7219		       00		      .byte.b	%00000000
   3302  721a		       00		      .byte.b	%00000000
   3303  721b		       00		      .byte.b	%00000000
   3304  721c		       00		      .byte.b	%00000000
   3305  721d		       00		      .byte.b	%00000000
   3306  721e		       00		      .byte.b	%00000000
   3307  721f		       00		      .byte.b	%00000000
   3308  7220		       00		      .byte.b	%00000000
   3309  7221		       00		      .byte.b	%00000000
   3310  7222		       00		      .byte.b	%00000000
   3311  7223		       00		      .byte.b	%00000000
   3312  7224		       02		      .byte.b	%00000010
   3313  7225		       07		      .byte.b	%00000111
   3314  7226		       05		      .byte.b	%00000101
   3315  7227		       02		      .byte.b	%00000010
   3316  7228		       00		      .byte.b	%00000000
   3317  7229		       00		      .byte.b	%00000000
   3318  722a		       00		      .byte.b	%00000000
   3319  722b		       00		      .byte.b	%00000000
   3320  722c		       00		      .byte.b	%00000000
   3321  722d		       00		      .byte.b	%00000000
   3322  722e		       00		      .byte.b	%00000000
   3323  722f		       00		      .byte.b	%00000000
   3324  7230		       00		      .byte.b	%00000000
   3325  7231		       00		      .byte.b	%00000000
   3326  7232				   PF_data3
   3327  7232		       00		      .byte.b	%00000000
   3328  7233		       00		      .byte.b	%00000000
   3329  7234		       00		      .byte.b	%00000000
   3330  7235		       00		      .byte.b	%00000000
   3331  7236		       00		      .byte.b	%00000000
   3332  7237		       00		      .byte.b	%00000000
   3333  7238		       00		      .byte.b	%00000000
   3334  7239		       00		      .byte.b	%00000000
   3335  723a		       00		      .byte.b	%00000000
   3336  723b		       00		      .byte.b	%00000000
   3337  723c		       00		      .byte.b	%00000000
   3338  723d		       00		      .byte.b	%00000000
   3339  723e		       00		      .byte.b	%00000000
   3340  723f		       00		      .byte.b	%00000000
   3341  7240		       00		      .byte.b	%00000000
   3342  7241		       00		      .byte.b	%00000000
   3343  7242		       00		      .byte.b	%00000000
   3344  7243		       00		      .byte.b	%00000000
   3345  7244		       00		      .byte.b	%00000000
   3346  7245		       00		      .byte.b	%00000000
   3347  7246		       00		      .byte.b	%00000000
   3348  7247		       00		      .byte.b	%00000000
   3349  7248		       00		      .byte.b	%00000000
   3350  7249		       00		      .byte.b	%00000000
   3351  724a		       00		      .byte.b	%00000000
   3352  724b		       00		      .byte.b	%00000000
   3353  724c		       00		      .byte.b	%00000000
   3354  724d		       00		      .byte.b	%00000000
   3355  724e		       00		      .byte.b	%00000000
   3356  724f		       08		      .byte.b	%00001000
   3357  7250		       1c		      .byte.b	%00011100
   3358  7251		       14		      .byte.b	%00010100
   3359  7252		       08		      .byte.b	%00001000
   3360  7253		       00		      .byte.b	%00000000
   3361  7254		       00		      .byte.b	%00000000
   3362  7255		       00		      .byte.b	%00000000
   3363  7256		       00		      .byte.b	%00000000
   3364  7257		       10		      .byte.b	%00010000
   3365  7258		       20		      .byte.b	%00100000
   3366  7259		       38		      .byte.b	%00111000
   3367  725a		       00		      .byte.b	%00000000
   3368  725b		       00		      .byte.b	%00000000
   3369  725c		       00		      .byte.b	%00000000
   3370  725d		       00		      .byte.b	%00000000
   3371  725e		       00		      .byte.b	%00000000
   3372  725f		       00		      .byte.b	%00000000
   3373  7260		       00		      .byte.b	%00000000
   3374  7261		       00		      .byte.b	%00000000
   3375  7262		       00		      .byte.b	%00000000
   3376  7263		       00		      .byte.b	%00000000
   3377  7264		       00		      .byte.b	%00000000
   3378  7265		       00		      .byte.b	%00000000
   3379  7266		       00		      .byte.b	%00000000
   3380  7267		       00		      .byte.b	%00000000
   3381  7268		       00		      .byte.b	%00000000
   3382  7269		       00		      .byte.b	%00000000
   3383  726a		       00		      .byte.b	%00000000
   3384  726b		       00		      .byte.b	%00000000
   3385  726c		       00		      .byte.b	%00000000
   3386  726d		       00		      .byte.b	%00000000
   3387  726e		       00		      .byte.b	%00000000
   3388  726f		       00		      .byte.b	%00000000
   3389  7270		       00		      .byte.b	%00000000
   3390  7271		       00		      .byte.b	%00000000
   3391  7272		       00		      .byte.b	%00000000
   3392  7273		       00		      .byte.b	%00000000
   3393  7274		       00		      .byte.b	%00000000
   3394  7275		       00		      .byte.b	%00000000
   3395  7276				   PF_data4
   3396  7276		       00		      .byte.b	%00000000
   3397  7277		       00		      .byte.b	%00000000
   3398  7278		       00		      .byte.b	%00000000
   3399  7279		       00		      .byte.b	%00000000
   3400  727a		       00		      .byte.b	%00000000
   3401  727b		       00		      .byte.b	%00000000
   3402  727c		       00		      .byte.b	%00000000
   3403  727d		       00		      .byte.b	%00000000
   3404  727e		       00		      .byte.b	%00000000
   3405  727f		       00		      .byte.b	%00000000
   3406  7280		       00		      .byte.b	%00000000
   3407  7281		       00		      .byte.b	%00000000
   3408  7282		       00		      .byte.b	%00000000
   3409  7283		       00		      .byte.b	%00000000
   3410  7284		       00		      .byte.b	%00000000
   3411  7285		       00		      .byte.b	%00000000
   3412  7286		       00		      .byte.b	%00000000
   3413  7287		       00		      .byte.b	%00000000
   3414  7288		       00		      .byte.b	%00000000
   3415  7289		       00		      .byte.b	%00000000
   3416  728a		       00		      .byte.b	%00000000
   3417  728b		       00		      .byte.b	%00000000
   3418  728c		       00		      .byte.b	%00000000
   3419  728d		       00		      .byte.b	%00000000
   3420  728e		       00		      .byte.b	%00000000
   3421  728f		       00		      .byte.b	%00000000
   3422  7290		       00		      .byte.b	%00000000
   3423  7291		       00		      .byte.b	%00000000
   3424  7292		       00		      .byte.b	%00000000
   3425  7293		       00		      .byte.b	%00000000
   3426  7294		       00		      .byte.b	%00000000
   3427  7295		       00		      .byte.b	%00000000
   3428  7296		       00		      .byte.b	%00000000
   3429  7297		       00		      .byte.b	%00000000
   3430  7298		       00		      .byte.b	%00000000
   3431  7299		       00		      .byte.b	%00000000
   3432  729a		       00		      .byte.b	%00000000
   3433  729b		       00		      .byte.b	%00000000
   3434  729c		       00		      .byte.b	%00000000
   3435  729d		       00		      .byte.b	%00000000
   3436  729e		       00		      .byte.b	%00000000
   3437  729f		       00		      .byte.b	%00000000
   3438  72a0		       00		      .byte.b	%00000000
   3439  72a1		       00		      .byte.b	%00000000
   3440  72a2		       00		      .byte.b	%00000000
   3441  72a3		       00		      .byte.b	%00000000
   3442  72a4		       00		      .byte.b	%00000000
   3443  72a5		       00		      .byte.b	%00000000
   3444  72a6		       00		      .byte.b	%00000000
   3445  72a7		       00		      .byte.b	%00000000
   3446  72a8		       00		      .byte.b	%00000000
   3447  72a9		       00		      .byte.b	%00000000
   3448  72aa		       00		      .byte.b	%00000000
   3449  72ab		       00		      .byte.b	%00000000
   3450  72ac		       00		      .byte.b	%00000000
   3451  72ad		       00		      .byte.b	%00000000
   3452  72ae		       00		      .byte.b	%00000000
   3453  72af		       3c		      .byte.b	%00111100
   3454  72b0		       44		      .byte.b	%01000100
   3455  72b1		       04		      .byte.b	%00000100
   3456  72b2		       48		      .byte.b	%01001000
   3457  72b3		       00		      .byte.b	%00000000
   3458  72b4		       00		      .byte.b	%00000000
   3459  72b5		       00		      .byte.b	%00000000
   3460  72b6		       00		      .byte.b	%00000000
   3461  72b7		       00		      .byte.b	%00000000
   3462  72b8		       00		      .byte.b	%00000000
   3463  72b9		       00		      .byte.b	%00000000
   3464  72ba					      if	ECHOFIRST
      3354 bytes of ROM space left in graphics bank
   3465  72ba					      echo	"    ",[(DPC_graphics_end - *)]d , "bytes of ROM space left in graphics bank")
   3466  72ba					      endif
   3467  72ba		       00 01	   ECHOFIRST  =	1
   3468  72ba
   3469  72ba
   3470  7fd4					      ORG	$7FF4-bscode_length
   3471  7fd4					      RORG	$DFF4-bscode_length
   3472  7fd4				   DPC_graphics_end
   3473  7fd4
   3474  7fd4							; every bank has this stuff at the same place
   3475  7fd4							; this code can switch to/from any bank at any entry point
   3476  7fd4							; and can preserve register values
   3477  7fd4							; note: lines not starting with a space are not placed in all banks
   3478  7fd4							;
   3479  7fd4							; line below tells the compiler how long this is - do not remove
   3480  7fd4							;size=32
   3481  7fd4
   3482  7fd4				   begin_bscode
   3483  7fd4		       a2 ff		      ldx	#$ff
   3484  7fd6					      ifconst	FASTFETCH	; using DPC+
   3485  7fd6		       8e 58 10 	      stx	FASTFETCH
   3486  7fd9					      endif
   3487  7fd9		       9a		      txs
   3488  7fda				  -	      if	bankswitch == 64
   3489  7fda				  -	      lda	#(((>(start-1)) & $0F) | $F0)
   3490  7fda					      else
   3491  7fda		       a9 18		      lda	#>(start-1)
   3492  7fdc					      endif
   3493  7fdc		       48		      pha
   3494  7fdd		       a9 eb		      lda	#<(start-1)
   3495  7fdf		       48		      pha
   3496  7fe0
   3497  7fe0				   BS_return
   3498  7fe0		       48		      pha
   3499  7fe1		       8a		      txa
   3500  7fe2		       48		      pha
   3501  7fe3		       ba		      tsx
   3502  7fe4
   3503  7fe4					      if	bankswitch != 64
   3504  7fe4		       b5 04		      lda	4,x	; get high byte of return address
   3505  7fe6
   3506  7fe6		       2a		      rol
   3507  7fe7		       2a		      rol
   3508  7fe8		       2a		      rol
   3509  7fe9		       2a		      rol
   3510  7fea		       29 07		      and	#bs_mask	;1 3 or 7 for F8/F6/F4
   3511  7fec		       aa		      tax
   3512  7fed		       e8		      inx
   3513  7fee				  -	      else
   3514  7fee				  -	      lda	4,x	; get high byte of return address
   3515  7fee				  -	      tay
   3516  7fee				  -	      ora	#$10	; change our bank nibble into a valid rom mirror
   3517  7fee				  -	      sta	4,x
   3518  7fee				  -	      tya
   3519  7fee				  -	      lsr
   3520  7fee				  -	      lsr
   3521  7fee				  -	      lsr
   3522  7fee				  -	      lsr
   3523  7fee				  -	      tax
   3524  7fee				  -	      inx
   3525  7fee					      endif
   3526  7fee
   3527  7fee				   BS_jsr
   3528  7fee		       bd f5 1f 	      lda	bankswitch_hotspot-1,x
   3529  7ff1		       68		      pla
   3530  7ff2		       aa		      tax
   3531  7ff3		       68		      pla
   3532  7ff4		       60		      rts
   3533  7ff5				  -	      if	((* & $1FFF) > ((bankswitch_hotspot & $1FFF) - 1))
   3534  7ff5				  -	      echo	"WARNING: size parameter in banksw.asm too small - the program probably will not work."
   3535  7ff5				  -	      echo	"Change to",[(*-begin_bscode+1)&$FF]d,"and try again."
   3536  7ff5					      endif
   3537  8000					      org	$8000
   3538  8000					      rorg	$1000
   3539  8000							; 1K Frequency Table.
   3540  8000							; Fred Quimby, Darrell Spice Jr, Chris Walton 2010
   3541  8000							;
   3542  8000							; The 1K Frequency Table can contain up to 256 frequency values
   3543  8000							;
   3544  8000							; Table entries are defined as 2^32*freq/20000
   3545  8000							;
   3546  8000							; If User ARM code is being used, then the last 512 bytes of the frequency
   3547  8000							; table will no longer be available, reducing the number of frequencies you can
   3548  8000							; use to 128.
   3549  8000
   3550  8000							; piano key frequencies (s = sharp)
   3551  8000
   3552  8000				   .freq_table_start
   3553  8000
   3554  8000		       00 00 00 00	      DC.L	0
   3555  8000		       00 01	   A0	      =	(* & $3ff)/4
   3556  8004		       ac 1c 5a 00	      DC.L	5905580
   3557  8008
   3558  8008		       00 02	   A0s	      =	(* & $3ff)/4
   3559  8008		       68 78 5f 00	      DC.L	6256744
   3560  800c
   3561  800c		       00 03	   B0	      =	(* & $3ff)/4
   3562  800c		       b5 25 65 00	      DC.L	6628789
   3563  8010
   3564  8010		       00 04	   C1	      =	(* & $3ff)/4
   3565  8010		       6e 29 6b 00	      DC.L	7022958
   3566  8014
   3567  8014		       00 05	   C1s	      =	(* & $3ff)/4
   3568  8014		       b5 88 71 00	      DC.L	7440565
   3569  8018
   3570  8018		       00 06	   D1	      =	(* & $3ff)/4
   3571  8018		       fc 48 78 00	      DC.L	7883004
   3572  801c
   3573  801c		       00 07	   D1s	      =	(* & $3ff)/4
   3574  801c		       07 70 7f 00	      DC.L	8351751
   3575  8020
   3576  8020		       00 08	   E1	      =	(* & $3ff)/4
   3577  8020		       f4 03 87 00	      DC.L	8848372
   3578  8024
   3579  8024		       00 09	   F1	      =	(* & $3ff)/4
   3580  8024		       3c 0b 8f 00	      DC.L	9374524
   3581  8028
   3582  8028		       00 0a	   F1s	      =	(* & $3ff)/4
   3583  8028		       ba 8c 97 00	      DC.L	9931962
   3584  802c
   3585  802c		       00 0b	   G1	      =	(* & $3ff)/4
   3586  802c		       b3 8f a0 00	      DC.L	10522547
   3587  8030
   3588  8030		       00 0c	   G1s	      =	(* & $3ff)/4
   3589  8030		       db 1b aa 00	      DC.L	11148251
   3590  8034
   3591  8034		       00 0d	   A1	      =	(* & $3ff)/4
   3592  8034		       58 39 b4 00	      DC.L	11811160
   3593  8038
   3594  8038		       00 0e	   A1s	      =	(* & $3ff)/4
   3595  8038		       d0 f0 be 00	      DC.L	12513488
   3596  803c
   3597  803c		       00 0f	   B1	      =	(* & $3ff)/4
   3598  803c		       6b 4b ca 00	      DC.L	13257579
   3599  8040
   3600  8040		       00 10	   C2	      =	(* & $3ff)/4
   3601  8040		       dc 52 d6 00	      DC.L	14045916
   3602  8044
   3603  8044		       00 11	   C2s	      =	(* & $3ff)/4
   3604  8044		       69 11 e3 00	      DC.L	14881129
   3605  8048
   3606  8048		       00 12	   D2	      =	(* & $3ff)/4
   3607  8048		       f7 91 f0 00	      DC.L	15766007
   3608  804c
   3609  804c		       00 13	   D2s	      =	(* & $3ff)/4
   3610  804c		       0f e0 fe 00	      DC.L	16703503
   3611  8050
   3612  8050		       00 14	   E2	      =	(* & $3ff)/4
   3613  8050		       e9 07 0e 01	      DC.L	17696745
   3614  8054
   3615  8054		       00 15	   F2	      =	(* & $3ff)/4
   3616  8054		       78 16 1e 01	      DC.L	18749048
   3617  8058
   3618  8058		       00 16	   F2s	      =	(* & $3ff)/4
   3619  8058		       74 19 2f 01	      DC.L	19863924
   3620  805c
   3621  805c		       00 17	   G2	      =	(* & $3ff)/4
   3622  805c		       67 1f 41 01	      DC.L	21045095
   3623  8060
   3624  8060		       00 18	   G2s	      =	(* & $3ff)/4
   3625  8060		       b5 37 54 01	      DC.L	22296501
   3626  8064
   3627  8064		       00 19	   A2	      =	(* & $3ff)/4
   3628  8064		       b0 72 68 01	      DC.L	23622320
   3629  8068
   3630  8068		       00 1a	   A2s	      =	(* & $3ff)/4
   3631  8068		       a0 e1 7d 01	      DC.L	25026976
   3632  806c
   3633  806c		       00 1b	   B2	      =	(* & $3ff)/4
   3634  806c		       d6 96 94 01	      DC.L	26515158
   3635  8070
   3636  8070		       00 1c	   C3	      =	(* & $3ff)/4
   3637  8070		       b7 a5 ac 01	      DC.L	28091831
   3638  8074
   3639  8074		       00 1d	   C3s	      =	(* & $3ff)/4
   3640  8074		       d2 22 c6 01	      DC.L	29762258
   3641  8078
   3642  8078		       00 1e	   D3	      =	(* & $3ff)/4
   3643  8078		       ee 23 e1 01	      DC.L	31532014
   3644  807c
   3645  807c		       00 1f	   D3s	      =	(* & $3ff)/4
   3646  807c		       1d c0 fd 01	      DC.L	33407005
   3647  8080
   3648  8080		       00 20	   E3	      =	(* & $3ff)/4
   3649  8080		       d1 0f 1c 02	      DC.L	35393489
   3650  8084
   3651  8084		       00 21	   F3	      =	(* & $3ff)/4
   3652  8084		       f0 2c 3c 02	      DC.L	37498096
   3653  8088
   3654  8088		       00 22	   F3s	      =	(* & $3ff)/4
   3655  8088		       e9 32 5e 02	      DC.L	39727849
   3656  808c
   3657  808c		       00 23	   G3	      =	(* & $3ff)/4
   3658  808c		       cd 3e 82 02	      DC.L	42090189
   3659  8090
   3660  8090		       00 24	   G3s	      =	(* & $3ff)/4
   3661  8090		       6a 6f a8 02	      DC.L	44593002
   3662  8094
   3663  8094		       00 25	   A3	      =	(* & $3ff)/4
   3664  8094		       60 e5 d0 02	      DC.L	47244640
   3665  8098
   3666  8098		       00 26	   A3s	      =	(* & $3ff)/4
   3667  8098		       41 c3 fb 02	      DC.L	50053953
   3668  809c
   3669  809c		       00 27	   B3	      =	(* & $3ff)/4
   3670  809c		       ac 2d 29 03	      DC.L	53030316
   3671  80a0
   3672  80a0		       00 28	   C4	      =	(* & $3ff)/4
   3673  80a0		       6e 4b 59 03	      DC.L	56183662
   3674  80a4
   3675  80a4		       00 29	   C4s	      =	(* & $3ff)/4
   3676  80a4		       a5 45 8c 03	      DC.L	59524517
   3677  80a8
   3678  80a8		       00 2a	   D4	      =	(* & $3ff)/4
   3679  80a8		       dd 47 c2 03	      DC.L	63064029
   3680  80ac
   3681  80ac		       00 2b	   D4s	      =	(* & $3ff)/4
   3682  80ac		       3b 80 fb 03	      DC.L	66814011
   3683  80b0
   3684  80b0		       00 2c	   E4	      =	(* & $3ff)/4
   3685  80b0		       a3 1f 38 04	      DC.L	70786979
   3686  80b4
   3687  80b4		       00 2d	   F4	      =	(* & $3ff)/4
   3688  80b4		       e0 59 78 04	      DC.L	74996192
   3689  80b8
   3690  80b8		       00 2e	   F4s	      =	(* & $3ff)/4
   3691  80b8		       d1 65 bc 04	      DC.L	79455697
   3692  80bc
   3693  80bc		       00 2f	   G4	      =	(* & $3ff)/4
   3694  80bc		       9b 7d 04 05	      DC.L	84180379
   3695  80c0
   3696  80c0		       00 30	   G4s	      =	(* & $3ff)/4
   3697  80c0		       d5 de 50 05	      DC.L	89186005
   3698  80c4
   3699  80c4		       00 31	   A4	      =	(* & $3ff)/4
   3700  80c4		       c1 ca a1 05	      DC.L	94489281
   3701  80c8
   3702  80c8		       00 32	   A4s	      =	(* & $3ff)/4
   3703  80c8		       82 86 f7 05	      DC.L	100107906
   3704  80cc
   3705  80cc		       00 33	   B4	      =	(* & $3ff)/4
   3706  80cc		       57 5b 52 06	      DC.L	106060631
   3707  80d0
   3708  80d0		       00 34	   C5	      =	(* & $3ff)/4
   3709  80d0		       dd 96 b2 06	      DC.L	112367325
   3710  80d4
   3711  80d4		       00 35	   C5s	      =	(* & $3ff)/4
   3712  80d4		       4a 8b 18 07	      DC.L	119049034
   3713  80d8
   3714  80d8		       00 36	   D5	      =	(* & $3ff)/4
   3715  80d8		       b9 8f 84 07	      DC.L	126128057
   3716  80dc
   3717  80dc		       00 37	   D5s	      =	(* & $3ff)/4
   3718  80dc		       76 00 f7 07	      DC.L	133628022
   3719  80e0
   3720  80e0		       00 38	   E5	      =	(* & $3ff)/4
   3721  80e0		       46 3f 70 08	      DC.L	141573958
   3722  80e4
   3723  80e4		       00 39	   F5	      =	(* & $3ff)/4
   3724  80e4		       bf b3 f0 08	      DC.L	149992383
   3725  80e8
   3726  80e8		       00 3a	   F5s	      =	(* & $3ff)/4
   3727  80e8		       a3 cb 78 09	      DC.L	158911395
   3728  80ec
   3729  80ec		       00 3b	   G5	      =	(* & $3ff)/4
   3730  80ec		       36 fb 08 0a	      DC.L	168360758
   3731  80f0
   3732  80f0		       00 3c	   G5s	      =	(* & $3ff)/4
   3733  80f0		       a9 bd a1 0a	      DC.L	178372009
   3734  80f4
   3735  80f4		       00 3d	   A5	      =	(* & $3ff)/4
   3736  80f4		       81 95 43 0b	      DC.L	188978561
   3737  80f8
   3738  80f8		       00 3e	   A5s	      =	(* & $3ff)/4
   3739  80f8		       03 0d ef 0b	      DC.L	200215811
   3740  80fc
   3741  80fc		       00 3f	   B5	      =	(* & $3ff)/4
   3742  80fc		       af b6 a4 0c	      DC.L	212121263
   3743  8100
   3744  8100		       00 40	   C6	      =	(* & $3ff)/4
   3745  8100		       b9 2d 65 0d	      DC.L	224734649
   3746  8104
   3747  8104		       00 41	   C6s	      =	(* & $3ff)/4
   3748  8104		       93 16 31 0e	      DC.L	238098067
   3749  8108
   3750  8108		       00 42	   D6	      =	(* & $3ff)/4
   3751  8108		       73 1f 09 0f	      DC.L	252256115
   3752  810c
   3753  810c		       00 43	   D6s	      =	(* & $3ff)/4
   3754  810c		       ec 00 ee 0f	      DC.L	267256044
   3755  8110
   3756  8110		       00 44	   E6	      =	(* & $3ff)/4
   3757  8110		       8b 7e e0 10	      DC.L	283147915
   3758  8114
   3759  8114		       00 45	   F6	      =	(* & $3ff)/4
   3760  8114		       7f 67 e1 11	      DC.L	299984767
   3761  8118
   3762  8118		       00 46	   F6s	      =	(* & $3ff)/4
   3763  8118		       45 97 f1 12	      DC.L	317822789
   3764  811c
   3765  811c		       00 47	   G6	      =	(* & $3ff)/4
   3766  811c		       6c f6 11 14	      DC.L	336721516
   3767  8120
   3768  8120		       00 48	   G6s	      =	(* & $3ff)/4
   3769  8120		       53 7b 43 15	      DC.L	356744019
   3770  8124
   3771  8124		       00 49	   A6	      =	(* & $3ff)/4
   3772  8124		       02 2b 87 16	      DC.L	377957122
   3773  8128
   3774  8128		       00 4a	   A6s	      =	(* & $3ff)/4
   3775  8128		       06 1a de 17	      DC.L	400431622
   3776  812c
   3777  812c		       00 4b	   B6	      =	(* & $3ff)/4
   3778  812c		       5d 6d 49 19	      DC.L	424242525
   3779  8130
   3780  8130		       00 4c	   C7	      =	(* & $3ff)/4
   3781  8130		       73 5b ca 1a	      DC.L	449469299
   3782  8134
   3783  8134		       00 4d	   C7s	      =	(* & $3ff)/4
   3784  8134		       26 2d 62 1c	      DC.L	476196134
   3785  8138
   3786  8138		       00 4e	   D7	      =	(* & $3ff)/4
   3787  8138		       e6 3e 12 1e	      DC.L	504512230
   3788  813c
   3789  813c		       00 4f	   D7s	      =	(* & $3ff)/4
   3790  813c		       d8 01 dc 1f	      DC.L	534512088
   3791  8140
   3792  8140		       00 50	   E7	      =	(* & $3ff)/4
   3793  8140		       17 fd c0 21	      DC.L	566295831
   3794  8144
   3795  8144		       00 51	   F7	      =	(* & $3ff)/4
   3796  8144		       fd ce c2 23	      DC.L	599969533
   3797  8148
   3798  8148		       00 52	   F7s	      =	(* & $3ff)/4
   3799  8148		       8a 2e e3 25	      DC.L	635645578
   3800  814c
   3801  814c		       00 53	   G7	      =	(* & $3ff)/4
   3802  814c		       d7 ec 23 28	      DC.L	673443031
   3803  8150
   3804  8150		       00 54	   G7s	      =	(* & $3ff)/4
   3805  8150		       a6 f6 86 2a	      DC.L	713488038
   3806  8154
   3807  8154		       00 55	   A7	      =	(* & $3ff)/4
   3808  8154		       04 56 0e 2d	      DC.L	755914244
   3809  8158
   3810  8158		       00 56	   A7s	      =	(* & $3ff)/4
   3811  8158		       0c 34 bc 2f	      DC.L	800863244
   3812  815c
   3813  815c		       00 57	   B7	      =	(* & $3ff)/4
   3814  815c		       bb da 92 32	      DC.L	848485051
   3815  8160
   3816  8160		       00 58	   C8	      =	(* & $3ff)/4
   3817  8160		       e5 b6 94 35	      DC.L	898938597
   3818  8164
   3819  8164							;values for 89-255 may go here
   3820  8164
   3821  8164					      if	(* <= $1400)
   3822  8164		       00 00 00 00*	      ds	($1400-*)	; pad out remaining space in frequency table
   3823  8400				  -	      else
   3824  8400				  -	      echo	"FATAL ERROR - Frequency table exceeds 1K"
   3825  8400				  -	      err
   3826  8400					      endif
